

/* automatically generated by rust-bindgen */

#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub mod lang_items {
    pub enum c_void {}
    pub type c_char = u8;
    pub type c_int = i32;
    pub type c_long = i64;
    pub type c_longlong = i64;
    pub type c_schar = i8;
    pub type c_short = i16;
    pub type c_uchar = u8;
    pub type c_uint = u32;
    pub type c_ulong = u64;
    pub type c_ulonglong = u64;
    pub type c_ushort = u16;
    pub type size_t = u64;
    pub type ssize_t = i64;
    pub type c_float = f32;
    pub type c_double = f64;
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const __error_t_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 0;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 0;
pub const __OBSOLETE_MATH: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const MALLOC_ALIGNMENT: u32 = 16;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 2usize] = b"l\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 2usize] = b"l\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 2usize] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const MB_LEN_MAX: u32 = 8;
pub const NL_ARGMAX: u32 = 32;
pub const CHAR_MIN: u32 = 0;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 4096;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 56;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 14;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_PIX_FMT_FLAG_BE: u32 = 1;
pub const AV_PIX_FMT_FLAG_PAL: u32 = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: u32 = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: u32 = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: u32 = 16;
pub const AV_PIX_FMT_FLAG_RGB: u32 = 32;
pub const AV_PIX_FMT_FLAG_PSEUDOPAL: u32 = 64;
pub const AV_PIX_FMT_FLAG_ALPHA: u32 = 128;
pub const AV_PIX_FMT_FLAG_BAYER: u32 = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: u32 = 512;
pub const FF_LOSS_RESOLUTION: u32 = 1;
pub const FF_LOSS_DEPTH: u32 = 2;
pub const FF_LOSS_COLORSPACE: u32 = 4;
pub const FF_LOSS_ALPHA: u32 = 8;
pub const FF_LOSS_COLORQUANT: u32 = 16;
pub const FF_LOSS_CHROMA: u32 = 32;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_OPT_FLAG_ENCODING_PARAM: u32 = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: u32 = 2;
pub const AV_OPT_FLAG_AUDIO_PARAM: u32 = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: u32 = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: u32 = 32;
pub const AV_OPT_FLAG_EXPORT: u32 = 64;
pub const AV_OPT_FLAG_READONLY: u32 = 128;
pub const AV_OPT_FLAG_BSF_PARAM: u32 = 256;
pub const AV_OPT_FLAG_FILTERING_PARAM: u32 = 65536;
pub const AV_OPT_SEARCH_CHILDREN: u32 = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: u32 = 2;
pub const AV_OPT_ALLOW_NULL: u32 = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: u32 = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: u32 = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: u32 = 2;
pub const _CLOCKS_PER_SEC_: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const CLK_TCK: u32 = 100;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: u32 = 1;
pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
pub const AV_CPU_FLAG_MMX2: u32 = 2;
pub const AV_CPU_FLAG_3DNOW: u32 = 4;
pub const AV_CPU_FLAG_SSE: u32 = 8;
pub const AV_CPU_FLAG_SSE2: u32 = 16;
pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const AV_CPU_FLAG_SSE3: u32 = 64;
pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
pub const AV_CPU_FLAG_SSSE3: u32 = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: u32 = 67108864;
pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
pub const AV_CPU_FLAG_SSE4: u32 = 256;
pub const AV_CPU_FLAG_SSE42: u32 = 512;
pub const AV_CPU_FLAG_AESNI: u32 = 524288;
pub const AV_CPU_FLAG_AVX: u32 = 16384;
pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
pub const AV_CPU_FLAG_XOP: u32 = 1024;
pub const AV_CPU_FLAG_FMA4: u32 = 2048;
pub const AV_CPU_FLAG_CMOV: u32 = 4096;
pub const AV_CPU_FLAG_AVX2: u32 = 32768;
pub const AV_CPU_FLAG_FMA3: u32 = 65536;
pub const AV_CPU_FLAG_BMI1: u32 = 131072;
pub const AV_CPU_FLAG_BMI2: u32 = 262144;
pub const AV_CPU_FLAG_AVX512: u32 = 1048576;
pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
pub const AV_CPU_FLAG_VSX: u32 = 2;
pub const AV_CPU_FLAG_POWER8: u32 = 4;
pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
pub const AV_CPU_FLAG_ARMV6: u32 = 2;
pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
pub const AV_CPU_FLAG_VFP: u32 = 8;
pub const AV_CPU_FLAG_VFPV3: u32 = 16;
pub const AV_CPU_FLAG_NEON: u32 = 32;
pub const AV_CPU_FLAG_ARMV8: u32 = 64;
pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
pub const AV_CPU_FLAG_SETEND: u32 = 65536;
pub const AV_CH_FRONT_LEFT: u32 = 1;
pub const AV_CH_FRONT_RIGHT: u32 = 2;
pub const AV_CH_FRONT_CENTER: u32 = 4;
pub const AV_CH_LOW_FREQUENCY: u32 = 8;
pub const AV_CH_BACK_LEFT: u32 = 16;
pub const AV_CH_BACK_RIGHT: u32 = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: u32 = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: u32 = 128;
pub const AV_CH_BACK_CENTER: u32 = 256;
pub const AV_CH_SIDE_LEFT: u32 = 512;
pub const AV_CH_SIDE_RIGHT: u32 = 1024;
pub const AV_CH_TOP_CENTER: u32 = 2048;
pub const AV_CH_TOP_FRONT_LEFT: u32 = 4096;
pub const AV_CH_TOP_FRONT_CENTER: u32 = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: u32 = 16384;
pub const AV_CH_TOP_BACK_LEFT: u32 = 32768;
pub const AV_CH_TOP_BACK_CENTER: u32 = 65536;
pub const AV_CH_TOP_BACK_RIGHT: u32 = 131072;
pub const AV_CH_STEREO_LEFT: u32 = 536870912;
pub const AV_CH_STEREO_RIGHT: u32 = 1073741824;
pub const AV_CH_WIDE_LEFT: u32 = 2147483648;
pub const AV_CH_WIDE_RIGHT: u64 = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: u64 = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: u64 = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: u64 = 34359738368;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_CH_LAYOUT_MONO: u32 = 4;
pub const AV_CH_LAYOUT_STEREO: u32 = 3;
pub const AV_CH_LAYOUT_2POINT1: u32 = 11;
pub const AV_CH_LAYOUT_2_1: u32 = 259;
pub const AV_CH_LAYOUT_SURROUND: u32 = 7;
pub const AV_CH_LAYOUT_3POINT1: u32 = 15;
pub const AV_CH_LAYOUT_4POINT0: u32 = 263;
pub const AV_CH_LAYOUT_4POINT1: u32 = 271;
pub const AV_CH_LAYOUT_2_2: u32 = 1539;
pub const AV_CH_LAYOUT_QUAD: u32 = 51;
pub const AV_CH_LAYOUT_5POINT0: u32 = 1543;
pub const AV_CH_LAYOUT_5POINT1: u32 = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: u32 = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: u32 = 63;
pub const AV_CH_LAYOUT_6POINT0: u32 = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: u32 = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: u32 = 311;
pub const AV_CH_LAYOUT_6POINT1: u32 = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: u32 = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: u32 = 1739;
pub const AV_CH_LAYOUT_7POINT0: u32 = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: u32 = 1735;
pub const AV_CH_LAYOUT_7POINT1: u32 = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: u32 = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: u32 = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: u32 = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: u64 = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: u32 = 1610612736;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 58;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 18;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 100;
pub const AV_CODEC_PROP_INTRA_ONLY: u32 = 1;
pub const AV_CODEC_PROP_LOSSY: u32 = 2;
pub const AV_CODEC_PROP_LOSSLESS: u32 = 4;
pub const AV_CODEC_PROP_REORDER: u32 = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: u32 = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: u32 = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: u32 = 64;
pub const AV_INPUT_BUFFER_MIN_SIZE: u32 = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: u32 = 1;
pub const AV_CODEC_FLAG_QSCALE: u32 = 2;
pub const AV_CODEC_FLAG_4MV: u32 = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const AV_CODEC_FLAG_QPEL: u32 = 16;
pub const AV_CODEC_FLAG_PASS1: u32 = 512;
pub const AV_CODEC_FLAG_PASS2: u32 = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const AV_CODEC_FLAG_GRAY: u32 = 8192;
pub const AV_CODEC_FLAG_PSNR: u32 = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: u32 = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: u32 = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: u32 = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: u32 = 1073741824;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const AV_CODEC_CAP_DR1: u32 = 2;
pub const AV_CODEC_CAP_TRUNCATED: u32 = 8;
pub const AV_CODEC_CAP_DELAY: u32 = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const AV_CODEC_CAP_SUBFRAMES: u32 = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const AV_CODEC_CAP_AUTO_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: u32 = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: u32 = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const AV_CODEC_CAP_HARDWARE: u32 = 262144;
pub const AV_CODEC_CAP_HYBRID: u32 = 524288;
pub const AV_GET_BUFFER_FLAG_REF: u32 = 1;
pub const AV_PKT_FLAG_KEY: u32 = 1;
pub const AV_PKT_FLAG_CORRUPT: u32 = 2;
pub const AV_PKT_FLAG_DISCARD: u32 = 4;
pub const AV_PKT_FLAG_TRUSTED: u32 = 8;
pub const AV_PKT_FLAG_DISPOSABLE: u32 = 16;
pub const FF_COMPRESSION_DEFAULT: i32 = -1;
pub const FF_PRED_LEFT: u32 = 0;
pub const FF_PRED_PLANE: u32 = 1;
pub const FF_PRED_MEDIAN: u32 = 2;
pub const FF_CMP_SAD: u32 = 0;
pub const FF_CMP_SSE: u32 = 1;
pub const FF_CMP_SATD: u32 = 2;
pub const FF_CMP_DCT: u32 = 3;
pub const FF_CMP_PSNR: u32 = 4;
pub const FF_CMP_BIT: u32 = 5;
pub const FF_CMP_RD: u32 = 6;
pub const FF_CMP_ZERO: u32 = 7;
pub const FF_CMP_VSAD: u32 = 8;
pub const FF_CMP_VSSE: u32 = 9;
pub const FF_CMP_NSSE: u32 = 10;
pub const FF_CMP_W53: u32 = 11;
pub const FF_CMP_W97: u32 = 12;
pub const FF_CMP_DCTMAX: u32 = 13;
pub const FF_CMP_DCT264: u32 = 14;
pub const FF_CMP_MEDIAN_SAD: u32 = 15;
pub const FF_CMP_CHROMA: u32 = 256;
pub const SLICE_FLAG_CODED_ORDER: u32 = 1;
pub const SLICE_FLAG_ALLOW_FIELD: u32 = 2;
pub const SLICE_FLAG_ALLOW_PLANE: u32 = 4;
pub const FF_MB_DECISION_SIMPLE: u32 = 0;
pub const FF_MB_DECISION_BITS: u32 = 1;
pub const FF_MB_DECISION_RD: u32 = 2;
pub const FF_CODER_TYPE_VLC: u32 = 0;
pub const FF_CODER_TYPE_AC: u32 = 1;
pub const FF_CODER_TYPE_RAW: u32 = 2;
pub const FF_CODER_TYPE_RLE: u32 = 3;
pub const FF_BUG_AUTODETECT: u32 = 1;
pub const FF_BUG_XVID_ILACE: u32 = 4;
pub const FF_BUG_UMP4: u32 = 8;
pub const FF_BUG_NO_PADDING: u32 = 16;
pub const FF_BUG_AMV: u32 = 32;
pub const FF_BUG_QPEL_CHROMA: u32 = 64;
pub const FF_BUG_STD_QPEL: u32 = 128;
pub const FF_BUG_QPEL_CHROMA2: u32 = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: u32 = 512;
pub const FF_BUG_EDGE: u32 = 1024;
pub const FF_BUG_HPEL_CHROMA: u32 = 2048;
pub const FF_BUG_DC_CLIP: u32 = 4096;
pub const FF_BUG_MS: u32 = 8192;
pub const FF_BUG_TRUNCATED: u32 = 16384;
pub const FF_BUG_IEDGE: u32 = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: u32 = 2;
pub const FF_COMPLIANCE_STRICT: u32 = 1;
pub const FF_COMPLIANCE_NORMAL: u32 = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: i32 = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: i32 = -2;
pub const FF_EC_GUESS_MVS: u32 = 1;
pub const FF_EC_DEBLOCK: u32 = 2;
pub const FF_EC_FAVOR_INTER: u32 = 256;
pub const FF_DEBUG_PICT_INFO: u32 = 1;
pub const FF_DEBUG_RC: u32 = 2;
pub const FF_DEBUG_BITSTREAM: u32 = 4;
pub const FF_DEBUG_MB_TYPE: u32 = 8;
pub const FF_DEBUG_QP: u32 = 16;
pub const FF_DEBUG_DCT_COEFF: u32 = 64;
pub const FF_DEBUG_SKIP: u32 = 128;
pub const FF_DEBUG_STARTCODE: u32 = 256;
pub const FF_DEBUG_ER: u32 = 1024;
pub const FF_DEBUG_MMCO: u32 = 2048;
pub const FF_DEBUG_BUGS: u32 = 4096;
pub const FF_DEBUG_BUFFERS: u32 = 32768;
pub const FF_DEBUG_THREADS: u32 = 65536;
pub const FF_DEBUG_GREEN_MD: u32 = 8388608;
pub const FF_DEBUG_NOMC: u32 = 16777216;
pub const AV_EF_CRCCHECK: u32 = 1;
pub const AV_EF_BITSTREAM: u32 = 2;
pub const AV_EF_BUFFER: u32 = 4;
pub const AV_EF_EXPLODE: u32 = 8;
pub const AV_EF_IGNORE_ERR: u32 = 32768;
pub const AV_EF_CAREFUL: u32 = 65536;
pub const AV_EF_COMPLIANT: u32 = 131072;
pub const AV_EF_AGGRESSIVE: u32 = 262144;
pub const FF_DCT_AUTO: u32 = 0;
pub const FF_DCT_FASTINT: u32 = 1;
pub const FF_DCT_INT: u32 = 2;
pub const FF_DCT_MMX: u32 = 3;
pub const FF_DCT_ALTIVEC: u32 = 5;
pub const FF_DCT_FAAN: u32 = 6;
pub const FF_IDCT_AUTO: u32 = 0;
pub const FF_IDCT_INT: u32 = 1;
pub const FF_IDCT_SIMPLE: u32 = 2;
pub const FF_IDCT_SIMPLEMMX: u32 = 3;
pub const FF_IDCT_ARM: u32 = 7;
pub const FF_IDCT_ALTIVEC: u32 = 8;
pub const FF_IDCT_SIMPLEARM: u32 = 10;
pub const FF_IDCT_XVID: u32 = 14;
pub const FF_IDCT_SIMPLEARMV5TE: u32 = 16;
pub const FF_IDCT_SIMPLEARMV6: u32 = 17;
pub const FF_IDCT_FAAN: u32 = 20;
pub const FF_IDCT_SIMPLENEON: u32 = 22;
pub const FF_IDCT_NONE: u32 = 24;
pub const FF_IDCT_SIMPLEAUTO: u32 = 128;
pub const FF_THREAD_FRAME: u32 = 1;
pub const FF_THREAD_SLICE: u32 = 2;
pub const FF_PROFILE_UNKNOWN: i32 = -99;
pub const FF_PROFILE_RESERVED: i32 = -100;
pub const FF_PROFILE_AAC_MAIN: u32 = 0;
pub const FF_PROFILE_AAC_LOW: u32 = 1;
pub const FF_PROFILE_AAC_SSR: u32 = 2;
pub const FF_PROFILE_AAC_LTP: u32 = 3;
pub const FF_PROFILE_AAC_HE: u32 = 4;
pub const FF_PROFILE_AAC_HE_V2: u32 = 28;
pub const FF_PROFILE_AAC_LD: u32 = 22;
pub const FF_PROFILE_AAC_ELD: u32 = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const FF_PROFILE_DNXHD: u32 = 0;
pub const FF_PROFILE_DNXHR_LB: u32 = 1;
pub const FF_PROFILE_DNXHR_SQ: u32 = 2;
pub const FF_PROFILE_DNXHR_HQ: u32 = 3;
pub const FF_PROFILE_DNXHR_HQX: u32 = 4;
pub const FF_PROFILE_DNXHR_444: u32 = 5;
pub const FF_PROFILE_DTS: u32 = 20;
pub const FF_PROFILE_DTS_ES: u32 = 30;
pub const FF_PROFILE_DTS_96_24: u32 = 40;
pub const FF_PROFILE_DTS_HD_HRA: u32 = 50;
pub const FF_PROFILE_DTS_HD_MA: u32 = 60;
pub const FF_PROFILE_DTS_EXPRESS: u32 = 70;
pub const FF_PROFILE_MPEG2_422: u32 = 0;
pub const FF_PROFILE_MPEG2_HIGH: u32 = 1;
pub const FF_PROFILE_MPEG2_SS: u32 = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const FF_PROFILE_MPEG2_MAIN: u32 = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const FF_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const FF_PROFILE_H264_INTRA: u32 = 2048;
pub const FF_PROFILE_H264_BASELINE: u32 = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const FF_PROFILE_H264_MAIN: u32 = 77;
pub const FF_PROFILE_H264_EXTENDED: u32 = 88;
pub const FF_PROFILE_H264_HIGH: u32 = 100;
pub const FF_PROFILE_H264_HIGH_10: u32 = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const FF_PROFILE_H264_HIGH_422: u32 = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const FF_PROFILE_H264_HIGH_444: u32 = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const FF_PROFILE_H264_CAVLC_444: u32 = 44;
pub const FF_PROFILE_VC1_SIMPLE: u32 = 0;
pub const FF_PROFILE_VC1_MAIN: u32 = 1;
pub const FF_PROFILE_VC1_COMPLEX: u32 = 2;
pub const FF_PROFILE_VC1_ADVANCED: u32 = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const FF_PROFILE_MPEG4_CORE: u32 = 2;
pub const FF_PROFILE_MPEG4_MAIN: u32 = 3;
pub const FF_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const FF_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const FF_PROFILE_VP9_0: u32 = 0;
pub const FF_PROFILE_VP9_1: u32 = 1;
pub const FF_PROFILE_VP9_2: u32 = 2;
pub const FF_PROFILE_VP9_3: u32 = 3;
pub const FF_PROFILE_HEVC_MAIN: u32 = 1;
pub const FF_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const FF_PROFILE_HEVC_REXT: u32 = 4;
pub const FF_PROFILE_AV1_MAIN: u32 = 0;
pub const FF_PROFILE_AV1_HIGH: u32 = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: u32 = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: u32 = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: u32 = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: u32 = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: u32 = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: u32 = 247;
pub const FF_PROFILE_SBC_MSBC: u32 = 1;
pub const FF_LEVEL_UNKNOWN: i32 = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: i32 = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: u32 = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: u32 = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: u32 = 2;
pub const FF_DEBUG_VIS_MV_P_FOR: u32 = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: u32 = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: u32 = 4;
pub const FF_CODEC_PROPERTY_LOSSLESS: u32 = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: u32 = 2;
pub const FF_SUB_TEXT_FMT_ASS: u32 = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: u32 = 1;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: u32 = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: u32 = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: u32 = 4;
pub const AV_SUBTITLE_FLAG_FORCED: u32 = 1;
pub const AV_PARSER_PTS_NB: u32 = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: u32 = 1;
pub const PARSER_FLAG_ONCE: u32 = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: u32 = 4;
pub const PARSER_FLAG_USE_CODEC_TS: u32 = 4096;
pub const LIBAVFORMAT_VERSION_MAJOR: u32 = 58;
pub const LIBAVFORMAT_VERSION_MINOR: u32 = 12;
pub const LIBAVFORMAT_VERSION_MICRO: u32 = 100;
pub const FF_API_R_FRAME_RATE: u32 = 1;
pub const AVIO_SEEKABLE_NORMAL: u32 = 1;
pub const AVIO_SEEKABLE_TIME: u32 = 2;
pub const AVSEEK_SIZE: u32 = 65536;
pub const AVSEEK_FORCE: u32 = 131072;
pub const AVIO_FLAG_READ: u32 = 1;
pub const AVIO_FLAG_WRITE: u32 = 2;
pub const AVIO_FLAG_READ_WRITE: u32 = 3;
pub const AVIO_FLAG_NONBLOCK: u32 = 8;
pub const AVIO_FLAG_DIRECT: u32 = 32768;
pub const AVPROBE_SCORE_EXTENSION: u32 = 50;
pub const AVPROBE_SCORE_MIME: u32 = 75;
pub const AVPROBE_SCORE_MAX: u32 = 100;
pub const AVPROBE_PADDING_SIZE: u32 = 32;
pub const AVFMT_NOFILE: u32 = 1;
pub const AVFMT_NEEDNUMBER: u32 = 2;
pub const AVFMT_SHOW_IDS: u32 = 8;
pub const AVFMT_GLOBALHEADER: u32 = 64;
pub const AVFMT_NOTIMESTAMPS: u32 = 128;
pub const AVFMT_GENERIC_INDEX: u32 = 256;
pub const AVFMT_TS_DISCONT: u32 = 512;
pub const AVFMT_VARIABLE_FPS: u32 = 1024;
pub const AVFMT_NODIMENSIONS: u32 = 2048;
pub const AVFMT_NOSTREAMS: u32 = 4096;
pub const AVFMT_NOBINSEARCH: u32 = 8192;
pub const AVFMT_NOGENSEARCH: u32 = 16384;
pub const AVFMT_NO_BYTE_SEEK: u32 = 32768;
pub const AVFMT_ALLOW_FLUSH: u32 = 65536;
pub const AVFMT_TS_NONSTRICT: u32 = 131072;
pub const AVFMT_TS_NEGATIVE: u32 = 262144;
pub const AVFMT_SEEK_TO_PTS: u32 = 67108864;
pub const AVINDEX_KEYFRAME: u32 = 1;
pub const AVINDEX_DISCARD_FRAME: u32 = 2;
pub const AV_DISPOSITION_DEFAULT: u32 = 1;
pub const AV_DISPOSITION_DUB: u32 = 2;
pub const AV_DISPOSITION_ORIGINAL: u32 = 4;
pub const AV_DISPOSITION_COMMENT: u32 = 8;
pub const AV_DISPOSITION_LYRICS: u32 = 16;
pub const AV_DISPOSITION_KARAOKE: u32 = 32;
pub const AV_DISPOSITION_FORCED: u32 = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: u32 = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: u32 = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: u32 = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: u32 = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: u32 = 2048;
pub const AV_DISPOSITION_CAPTIONS: u32 = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: u32 = 131072;
pub const AV_DISPOSITION_METADATA: u32 = 262144;
pub const AV_DISPOSITION_DEPENDENT: u32 = 524288;
pub const AV_PTS_WRAP_IGNORE: u32 = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: u32 = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: i32 = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const MAX_STD_TIMEBASES: u32 = 399;
pub const MAX_REORDER_DELAY: u32 = 16;
pub const AV_PROGRAM_RUNNING: u32 = 1;
pub const AVFMTCTX_NOHEADER: u32 = 1;
pub const AVFMTCTX_UNSEEKABLE: u32 = 2;
pub const AVFMT_FLAG_GENPTS: u32 = 1;
pub const AVFMT_FLAG_IGNIDX: u32 = 2;
pub const AVFMT_FLAG_NONBLOCK: u32 = 4;
pub const AVFMT_FLAG_IGNDTS: u32 = 8;
pub const AVFMT_FLAG_NOFILLIN: u32 = 16;
pub const AVFMT_FLAG_NOPARSE: u32 = 32;
pub const AVFMT_FLAG_NOBUFFER: u32 = 64;
pub const AVFMT_FLAG_CUSTOM_IO: u32 = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: u32 = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: u32 = 512;
pub const AVFMT_FLAG_BITEXACT: u32 = 1024;
pub const AVFMT_FLAG_MP4A_LATM: u32 = 32768;
pub const AVFMT_FLAG_SORT_DTS: u32 = 65536;
pub const AVFMT_FLAG_PRIV_OPT: u32 = 131072;
pub const AVFMT_FLAG_KEEP_SIDE_DATA: u32 = 262144;
pub const AVFMT_FLAG_FAST_SEEK: u32 = 524288;
pub const AVFMT_FLAG_SHORTEST: u32 = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: u32 = 2097152;
pub const FF_FDEBUG_TS: u32 = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: i32 = -1;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: u32 = 2;
pub const AVSEEK_FLAG_BACKWARD: u32 = 1;
pub const AVSEEK_FLAG_BYTE: u32 = 2;
pub const AVSEEK_FLAG_ANY: u32 = 4;
pub const AVSEEK_FLAG_FRAME: u32 = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: u32 = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: u32 = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: u32 = 1;
pub const LIBSWSCALE_VERSION_MAJOR: u32 = 5;
pub const LIBSWSCALE_VERSION_MINOR: u32 = 1;
pub const LIBSWSCALE_VERSION_MICRO: u32 = 100;
pub const SWS_FAST_BILINEAR: u32 = 1;
pub const SWS_BILINEAR: u32 = 2;
pub const SWS_BICUBIC: u32 = 4;
pub const SWS_X: u32 = 8;
pub const SWS_POINT: u32 = 16;
pub const SWS_AREA: u32 = 32;
pub const SWS_BICUBLIN: u32 = 64;
pub const SWS_GAUSS: u32 = 128;
pub const SWS_SINC: u32 = 256;
pub const SWS_LANCZOS: u32 = 512;
pub const SWS_SPLINE: u32 = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: u32 = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: u32 = 16;
pub const SWS_PARAM_DEFAULT: u32 = 123456;
pub const SWS_PRINT_INFO: u32 = 4096;
pub const SWS_FULL_CHR_H_INT: u32 = 8192;
pub const SWS_FULL_CHR_H_INP: u32 = 16384;
pub const SWS_DIRECT_BGR: u32 = 32768;
pub const SWS_ACCURATE_RND: u32 = 262144;
pub const SWS_BITEXACT: u32 = 524288;
pub const SWS_ERROR_DIFFUSION: u32 = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: u32 = 1;
pub const SWS_CS_FCC: u32 = 4;
pub const SWS_CS_ITU601: u32 = 5;
pub const SWS_CS_ITU624: u32 = 5;
pub const SWS_CS_SMPTE170M: u32 = 5;
pub const SWS_CS_SMPTE240M: u32 = 7;
pub const SWS_CS_DEFAULT: u32 = 5;
pub const SWS_CS_BT2020: u32 = 9;
pub const LIBSWRESAMPLE_VERSION_MAJOR: u32 = 3;
pub const LIBSWRESAMPLE_VERSION_MINOR: u32 = 1;
pub const LIBSWRESAMPLE_VERSION_MICRO: u32 = 100;
pub const SWR_FLAG_RESAMPLE: u32 = 1;
extern "C" {
    /// Return the LIBAVUTIL_VERSION_INT constant.
    pub fn avutil_version() -> lang_items::c_uint;
}
extern "C" {
    /// Return an informative version string. This usually is the actual release
    /// version number or a git commit description. This string has no fixed format
    /// and can change any time. It should never be parsed by code.
    pub fn av_version_info() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the libavutil build-time configuration.
    pub fn avutil_configuration() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the libavutil license.
    pub fn avutil_license() -> *const lang_items::c_char;
}
/// < Usually treated as AVMEDIA_TYPE_DATA
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
/// < Opaque data information usually continuous
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
/// < Opaque data information usually sparse
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
/// @addtogroup lavu_media Media Type
/// @brief Media Type
pub type AVMediaType = i32;
extern "C" {
    /// Return a string describing the media_type enum, NULL if media_type
    /// is unknown.
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const lang_items::c_char;
}
/// < Undefined
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
/// < Intra
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
/// < Predicted
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
/// < Bi-dir predicted
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
/// < S(GMC)-VOP MPEG-4
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
/// < Switching Intra
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
/// < Switching Predicted
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
/// < BI type
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
/// @}
/// @}
/// @defgroup lavu_picture Image related
///
/// AVPicture types, pixel formats and basic image planes manipulation.
///
/// @{
pub type AVPictureType = u32;
extern "C" {
    /// Return a single letter to describe the given picture type
    /// pict_type.
    ///
    /// @param[in] pict_type the picture type @return a single character
    /// representing the picture type, '?' if pict_type is unknown
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> lang_items::c_char;
}
pub type error_t = lang_items::c_int;
pub type wchar_t = lang_items::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: lang_items::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<max_align_t>())).__max_align_ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<max_align_t>())).__max_align_ld as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
pub type __int8_t = lang_items::c_schar;
pub type __uint8_t = lang_items::c_uchar;
pub type __int16_t = lang_items::c_short;
pub type __uint16_t = lang_items::c_ushort;
pub type __int32_t = lang_items::c_int;
pub type __uint32_t = lang_items::c_uint;
pub type __int64_t = lang_items::c_long;
pub type __uint64_t = lang_items::c_ulong;
pub type __int_least8_t = lang_items::c_schar;
pub type __uint_least8_t = lang_items::c_uchar;
pub type __int_least16_t = lang_items::c_short;
pub type __uint_least16_t = lang_items::c_ushort;
pub type __int_least32_t = lang_items::c_int;
pub type __uint_least32_t = lang_items::c_uint;
pub type __int_least64_t = lang_items::c_long;
pub type __uint_least64_t = lang_items::c_ulong;
pub type __intmax_t = lang_items::c_long;
pub type __uintmax_t = lang_items::c_ulong;
pub type __intptr_t = lang_items::c_long;
pub type __uintptr_t = lang_items::c_ulong;
pub type _ssize_t = lang_items::c_long;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = lang_items::c_schar;
pub type uint_fast8_t = lang_items::c_uchar;
pub type int_fast16_t = lang_items::c_short;
pub type uint_fast16_t = lang_items::c_ushort;
pub type int_fast32_t = lang_items::c_int;
pub type uint_fast32_t = lang_items::c_uint;
pub type int_fast64_t = lang_items::c_long;
pub type uint_fast64_t = lang_items::c_ulong;
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
#[test]
fn bindgen_test_layout___lock_t() {
    assert_eq!(
        std::mem::size_of::<__lock_t>(),
        12usize,
        concat!("Size of: ", stringify!(__lock_t))
    );
    assert_eq!(
        std::mem::align_of::<__lock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__lock_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__lock_t>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__lock_t>())).thread_tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(thread_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__lock_t>())).counter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(counter)
        )
    );
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> lang_items::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> lang_items::c_int;
}
pub type __blkcnt_t = lang_items::c_long;
pub type __blksize_t = lang_items::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = lang_items::c_long;
pub type __pid_t = lang_items::c_int;
pub type __dev_t = lang_items::c_short;
pub type __uid_t = lang_items::c_ushort;
pub type __gid_t = lang_items::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = lang_items::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = lang_items::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = lang_items::c_long;
pub type _fpos_t = lang_items::c_long;
pub type __size_t = lang_items::c_ulong;
pub type __ssize_t = _ssize_t;
pub type wint_t = lang_items::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: lang_items::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [lang_items::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        std::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        std::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        std::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        std::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut lang_items::c_void;
pub type __clock_t = lang_items::c_ulong;
pub type __time_t = lang_items::c_long;
pub type __clockid_t = lang_items::c_ulong;
pub type __timer_t = lang_items::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = lang_items::c_ushort;
pub type __suseconds_t = lang_items::c_long;
pub type __useconds_t = lang_items::c_ulong;
//pub type __va_list = *mut lang_items::c_char;
pub type __ULong = lang_items::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: lang_items::c_int,
    pub _maxwds: lang_items::c_int,
    pub _sign: lang_items::c_int,
    pub _wds: lang_items::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        std::mem::size_of::<_Bigint>(),
        32usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        std::mem::align_of::<_Bigint>(),
        8usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_Bigint>()))._x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: lang_items::c_int,
    pub __tm_min: lang_items::c_int,
    pub __tm_hour: lang_items::c_int,
    pub __tm_mday: lang_items::c_int,
    pub __tm_mon: lang_items::c_int,
    pub __tm_year: lang_items::c_int,
    pub __tm_wday: lang_items::c_int,
    pub __tm_yday: lang_items::c_int,
    pub __tm_isdst: lang_items::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        std::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        std::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut lang_items::c_void; 32usize],
    pub _dso_handle: [*mut lang_items::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        std::mem::size_of::<_on_exit_args>(),
        520usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        std::mem::align_of::<_on_exit_args>(),
        8usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: lang_items::c_int,
    pub _fns: [std::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        std::mem::size_of::<_atexit>(),
        792usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        std::mem::align_of::<_atexit>(),
        8usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_atexit>()))._ind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_atexit>()))._fns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut lang_items::c_uchar,
    pub _size: lang_items::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut lang_items::c_uchar,
    pub _r: lang_items::c_int,
    pub _w: lang_items::c_int,
    pub _flags: lang_items::c_short,
    pub _file: lang_items::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: lang_items::c_int,
    pub _cookie: *mut lang_items::c_void,
    pub _read: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut lang_items::c_void,
            arg3: *mut lang_items::c_char,
            arg4: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub _write: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut lang_items::c_void,
            arg3: *const lang_items::c_char,
            arg4: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub _seek: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut lang_items::c_void,
            arg3: _fpos_t,
            arg4: lang_items::c_int,
        ) -> _fpos_t,
    >,
    pub _close: std::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut lang_items::c_void) -> lang_items::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut lang_items::c_uchar,
    pub _ur: lang_items::c_int,
    pub _ubuf: [lang_items::c_uchar; 3usize],
    pub _nbuf: [lang_items::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: lang_items::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: lang_items::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        std::mem::size_of::<__sFILE>(),
        184usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._up as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: lang_items::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        std::mem::size_of::<_glue>(),
        24usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        std::mem::align_of::<_glue>(),
        8usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_glue>()))._niobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_glue>()))._iobs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [lang_items::c_ushort; 3usize],
    pub _mult: [lang_items::c_ushort; 3usize],
    pub _add: lang_items::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        std::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        std::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: lang_items::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: lang_items::c_int,
    pub _emergency: [lang_items::c_char; 25usize],
    pub _unspecified_locale_info: lang_items::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: lang_items::c_int,
    pub __cleanup: std::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: lang_items::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: lang_items::c_int,
    pub _cvtbuf: *mut lang_items::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut std::option::Option<unsafe extern "C" fn(arg1: lang_items::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut lang_items::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 45usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: lang_items::c_uint,
    pub _strtok_last: *mut lang_items::c_char,
    pub _asctime_buf: [lang_items::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: lang_items::c_int,
    pub _rand_next: lang_items::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [lang_items::c_char; 8usize],
    pub _signal_buf: [lang_items::c_char; 24usize],
    pub _getdate_err: lang_items::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: lang_items::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        std::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        216usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        std::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut lang_items::c_uchar; 30usize],
    pub _nmalloc: [lang_items::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        std::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        std::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        std::mem::size_of::<_reent__bindgen_ty_1>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        std::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        std::mem::size_of::<_reent>(),
        1896usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        std::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._stdin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._stdout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._stderr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._inc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._emergency as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._locale as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._result as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._result_k as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._p5s as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._freelist as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._new as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._atexit as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>())).__sglue as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>())).__sf as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_reent>())).deviceData as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(deviceData)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub fn __errno() -> *mut lang_items::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const lang_items::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: lang_items::c_int;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const lang_items::c_char,
        arg2: *mut *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut *mut lang_items::c_char,
        arg4: lang_items::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const lang_items::c_char,
        arg2: *mut *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut *mut lang_items::c_char,
        arg4: lang_items::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: lang_items::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: lang_items::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: lang_items::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: lang_items::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const lang_items::c_char,
        _restrict: *mut *mut lang_items::c_char,
        arg2: lang_items::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const lang_items::c_char,
        _restrict: *mut *mut lang_items::c_char,
        arg2: lang_items::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: lang_items::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: lang_items::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut lang_items::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: lang_items::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn finitel(arg1: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn isinff(arg1: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn isnanf(arg1: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn isinf(arg1: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn isnan(arg1: f64) -> lang_items::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(x: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn __isinfd(x: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn __isnanf(x: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn __isnand(x: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn __fpclassifyf(x: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn __fpclassifyd(x: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn __signbitf(x: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn __signbitd(x: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const lang_items::c_char) -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> lang_items::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: lang_items::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: lang_items::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> lang_items::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> lang_items::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> lang_items::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> lang_items::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut lang_items::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut lang_items::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: lang_items::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: lang_items::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> lang_items::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> lang_items::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> lang_items::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> lang_items::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut lang_items::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const lang_items::c_char) -> f32;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> lang_items::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: lang_items::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut lang_items::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut lang_items::c_int) -> f64;
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut lang_items::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut lang_items::c_int) -> f32;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: lang_items::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: lang_items::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: lang_items::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: lang_items::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: lang_items::c_int,
    pub name: *mut lang_items::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
    pub err: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        std::mem::size_of::<exception>(),
        48usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<exception>())).err as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(err)
        )
    );
}
extern "C" {
    pub fn matherr(e: *mut exception) -> lang_items::c_int;
}
pub const __fdlibm_version___fdlibm_ieee: __fdlibm_version = -1;
pub const __fdlibm_version___fdlibm_svid: __fdlibm_version = 0;
pub const __fdlibm_version___fdlibm_xopen: __fdlibm_version = 1;
pub const __fdlibm_version___fdlibm_posix: __fdlibm_version = 2;
pub type __fdlibm_version = i32;
extern "C" {
    pub static mut __fdlib_version: __fdlibm_version;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = lang_items::c_int;
pub type __sigset_t = lang_items::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = lang_items::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: lang_items::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = lang_items::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        std::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        std::mem::align_of::<_types_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: lang_items::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn pselect(
        __n: lang_items::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> lang_items::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = lang_items::c_uchar;
pub type u_short = lang_items::c_ushort;
pub type u_int = lang_items::c_uint;
pub type u_long = lang_items::c_ulong;
pub type ushort = lang_items::c_ushort;
pub type uint = lang_items::c_uint;
pub type ulong = lang_items::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = lang_items::c_ulong;
pub type daddr_t = lang_items::c_long;
pub type caddr_t = *mut lang_items::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: lang_items::c_int,
    pub stackaddr: *mut lang_items::c_void,
    pub stacksize: lang_items::c_int,
    pub contentionscope: lang_items::c_int,
    pub inheritsched: lang_items::c_int,
    pub schedpolicy: lang_items::c_int,
    pub schedparam: sched_param,
    pub detachstate: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        std::mem::size_of::<pthread_attr_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: lang_items::c_int,
    pub recursive: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        std::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: lang_items::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        std::mem::size_of::<pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        std::mem::align_of::<pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: lang_items::c_int,
    pub init_executed: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        std::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        std::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut lang_items::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
        arg4: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn printf(arg1: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const lang_items::c_char, arg2: __gnuc_va_list) -> lang_items::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut lang_items::c_char,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn fputc(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const lang_items::c_char, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn getchar() -> lang_items::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn putc(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn putchar(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn puts(arg1: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn ungetc(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut lang_items::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(
        arg1: *const lang_items::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> lang_items::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: lang_items::c_long,
        arg3: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> lang_items::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> lang_items::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn perror(arg1: *const lang_items::c_char);
}
extern "C" {
    pub fn fopen(_name: *const lang_items::c_char, _type: *const lang_items::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn remove(arg1: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut lang_items::c_char,
        arg2: usize,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut lang_items::c_char,
        arg2: usize,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const lang_items::c_char, arg2: __gnuc_va_list) -> lang_items::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: *const lang_items::c_char,
        ...
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: *const lang_items::c_char,
        ...
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: lang_items::c_int,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut lang_items::c_char,
        arg2: usize,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: lang_items::c_int,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const lang_items::c_char, arg2: __gnuc_va_list) -> lang_items::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const lang_items::c_char, arg2: __gnuc_va_list) -> lang_items::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut lang_items::c_char,
        arg2: usize,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fdopen(arg1: lang_items::c_int, arg2: *const lang_items::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn popen(arg1: *const lang_items::c_char, arg2: *const lang_items::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut lang_items::c_char, arg3: lang_items::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn putw(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> lang_items::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: lang_items::c_int,
        arg2: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut lang_items::c_void,
        arg2: usize,
        arg3: *const lang_items::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut lang_items::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: lang_items::c_int,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: lang_items::c_int,
        arg2: *const lang_items::c_char,
        arg3: lang_items::c_int,
        arg4: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *mut usize,
        arg4: *const lang_items::c_char,
        ...
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *mut usize,
        arg4: *const lang_items::c_char,
        ...
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> lang_items::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
        arg4: *mut FILE,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
        arg4: *mut FILE,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> lang_items::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t)
        -> lang_items::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_void,
        arg3: usize,
        arg4: *const lang_items::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: lang_items::c_long,
        arg4: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> lang_items::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> lang_items::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const lang_items::c_char, ...)
        -> lang_items::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut lang_items::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const lang_items::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const lang_items::c_char,
        _new: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const lang_items::c_char, ...) -> lang_items::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: usize,
        arg4: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: usize,
        arg4: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *mut usize,
        arg4: *const lang_items::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *mut usize,
        arg4: *const lang_items::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: usize,
        arg4: *const lang_items::c_char,
        arg5: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: usize,
        arg4: *const lang_items::c_char,
        arg5: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *const lang_items::c_char,
        arg4: __gnuc_va_list,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: lang_items::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut lang_items::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: lang_items::c_int, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut lang_items::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const lang_items::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> lang_items::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: *mut FILE,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const lang_items::c_void,
        __readfn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __buf: *mut lang_items::c_char,
                __n: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        __writefn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __buf: *const lang_items::c_char,
                __n: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        __seekfn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __off: fpos_t,
                __whence: lang_items::c_int,
            ) -> fpos_t,
        >,
        __closefn: std::option::Option<
            unsafe extern "C" fn(__cookie: *mut lang_items::c_void) -> lang_items::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const lang_items::c_void,
        __readfn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __buf: *mut lang_items::c_char,
                __n: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        __writefn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __buf: *const lang_items::c_char,
                __n: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        __seekfn: std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut lang_items::c_void,
                __off: fpos_t,
                __whence: lang_items::c_int,
            ) -> fpos_t,
        >,
        __closefn: std::option::Option<
            unsafe extern "C" fn(__cookie: *mut lang_items::c_void) -> lang_items::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: lang_items::c_int,
    pub rem: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: lang_items::c_long,
    pub rem: lang_items::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: lang_items::c_longlong,
    pub rem: lang_items::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = std::option::Option<
    unsafe extern "C" fn(arg1: *const lang_items::c_void, arg2: *const lang_items::c_void)
        -> lang_items::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> lang_items::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut lang_items::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: std::option::Option<unsafe extern "C" fn()>) -> lang_items::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const lang_items::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const lang_items::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const lang_items::c_char) -> lang_items::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const lang_items::c_char) -> lang_items::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const lang_items::c_void,
        __base: *const lang_items::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn div(__numer: lang_items::c_int, __denom: lang_items::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: lang_items::c_int);
}
extern "C" {
    pub fn free(arg1: *mut lang_items::c_void);
}
extern "C" {
    pub fn getenv(__string: *const lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const lang_items::c_char,
        arg2: *mut lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut lang_items::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut lang_items::c_char,
        arg2: *const *mut lang_items::c_char,
        arg3: *mut *mut lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn labs(arg1: lang_items::c_long) -> lang_items::c_long;
}
extern "C" {
    pub fn ldiv(__numer: lang_items::c_long, __denom: lang_items::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const lang_items::c_char, arg2: usize) -> lang_items::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const lang_items::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut lang_items::c_char, arg2: wchar_t) -> lang_items::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const lang_items::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const lang_items::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut lang_items::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut lang_items::c_char, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
        arg4: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut lang_items::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> lang_items::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut lang_items::c_void, __size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut lang_items::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut lang_items::c_void, __size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const lang_items::c_char,
        resolved_path: *mut lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn srand(__seed: lang_items::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const lang_items::c_char, __end_PTR: *mut *mut lang_items::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const lang_items::c_char, __end_PTR: *mut *mut lang_items::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_ulong;
}
extern "C" {
    pub fn system(__string: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn a64l(__input: *const lang_items::c_char) -> lang_items::c_long;
}
extern "C" {
    pub fn l64a(__input: lang_items::c_long) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: lang_items::c_long) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: std::option::Option<
            unsafe extern "C" fn(arg1: lang_items::c_int, arg2: *mut lang_items::c_void),
        >,
        __arg: *mut lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _Exit(__status: lang_items::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_void,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const lang_items::c_char,
        __value: *const lang_items::c_char,
        __overwrite: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const lang_items::c_char,
        __value: *const lang_items::c_char,
        __overwrite: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: lang_items::c_int,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: lang_items::c_uint,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: lang_items::c_int,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: lang_items::c_uint,
        arg2: *mut lang_items::c_char,
        arg3: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut lang_items::c_uint) -> lang_items::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut lang_items::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut lang_items::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut lang_items::c_ushort) -> lang_items::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut lang_items::c_ushort) -> lang_items::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut lang_items::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut lang_items::c_ushort);
}
extern "C" {
    pub fn lrand48() -> lang_items::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> lang_items::c_long;
}
extern "C" {
    pub fn mrand48() -> lang_items::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> lang_items::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut lang_items::c_ushort) -> lang_items::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut lang_items::c_ushort) -> lang_items::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut lang_items::c_ushort) -> *mut lang_items::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_ushort,
    ) -> *mut lang_items::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: lang_items::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: lang_items::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: lang_items::c_uint,
        arg2: *mut lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn random() -> lang_items::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn srandom(arg1: lang_items::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const lang_items::c_char) -> lang_items::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const lang_items::c_char)
        -> lang_items::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: lang_items::c_longlong) -> lang_items::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: lang_items::c_longlong, __denom: lang_items::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const lang_items::c_char,
        __end_PTR: *mut *mut lang_items::c_char,
        __base: lang_items::c_int,
    ) -> lang_items::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut lang_items::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const lang_items::c_char)
        -> lang_items::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut lang_items::c_void,
        arg2: usize,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: lang_items::c_int,
        arg4: lang_items::c_int,
        arg5: *mut lang_items::c_int,
        arg6: *mut lang_items::c_int,
        arg7: *mut *mut lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut lang_items::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut lang_items::c_void,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut lang_items::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: lang_items::c_uint,
        arg4: *const lang_items::c_char,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut lang_items::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut lang_items::c_void,
        _compar: std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut lang_items::c_void,
                arg2: *const lang_items::c_void,
                arg3: *const lang_items::c_void,
            ) -> lang_items::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: *mut *mut lang_items::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const lang_items::c_char, arg2: *mut *mut lang_items::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(arg1: usize, arg2: usize) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: std::option::Option<unsafe extern "C" fn()>)
        -> lang_items::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: lang_items::c_int);
}
extern "C" {
    pub fn bcmp(
        arg1: *const lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const lang_items::c_void, arg2: *mut lang_items::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut lang_items::c_void, arg2: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut lang_items::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn ffsl(arg1: lang_items::c_long) -> lang_items::c_int;
}
extern "C" {
    pub fn ffsll(arg1: lang_items::c_longlong) -> lang_items::c_int;
}
extern "C" {
    pub fn fls(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn flsl(arg1: lang_items::c_long) -> lang_items::c_int;
}
extern "C" {
    pub fn flsll(arg1: lang_items::c_longlong) -> lang_items::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: locale_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const lang_items::c_void,
        arg2: lang_items::c_int,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut lang_items::c_void,
        arg2: lang_items::c_int,
        arg3: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: lang_items::c_int) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const lang_items::c_char) -> lang_items::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> lang_items::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> lang_items::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: locale_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: lang_items::c_int, arg2: locale_t) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: *mut *mut lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut lang_items::c_void,
        arg2: *const lang_items::c_void,
        arg3: lang_items::c_int,
        arg4: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const lang_items::c_char)
        -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const lang_items::c_char, arg2: usize) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: lang_items::c_int,
        arg2: *mut lang_items::c_char,
        arg3: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: lang_items::c_int,
        arg4: *mut lang_items::c_int,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const lang_items::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut lang_items::c_char,
        arg2: *const lang_items::c_char,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const lang_items::c_char,
        arg2: *const lang_items::c_char,
        arg3: usize,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn strsignal(__signo: lang_items::c_int) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn av_log2(v: lang_items::c_uint) -> lang_items::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: lang_items::c_uint) -> lang_items::c_int;
}
extern "C" {
    /// Put a description of the AVERROR code errnum in errbuf.
    /// In case of failure the global variable errno is set to indicate the
    /// error. Even in case of failure av_strerror() will print a generic
    /// error message indicating the errnum provided to errbuf.
    ///
    /// @param errnum      error code to describe
    /// @param errbuf      buffer to which description is written
    /// @param errbuf_size the size in bytes of errbuf
    /// @return 0 on success, a negative value if a description for errnum
    /// cannot be found
    pub fn av_strerror(
        errnum: lang_items::c_int,
        errbuf: *mut lang_items::c_char,
        errbuf_size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU).
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    /// be allocated
    /// @see av_mallocz()
    pub fn av_malloc(size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU) and zero all the bytes of the
    /// block.
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if it cannot be allocated
    /// @see av_malloc()
    pub fn av_mallocz(size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate a memory block for an array with av_malloc().
    ///
    /// The allocated memory will have size `size * nmemb` bytes.
    ///
    /// @param nmemb Number of element
    /// @param size  Size of a single element
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    /// be allocated
    /// @see av_malloc()
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate a memory block for an array with av_mallocz().
    ///
    /// The allocated memory will have size `size * nmemb` bytes.
    ///
    /// @param nmemb Number of elements
    /// @param size  Size of the single element
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    /// be allocated
    ///
    /// @see av_mallocz()
    /// @see av_malloc_array()
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Non-inlined equivalent of av_mallocz_array().
    ///
    /// Created for symmetry with the calloc() C function.
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param ptr  Pointer to a memory block already allocated with
    /// av_realloc() or `NULL`
    /// @param size Size in bytes of the memory block to be allocated or
    /// reallocated
    ///
    /// @return Pointer to a newly-reallocated block or `NULL` if the block
    /// cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
    /// correctly aligned.
    /// @see av_fast_realloc()
    /// @see av_reallocp()
    pub fn av_realloc(ptr: *mut lang_items::c_void, size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory through a pointer to a
    /// pointer.
    ///
    /// If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
    /// with av_realloc(), or a pointer to `NULL`. The pointer
    /// is updated on success, or freed on failure.
    /// @param[in]     size Size in bytes for the memory block to be allocated or
    /// reallocated
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    pub fn av_reallocp(ptr: *mut lang_items::c_void, size: usize) -> lang_items::c_int;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// This function does the same thing as av_realloc(), except:
    /// - It takes two size arguments and allocates `nelem * elsize` bytes,
    /// after checking the result of the multiplication for integer overflow.
    /// - It frees the input block in case of failure, thus avoiding the memory
    /// leak with the classic
    /// @code{.c}
    /// buf = realloc(buf);
    /// if (!buf)
    /// return -1;
    /// @endcode
    /// pattern.
    pub fn av_realloc_f(
        ptr: *mut lang_items::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array.
    ///
    /// If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
    /// `nmemb` is zero, free the memory block pointed to by `ptr`.
    ///
    /// @param ptr   Pointer to a memory block already allocated with
    /// av_realloc() or `NULL`
    /// @param nmemb Number of elements in the array
    /// @param size  Size of the single element of the array
    ///
    /// @return Pointer to a newly-reallocated block or NULL if the block
    /// cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    /// @see av_reallocp_array()
    pub fn av_realloc_array(
        ptr: *mut lang_items::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array through a pointer to a pointer.
    ///
    /// If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
    /// zero, free the memory block pointed to by `*ptr`.
    ///
    /// @param[in,out] ptr   Pointer to a pointer to a memory block already
    /// allocated with av_realloc(), or a pointer to `NULL`.
    /// The pointer is updated on success, or freed on failure.
    /// @param[in]     nmemb Number of elements
    /// @param[in]     size  Size of the single element
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    pub fn av_reallocp_array(
        ptr: *mut lang_items::c_void,
        nmemb: usize,
        size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Reallocate the given buffer if it is not large enough, otherwise do nothing.
    ///
    /// If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
    ///
    /// If the given buffer is not large enough, and reallocation fails, `NULL` is
    /// returned and `*size` is set to 0, but the original buffer is not changed or
    /// freed.
    ///
    /// A typical use pattern follows:
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
    /// if (!new_buf) {
    /// // Allocation failed; clean up original buffer
    /// av_freep(&buf);
    /// return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Already allocated buffer, or `NULL`
    /// @param[in,out] size     Pointer to current size of buffer `ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `ptr`
    /// @return `ptr` if the buffer is large enough, a pointer to newly reallocated
    /// buffer if the buffer was not large enough, or `NULL` in case of
    /// error
    /// @see av_realloc()
    /// @see av_fast_malloc()
    pub fn av_fast_realloc(
        ptr: *mut lang_items::c_void,
        size: *mut lang_items::c_uint,
        min_size: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Allocate a buffer, reusing the given one if large enough.
    ///
    /// Contrary to av_fast_realloc(), the current buffer contents might not be
    /// preserved and on error the old buffer is freed, thus no special handling to
    /// avoid memleaks is necessary.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// av_fast_malloc(&buf, &current_size, size_needed);
    /// if (!buf) {
    /// // Allocation failed; buf already freed
    /// return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    /// `*ptr` will be overwritten with pointer to new
    /// buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `*ptr`
    /// @see av_realloc()
    /// @see av_fast_mallocz()
    pub fn av_fast_malloc(
        ptr: *mut lang_items::c_void,
        size: *mut lang_items::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Allocate and clear a buffer, reusing the given one if large enough.
    ///
    /// Like av_fast_malloc(), but all newly allocated space is initially cleared.
    /// Reused buffer is not cleared.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    /// `*ptr` will be overwritten with pointer to new
    /// buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `*ptr`
    /// @see av_fast_malloc()
    pub fn av_fast_mallocz(
        ptr: *mut lang_items::c_void,
        size: *mut lang_items::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family.
    ///
    /// @param ptr Pointer to the memory block which should be freed.
    ///
    /// @note `ptr = NULL` is explicitly allowed.
    /// @note It is recommended that you use av_freep() instead, to prevent leaving
    /// behind dangling pointers.
    /// @see av_freep()
    pub fn av_free(ptr: *mut lang_items::c_void);
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family, and set the pointer pointing to it to `NULL`.
    ///
    /// @code{.c}
    /// uint8_t *buf = av_malloc(16);
    /// av_free(buf);
    /// // buf now contains a dangling pointer to freed memory, and accidental
    /// // dereference of buf will result in a use-after-free, which may be a
    /// // security risk.
    ///
    /// uint8_t *buf = av_malloc(16);
    /// av_freep(&buf);
    /// // buf is now NULL, and accidental dereference will only result in a
    /// // NULL-pointer dereference.
    /// @endcode
    ///
    /// @param ptr Pointer to the pointer to the memory block which should be freed
    /// @note `*ptr = NULL` is safe and leads to no action.
    /// @see av_free()
    pub fn av_freep(ptr: *mut lang_items::c_void);
}
extern "C" {
    /// Duplicate a string.
    ///
    /// @param s String to be duplicated
    /// @return Pointer to a newly-allocated string containing a
    /// copy of `s` or `NULL` if the string cannot be allocated
    /// @see av_strndup()
    pub fn av_strdup(s: *const lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    /// Duplicate a substring of a string.
    ///
    /// @param s   String to be duplicated
    /// @param len Maximum length of the resulting string (not counting the
    /// terminating byte)
    /// @return Pointer to a newly-allocated string containing a
    /// substring of `s` or `NULL` if the string cannot be allocated
    pub fn av_strndup(s: *const lang_items::c_char, len: usize) -> *mut lang_items::c_char;
}
extern "C" {
    /// Duplicate a buffer with av_malloc().
    ///
    /// @param p    Buffer to be duplicated
    /// @param size Size in bytes of the buffer copied
    /// @return Pointer to a newly allocated buffer containing a
    /// copy of `p` or `NULL` if the buffer cannot be allocated
    pub fn av_memdup(p: *const lang_items::c_void, size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// Overlapping memcpy() implementation.
    ///
    /// @param dst  Destination buffer
    /// @param back Number of bytes back to start copying (i.e. the initial size of
    /// the overlapping window); must be > 0
    /// @param cnt  Number of bytes to copy; must be >= 0
    ///
    /// @note `cnt > back` is valid, this will copy the bytes we just copied,
    /// thus creating a repeating pattern with a period length of `back`.
    pub fn av_memcpy_backptr(dst: *mut u8, back: lang_items::c_int, cnt: lang_items::c_int);
}
extern "C" {
    /// Add the pointer to an element to a dynamic array.
    ///
    /// The array to grow is supposed to be an array of pointers to
    /// structures, and the element to add must be a pointer to an already
    /// allocated structure.
    ///
    /// The array is reallocated when its size reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr Pointer to the array to grow
    /// @param[in,out] nb_ptr  Pointer to the number of elements in the array
    /// @param[in]     elem    Element to add
    /// @see av_dynarray_add_nofree(), av_dynarray2_add()
    pub fn av_dynarray_add(
        tab_ptr: *mut lang_items::c_void,
        nb_ptr: *mut lang_items::c_int,
        elem: *mut lang_items::c_void,
    );
}
extern "C" {
    /// Add an element to a dynamic array.
    ///
    /// Function has the same functionality as av_dynarray_add(),
    /// but it doesn't free memory on fails. It returns error code
    /// instead and leave current buffer untouched.
    ///
    /// @return >=0 on success, negative otherwise
    /// @see av_dynarray_add(), av_dynarray2_add()
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut lang_items::c_void,
        nb_ptr: *mut lang_items::c_int,
        elem: *mut lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Add an element of size `elem_size` to a dynamic array.
    ///
    /// The array is reallocated when its number of elements reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr   Pointer to the array to grow
    /// @param[in,out] nb_ptr    Pointer to the number of elements in the array
    /// @param[in]     elem_size Size in bytes of an element in the array
    /// @param[in]     elem_data Pointer to the data of the element to add. If
    /// `NULL`, the space of the newly added element is
    /// allocated but left uninitialized.
    ///
    /// @return Pointer to the data of the element to copy in the newly allocated
    /// space
    /// @see av_dynarray_add(), av_dynarray_add_nofree()
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut lang_items::c_void,
        nb_ptr: *mut lang_items::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Set the maximum size that may be allocated in one block.
    ///
    /// The value specified with this function is effective for all libavutil's @ref
    /// lavu_mem_funcs "heap management functions."
    ///
    /// By default, the max value is defined as `INT_MAX`.
    ///
    /// @param max Value to be set as the new maximum size
    ///
    /// @warning Exercise extreme caution when using this function. Don't touch
    /// this if you do not understand the full consequence of doing so.
    pub fn av_max_alloc(max: usize);
}
/// Rational number (pair of numerator and denominator).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    /// < Numerator
    pub num: lang_items::c_int,
    /// < Denominator
    pub den: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    assert_eq!(
        std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVRational>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVRational>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    /// Reduce a fraction.
    ///
    /// This is useful for framerate calculations.
    ///
    /// @param[out] dst_num Destination numerator
    /// @param[out] dst_den Destination denominator
    /// @param[in]      num Source numerator
    /// @param[in]      den Source denominator
    /// @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
    /// @return 1 if the operation is exact, 0 otherwise
    pub fn av_reduce(
        dst_num: *mut lang_items::c_int,
        dst_den: *mut lang_items::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Multiply two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b*c
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Divide one rational by another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b/c
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Add two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b+c
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Subtract one rational from another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b-c
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Convert a double precision floating point number to a rational.
    ///
    /// In case of infinity, the returned value is expressed as `{1, 0}` or
    /// `{-1, 0}` depending on the sign.
    ///
    /// @param d   `double` to convert
    /// @param max Maximum allowed numerator and denominator
    /// @return `d` in AVRational form
    /// @see av_q2d()
    pub fn av_d2q(d: f64, max: lang_items::c_int) -> AVRational;
}
extern "C" {
    /// Find which of the two rationals is closer to another rational.
    ///
    /// @param q     Rational to be compared against
    /// @param q1,q2 Rationals to be tested
    /// @return One of the following values:
    /// - 1 if `q1` is nearer to `q` than `q2`
    /// - -1 if `q2` is nearer to `q` than `q1`
    /// - 0 if they have the same distance
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> lang_items::c_int;
}
extern "C" {
    /// Find the value in a list of rationals nearest a given reference rational.
    ///
    /// @param q      Reference rational
    /// @param q_list Array of rationals terminated by `{0, 0}`
    /// @return Index of the nearest value found in the array
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational) -> lang_items::c_int;
}
extern "C" {
    /// Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
    /// format.
    ///
    /// @param q Rational to be converted
    /// @return Equivalent floating-point value, expressed as an unsigned 32-bit
    /// integer.
    /// @note The returned value is platform-indepedant.
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(
        std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(
        std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
/// < Round toward zero.
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
/// < Round away from zero.
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
/// < Round toward -infinity.
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
/// < Round toward +infinity.
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
/// < Round to nearest and halfway cases away from zero.
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
/// Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
/// unchanged, avoiding special cases for #AV_NOPTS_VALUE.
///
/// Unlike other values of the enumeration AVRounding, this value is a
/// bitmask that must be used in conjunction with another value of the
/// enumeration through a bitwise OR, in order to set behavior for normal
/// cases.
///
/// @code{.c}
/// av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
/// // Rescaling 3:
/// //     Calculating 3 * 1 / 2
/// //     3 / 2 is rounded up to 2
/// //     => 2
///
/// av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
/// // Rescaling AV_NOPTS_VALUE:
/// //     AV_NOPTS_VALUE == INT64_MIN
/// //     AV_NOPTS_VALUE is passed through
/// //     => AV_NOPTS_VALUE
/// @endcode
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
/// Rounding methods.
pub type AVRounding = u32;
extern "C" {
    /// Compute the greatest common divisor of two integer operands.
    ///
    /// @param a,b Operands
    /// @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
    /// if a == 0 and b == 0, returns 0.
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with rounding to nearest.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow.
    ///
    /// This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow, and does not support different rounding methods.
    ///
    /// @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q()
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Compare two timestamps each in its own time base.
    ///
    /// @return One of the following values:
    /// - -1 if `ts_a` is before `ts_b`
    /// - 1 if `ts_a` is after `ts_b`
    /// - 0 if they represent the same position
    ///
    /// @warning
    /// The result of the function is undefined if one of the timestamps is outside
    /// the `int64_t` range when represented in the other's timebase.
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Compare the remainders of two integer operands divided by a common divisor.
    ///
    /// In other words, compare the least significant `log2(mod)` bits of integers
    /// `a` and `b`.
    ///
    /// @code{.c}
    /// av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
    /// av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
    /// @endcode
    ///
    /// @param a,b Operands
    /// @param mod Divisor; must be a power of 2
    /// @return
    /// - a negative value if `a % mod < b % mod`
    /// - a positive value if `a % mod > b % mod`
    /// - zero             if `a % mod == b % mod`
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    /// Rescale a timestamp while preserving known durations.
    ///
    /// This function is designed to be called per audio packet to scale the input
    /// timestamp to a different time base. Compared to a simple av_rescale_q()
    /// call, this function is robust against possible inconsistent frame durations.
    ///
    /// The `last` parameter is a state variable that must be preserved for all
    /// subsequent calls for the same stream. For the first call, `*last` should be
    /// initialized to #AV_NOPTS_VALUE.
    ///
    /// @param[in]     in_tb    Input time base
    /// @param[in]     in_ts    Input timestamp
    /// @param[in]     fs_tb    Duration time base; typically this is finer-grained
    /// (greater) than `in_tb` and `out_tb`
    /// @param[in]     duration Duration till the next call to this function (i.e.
    /// duration of the current packet/frame)
    /// @param[in,out] last     Pointer to a timestamp expressed in terms of
    /// `fs_tb`, acting as a state variable
    /// @param[in]     out_tb   Output timebase
    /// @return        Timestamp expressed in terms of `out_tb`
    ///
    /// @note In the context of this function, "duration" is in term of samples, not
    /// seconds.
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: lang_items::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    /// Add a value to a timestamp.
    ///
    /// This function guarantees that when the same value is repeatly added that
    /// no accumulation of rounding errors occurs.
    ///
    /// @param[in] ts     Input timestamp
    /// @param[in] ts_tb  Input timestamp time base
    /// @param[in] inc    Value to be added
    /// @param[in] inc_tb Time base of `inc`
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
/// < not part of ABI/API
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = u32;
/// Describe the class of an AVClass context structure. That is an
/// arbitrary struct of which the first field is a pointer to an
/// AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    /// The name of the class; usually it is the same name as the
    /// context structure type to which the AVClass is associated.
    pub class_name: *const lang_items::c_char,
    /// A pointer to a function which returns the name of a context
    /// instance ctx associated with the class.
    pub item_name: std::option::Option<
        unsafe extern "C" fn(ctx: *mut lang_items::c_void) -> *const lang_items::c_char,
    >,
    /// a pointer to the first option specified in the class if any or NULL
    ///
    /// @see av_set_default_options()
    pub option: *const AVOption,
    /// LIBAVUTIL_VERSION with which this structure was created.
    /// This is used to allow fields to be added without requiring major
    /// version bumps everywhere.
    pub version: lang_items::c_int,
    /// Offset in the structure where log_level_offset is stored.
    /// 0 means there is no such variable
    pub log_level_offset_offset: lang_items::c_int,
    /// Offset in the structure where a pointer to the parent context for
    /// logging is stored. For example a decoder could pass its AVCodecContext
    /// to eval as such a parent context, which an av_log() implementation
    /// could then leverage to display the parent context.
    /// The offset can be NULL.
    pub parent_log_context_offset: lang_items::c_int,
    /// Return next AVOptions-enabled child or NULL
    pub child_next: std::option::Option<
        unsafe extern "C" fn(obj: *mut lang_items::c_void, prev: *mut lang_items::c_void)
            -> *mut lang_items::c_void,
    >,
    /// Return an AVClass corresponding to the next potential
    /// AVOptions-enabled child.
    ///
    /// The difference between child_next and this is that
    /// child_next iterates over _already existing_ objects, while
    /// child_class_next iterates over _all possible_ children.
    pub child_class_next:
        std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    /// Category used for visualization (like color)
    /// This is only set if the category is equal for all objects using this class.
    /// available since version (51 << 16 | 56 << 8 | 100)
    pub category: AVClassCategory,
    /// Callback to return the category.
    /// available since version (51 << 16 | 59 << 8 | 100)
    pub get_category: std::option::Option<
        unsafe extern "C" fn(ctx: *mut lang_items::c_void) -> AVClassCategory,
    >,
    /// Callback to return the supported/allowed ranges.
    /// available since version (52.12)
    pub query_ranges: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut lang_items::c_void,
            key: *const lang_items::c_char,
            flags: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(
        std::mem::size_of::<AVClass>(),
        80usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).class_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).item_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).child_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).child_class_next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).category as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).get_category as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct or NULL if general log.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    pub fn av_log(
        avcl: *mut lang_items::c_void,
        level: lang_items::c_int,
        fmt: *const lang_items::c_char,
        ...
    );
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_vlog(
        avcl: *mut lang_items::c_void,
        level: lang_items::c_int,
        fmt: *const lang_items::c_char,
        vl: va_list,
    );
}
extern "C" {
    /// Get the current log level
    ///
    /// @see lavu_log_constants
    ///
    /// @return Current log level
    pub fn av_log_get_level() -> lang_items::c_int;
}
extern "C" {
    /// Set the log level
    ///
    /// @see lavu_log_constants
    ///
    /// @param level Logging level
    pub fn av_log_set_level(level: lang_items::c_int);
}
extern "C" {
    /// Set the logging callback
    ///
    /// @note The callback must be thread safe, even if the application does not use
    /// threads itself as some codecs are multithreaded.
    ///
    /// @see av_log_default_callback
    ///
    /// @param callback A logging function with a compatible signature.
    pub fn av_log_set_callback(
        callback: std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut lang_items::c_void,
                arg2: lang_items::c_int,
                arg3: *const lang_items::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    /// Default logging callback
    ///
    /// It prints the message to stderr, optionally colorizing it.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_log_default_callback(
        avcl: *mut lang_items::c_void,
        level: lang_items::c_int,
        fmt: *const lang_items::c_char,
        vl: va_list,
    );
}
extern "C" {
    /// Return the context name
    ///
    /// @param  ctx The AVClass context
    ///
    /// @return The AVClass class_name
    pub fn av_default_item_name(ctx: *mut lang_items::c_void) -> *const lang_items::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut lang_items::c_void) -> AVClassCategory;
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line
    /// @param line_size     size of the buffer
    /// @param print_prefix  used to store whether the prefix must be printed;
    /// must point to a persistent integer initially set to 1
    pub fn av_log_format_line(
        ptr: *mut lang_items::c_void,
        level: lang_items::c_int,
        fmt: *const lang_items::c_char,
        vl: va_list,
        line: *mut lang_items::c_char,
        line_size: lang_items::c_int,
        print_prefix: *mut lang_items::c_int,
    );
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line;
    /// may be NULL if line_size is 0
    /// @param line_size     size of the buffer; at most line_size-1 characters will
    /// be written to the buffer, plus one null terminator
    /// @param print_prefix  used to store whether the prefix must be printed;
    /// must point to a persistent integer initially set to 1
    /// @return Returns a negative value if an error occurred, otherwise returns
    /// the number of characters that would have been written for a
    /// sufficiently large buffer, not including the terminating null
    /// character. If the return value is not less than line_size, it means
    /// that the log message was truncated to fit the buffer.
    pub fn av_log_format_line2(
        ptr: *mut lang_items::c_void,
        level: lang_items::c_int,
        fmt: *const lang_items::c_char,
        vl: va_list,
        line: *mut lang_items::c_char,
        line_size: lang_items::c_int,
        print_prefix: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: lang_items::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> lang_items::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
/// < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
/// < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
/// < packed RGB 8:8:8, 24bpp, RGBRGB...
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
/// < packed RGB 8:8:8, 24bpp, BGRBGR...
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
/// < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
/// < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
/// < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
/// < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
/// <        Y        ,  8bpp
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
/// <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
/// <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
/// < 8 bits with AV_PIX_FMT_RGB32 palette
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
/// < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
/// < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
/// < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
/// < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
/// < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
/// < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
/// < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
/// < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
/// < packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
/// < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
/// < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
/// < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
/// < as above, but U and V bytes are swapped
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
/// < packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
/// < packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
/// < packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
/// < packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
/// <        Y        , 16bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
/// <        Y        , 16bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
/// < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
/// < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
/// < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
/// < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
/// < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
/// < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
/// < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
/// < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
/// < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
/// < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
/// < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
/// < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
/// < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
/// < HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
/// < HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
/// < HW decoding through VA API, Picture.data[3] contains a VASurfaceID
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
/// @}
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
/// < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
/// < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
/// < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
/// < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
/// < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
/// < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
/// < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
/// < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
/// < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
/// < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
/// < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
/// < 8 bits gray, 8 bits alpha
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 58;
/// < alias for AV_PIX_FMT_YA8
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 58;
/// < alias for AV_PIX_FMT_YA8
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
/// < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
/// < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
/// < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
/// < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
/// < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
/// < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
/// < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
/// < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
/// < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
/// < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
/// < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
/// < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
/// < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
/// < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
/// < planar GBR 4:4:4 24bpp
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
/// < planar GBR 4:4:4 27bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
/// < planar GBR 4:4:4 27bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
/// < planar GBR 4:4:4 30bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
/// < planar GBR 4:4:4 30bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
/// < planar GBR 4:4:4 48bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
/// < planar GBR 4:4:4 48bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
/// < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
/// < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
/// < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
/// < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
/// < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
/// < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
/// < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
/// < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
/// < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
/// < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
/// < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
/// < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
/// < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
/// < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
/// < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
/// < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
/// < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
/// < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
/// < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
/// < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
/// < HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
/// < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
/// < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
/// < interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 103;
/// < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
/// < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
/// < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
/// < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
/// < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
/// < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
/// < packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
/// < 16 bits gray, 16 bits alpha (big-endian)
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
/// < 16 bits gray, 16 bits alpha (little-endian)
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
/// < planar GBRA 4:4:4:4 32bpp
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
/// < planar GBRA 4:4:4:4 64bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
/// < planar GBRA 4:4:4:4 64bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
/// HW acceleration through QSV, data[3] contains a pointer to the
/// mfxFrameSurface1 structure.
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 116;
/// HW acceleration though MMAL, data[3] contains a pointer to the
/// MMAL_BUFFER_HEADER_T structure.
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 117;
/// < HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
/// HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
/// exactly as for system memory frames.
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 119;
/// < packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 120;
/// < packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 121;
/// < packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 122;
/// < packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 123;
/// < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
/// < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
/// < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
/// < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
/// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
/// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
/// < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
/// < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
/// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
/// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
/// < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
/// < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
/// < planar GBR 4:4:4 36bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
/// < planar GBR 4:4:4 36bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
/// < planar GBR 4:4:4 42bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
/// < planar GBR 4:4:4 42bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
/// < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
/// < bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
/// < bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
/// < bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
/// < bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
/// < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
/// < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
/// < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
/// < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
/// < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
/// < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
/// < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
/// < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian */
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
/// < XVideo Motion Acceleration via common packet passing
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 153;
/// < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
/// < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
/// < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
/// < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
/// < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
/// < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
/// < hardware decoding through Videotoolbox
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
/// < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 161;
/// < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 162;
/// < planar GBR 4:4:4:4 48bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
/// < planar GBR 4:4:4:4 48bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
/// < planar GBR 4:4:4:4 40bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
/// < planar GBR 4:4:4:4 40bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
/// < hardware decoding through MediaCodec
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
/// <        Y        , 12bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
/// <        Y        , 12bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
/// <        Y        , 10bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
/// <        Y        , 10bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
/// < like NV12, with 16bpp per component, little-endian
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 172;
/// < like NV12, with 16bpp per component, big-endian
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 173;
/// Hardware surfaces for Direct3D11.
///
/// This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
/// hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
///
/// data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
/// texture array index of the frame as intptr_t if the ID3D11Texture2D is
/// an array texture (or always 0 if it's a normal texture).
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 174;
/// <        Y        , 9bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
/// <        Y        , 9bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
/// < IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
/// < IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
/// < IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
/// < IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
/// DRM-managed buffers exposed through PRIME buffer sharing.
///
/// data[0] points to an AVDRMFrameDescriptor.
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
/// Hardware surfaces for OpenCL.
///
/// data[i] contain 2D image objects (typed in C as cl_mem, used
/// in OpenCL as image2d_t) for each plane of the surface.
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
/// < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 183;
/// Pixel format.
///
/// @note
/// AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
/// color is put together as:
/// (A << 24) | (R << 16) | (G << 8) | B
/// This is stored as BGRA on little-endian CPU architectures and ARGB on
/// big-endian CPUs.
///
/// @par
/// When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
/// image data is stored in AVFrame.data[0]. The palette is transported in
/// AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
/// formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
/// also endian-specific). Note also that the individual RGB32 palette
/// components stored in AVFrame.data[1] should be in the range 0..255.
/// This is important as many custom PAL8 video codecs that were designed
/// to run on the IBM VGA graphics adapter use 6-bit palette components.
///
/// @par
/// For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
/// for pal8. This palette is filled in automatically by the function
/// allocating the picture.
pub type AVPixelFormat = i32;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
/// < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
/// < also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
/// < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
/// < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
/// < functionally identical to above
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
/// < colour filters using Illuminant C
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
/// < ITU-R BT2020
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
/// < SMPTE ST 428-1 (CIE 1931 XYZ)
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
/// < SMPTE ST 431-2 (2011) / DCI P3
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
/// < SMPTE ST 432-1 (2010) / P3 D65 / Display P3
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
/// < JEDEC P22 phosphors
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
/// < Not part of ABI
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
/// Chromaticity coordinates of the source primaries.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.
pub type AVColorPrimaries = u32;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
/// < also ITU-R BT1361
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
/// < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
/// < also ITU-R BT470BG
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
/// < also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
/// < "Linear transfer characteristics"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
/// < "Logarithmic transfer characteristic (100:1 range)"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
/// < "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
/// < IEC 61966-2-4
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
/// < ITU-R BT1361 Extended Colour Gamut
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
/// < IEC 61966-2-1 (sRGB or sYCC)
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
/// < ITU-R BT2020 for 10-bit system
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
/// < ITU-R BT2020 for 12-bit system
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
/// < SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
/// < SMPTE ST 428-1
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
/// < ARIB STD-B67, known as "Hybrid log-gamma"
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
/// < Not part of ABI
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
/// Color Transfer Characteristic.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.
pub type AVColorTransferCharacteristic = u32;
/// < order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
/// < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
/// < FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
/// < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
/// < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
/// < functionally identical to above
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
/// < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
/// < ITU-R BT2020 non-constant luminance system
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
/// < ITU-R BT2020 constant luminance system
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
/// < SMPTE 2085, Y'D'zD'x
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
/// < Chromaticity-derived non-constant luminance system
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
/// < Chromaticity-derived constant luminance system
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
/// < ITU-R BT.2100-0, ICtCp
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
/// < Not part of ABI
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
/// YUV colorspace type.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.
pub type AVColorSpace = u32;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
/// < the normal 219*2^(n-8) "MPEG" YUV ranges
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
/// < the normal     2^n-1   "JPEG" YUV ranges
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
/// < Not part of ABI
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
/// MPEG vs JPEG YUV range.
pub type AVColorRange = u32;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
/// < MPEG-2/4 4:2:0, H.264 default for 4:2:0
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
/// < MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
/// < ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
/// < Not part of ABI
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
/// Location of chroma samples.
///
/// Illustration showing the location of the first (top left) chroma sample of the
/// image, the left shows only luma, the right
/// shows the location of the chroma sample, the 2 could be imagined to overlay
/// each other but are drawn separately due to limitations of ASCII
///
/// 1st 2nd       1st 2nd horizontal luma sample positions
/// v   v         v   v
/// ______        ______
/// 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
/// |             |1 2           1-6 are possible chroma positions
/// 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
pub type AVChromaLocation = u32;
extern "C" {
    /// Compute the length of an integer list.
    ///
    /// @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
    /// @param term    list terminator (usually 0 or -1)
    /// @param list    pointer to the list
    /// @return  length of the list, in elements, not counting the terminator
    pub fn av_int_list_length_for_size(
        elsize: lang_items::c_uint,
        list: *const lang_items::c_void,
        term: u64,
    ) -> lang_items::c_uint;
}
extern "C" {
    /// Open a file using a UTF-8 filename.
    /// The API of this function matches POSIX fopen(), errors are returned through
    /// errno.
    pub fn av_fopen_utf8(
        path: *const lang_items::c_char,
        mode: *const lang_items::c_char,
    ) -> *mut FILE;
}
extern "C" {
    /// Return the fractional representation of the internal time base.
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    /// Fill the provided buffer with a string containing a FourCC (four-character
    /// code) representation.
    ///
    /// @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
    /// @param fourcc the fourcc to represent
    /// @return the buffer in input
    pub fn av_fourcc_make_string(
        buf: *mut lang_items::c_char,
        fourcc: u32,
    ) -> *mut lang_items::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComponentDescriptor {
    /// Which of the 4 planes contains the component.
    pub plane: lang_items::c_int,
    /// Number of elements between 2 horizontally consecutive pixels.
    /// Elements are bits for bitstream formats, bytes otherwise.
    pub step: lang_items::c_int,
    /// Number of elements before the component of the first pixel.
    /// Elements are bits for bitstream formats, bytes otherwise.
    pub offset: lang_items::c_int,
    /// Number of least significant bits that must be shifted away
    /// to get the value.
    pub shift: lang_items::c_int,
    /// Number of bits in the component.
    pub depth: lang_items::c_int,
    /// deprecated, use step instead
    pub step_minus1: lang_items::c_int,
    /// deprecated, use depth instead
    pub depth_minus1: lang_items::c_int,
    /// deprecated, use offset instead
    pub offset_plus1: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVComponentDescriptor() {
    assert_eq!(
        std::mem::size_of::<AVComponentDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        std::mem::align_of::<AVComponentDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVComponentDescriptor>())).plane as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVComponentDescriptor>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVComponentDescriptor>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVComponentDescriptor>())).shift as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVComponentDescriptor>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVComponentDescriptor>())).step_minus1 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVComponentDescriptor>())).depth_minus1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVComponentDescriptor>())).offset_plus1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset_plus1)
        )
    );
}
/// Descriptor that unambiguously describes how the bits of a pixel are
/// stored in the up to 4 data planes of an image. It also stores the
/// subsampling factors and number of components.
///
/// @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
/// and all the YUV variants) AVPixFmtDescriptor just stores how values
/// are stored not what these values represent.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPixFmtDescriptor {
    pub name: *const lang_items::c_char,
    /// < The number of components each pixel has, (1-4)
    pub nb_components: u8,
    /// Amount to shift the luma width right to find the chroma width.
    /// For YV12 this is 1 for example.
    /// chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)
    /// The note above is needed to ensure rounding up.
    /// This value only refers to the chroma components.
    pub log2_chroma_w: u8,
    /// Amount to shift the luma height right to find the chroma height.
    /// For YV12 this is 1 for example.
    /// chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)
    /// The note above is needed to ensure rounding up.
    /// This value only refers to the chroma components.
    pub log2_chroma_h: u8,
    /// Combination of AV_PIX_FMT_FLAG_... flags.
    pub flags: u64,
    /// Parameters that describe how pixels are packed.
    /// If the format has 1 or 2 components, then luma is 0.
    /// If the format has 3 or 4 components:
    /// if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
    /// otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
    ///
    /// If present, the Alpha channel is always the last component.
    pub comp: [AVComponentDescriptor; 4usize],
    /// Alternative comma-separated names.
    pub alias: *const lang_items::c_char,
}
#[test]
fn bindgen_test_layout_AVPixFmtDescriptor() {
    assert_eq!(
        std::mem::size_of::<AVPixFmtDescriptor>(),
        160usize,
        concat!("Size of: ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        std::mem::align_of::<AVPixFmtDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPixFmtDescriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVPixFmtDescriptor>())).nb_components as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(nb_components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_w as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_w)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_h as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_h)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPixFmtDescriptor>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPixFmtDescriptor>())).comp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPixFmtDescriptor>())).alias as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(alias)
        )
    );
}
extern "C" {
    /// Return the number of bits per pixel used by the pixel format
    /// described by pixdesc. Note that this is not the same as the number
    /// of bits per sample.
    ///
    /// The returned number of bits refers to the number of bits actually
    /// used for storing the pixel information, that is padding bits are
    /// not counted.
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> lang_items::c_int;
}
extern "C" {
    /// Return the number of bits per pixel for the pixel format
    /// described by pixdesc, including any padding or unused bits.
    pub fn av_get_padded_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> lang_items::c_int;
}
extern "C" {
    /// @return a pixel format descriptor for provided pixel format or NULL if
    /// this pixel format is unknown.
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    /// Iterate over all pixel format descriptors known to libavutil.
    ///
    /// @param prev previous descriptor. NULL to get the first descriptor.
    ///
    /// @return next descriptor or NULL after the last descriptor
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    /// @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
    /// is not a valid pointer to a pixel format descriptor.
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    /// Utility function to access log2_chroma_w log2_chroma_h from
    /// the pixel format AVPixFmtDescriptor.
    ///
    /// @param[in]  pix_fmt the pixel format
    /// @param[out] h_shift store log2_chroma_w (horizontal/width shift)
    /// @param[out] v_shift store log2_chroma_h (vertical/height shift)
    ///
    /// @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut lang_items::c_int,
        v_shift: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
    /// valid pixel format.
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> lang_items::c_int;
}
extern "C" {
    /// @return the name for provided color range or NULL if unknown.
    pub fn av_color_range_name(range: AVColorRange) -> *const lang_items::c_char;
}
extern "C" {
    /// @return the AVColorRange value for name or an AVError if not found.
    pub fn av_color_range_from_name(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// @return the name for provided color primaries or NULL if unknown.
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const lang_items::c_char;
}
extern "C" {
    /// @return the AVColorPrimaries value for name or an AVError if not found.
    pub fn av_color_primaries_from_name(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// @return the name for provided color transfer or NULL if unknown.
    pub fn av_color_transfer_name(
        transfer: AVColorTransferCharacteristic,
    ) -> *const lang_items::c_char;
}
extern "C" {
    /// @return the AVColorTransferCharacteristic value for name or an AVError if not found.
    pub fn av_color_transfer_from_name(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// @return the name for provided color space or NULL if unknown.
    pub fn av_color_space_name(space: AVColorSpace) -> *const lang_items::c_char;
}
extern "C" {
    /// @return the AVColorSpace value for name or an AVError if not found.
    pub fn av_color_space_from_name(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// @return the name for provided chroma location or NULL if unknown.
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const lang_items::c_char;
}
extern "C" {
    /// @return the AVChromaLocation value for name or an AVError if not found.
    pub fn av_chroma_location_from_name(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Return the pixel format corresponding to name.
    ///
    /// If there is no pixel format with name name, then looks for a
    /// pixel format with the name corresponding to the native endian
    /// format of name.
    /// For example in a little-endian system, first looks for "gray16",
    /// then for "gray16le".
    ///
    /// Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
    pub fn av_get_pix_fmt(name: *const lang_items::c_char) -> AVPixelFormat;
}
extern "C" {
    /// Return the short name for a pixel format, NULL in case pix_fmt is
    /// unknown.
    ///
    /// @see av_get_pix_fmt(), av_get_pix_fmt_string()
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const lang_items::c_char;
}
extern "C" {
    /// Print in buf the string corresponding to the pixel format with
    /// number pix_fmt, or a header if pix_fmt is negative.
    ///
    /// @param buf the buffer where to write the string
    /// @param buf_size the size of buf
    /// @param pix_fmt the number of the pixel format to print the
    /// corresponding info string, or a negative value to print the
    /// corresponding header.
    pub fn av_get_pix_fmt_string(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    /// Read a line from an image, and write the values of the
    /// pixel format component c to dst.
    ///
    /// @param data the array containing the pointers to the planes of the image
    /// @param linesize the array containing the linesizes of the image
    /// @param desc the pixel format descriptor for the image
    /// @param x the horizontal coordinate of the first pixel to read
    /// @param y the vertical coordinate of the first pixel to read
    /// @param w the width of the line to read, that is the number of
    /// values to write to dst
    /// @param read_pal_component if not zero and the format is a paletted
    /// format writes the values corresponding to the palette
    /// component c in data[1] to dst, rather than the palette indexes in
    /// data[0]. The behavior is undefined if the format is not paletted.
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const lang_items::c_int,
        desc: *const AVPixFmtDescriptor,
        x: lang_items::c_int,
        y: lang_items::c_int,
        c: lang_items::c_int,
        w: lang_items::c_int,
        read_pal_component: lang_items::c_int,
    );
}
extern "C" {
    /// Write the values from src to the pixel format component c of an
    /// image line.
    ///
    /// @param src array containing the values to write
    /// @param data the array containing the pointers to the planes of the
    /// image to write into. It is supposed to be zeroed.
    /// @param linesize the array containing the linesizes of the image
    /// @param desc the pixel format descriptor for the image
    /// @param x the horizontal coordinate of the first pixel to write
    /// @param y the vertical coordinate of the first pixel to write
    /// @param w the width of the line to write, that is the number of
    /// values to write to the image line
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const lang_items::c_int,
        desc: *const AVPixFmtDescriptor,
        x: lang_items::c_int,
        y: lang_items::c_int,
        c: lang_items::c_int,
        w: lang_items::c_int,
    );
}
extern "C" {
    /// Utility function to swap the endianness of a pixel format.
    ///
    /// @param[in]  pix_fmt the pixel format
    ///
    /// @return pixel format with swapped endianness if it exists,
    /// otherwise AV_PIX_FMT_NONE
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    /// Compute what kind of losses will occur when converting from one specific
    /// pixel format to another.
    /// When converting from one pixel format to another, information loss may occur.
    /// For example, when converting from RGB24 to GRAY, the color information will
    /// be lost. Similarly, other losses occur when converting from some formats to
    /// other formats. These losses can involve loss of chroma, but also loss of
    /// resolution, loss of color depth, loss due to the color space conversion, loss
    /// of the alpha bits or loss due to color quantization.
    /// av_get_fix_fmt_loss() informs you about the various types of losses
    /// which will occur when converting from one pixel format to another.
    ///
    /// @param[in] dst_pix_fmt destination pixel format
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @return Combination of flags informing you what kind of losses will occur
    /// (maximum loss for an invalid dst_pix_fmt).
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Compute what kind of losses will occur when converting from one specific
    /// pixel format to another.
    /// When converting from one pixel format to another, information loss may occur.
    /// For example, when converting from RGB24 to GRAY, the color information will
    /// be lost. Similarly, other losses occur when converting from some formats to
    /// other formats. These losses can involve loss of chroma, but also loss of
    /// resolution, loss of color depth, loss due to the color space conversion, loss
    /// of the alpha bits or loss due to color quantization.
    /// av_get_fix_fmt_loss() informs you about the various types of losses
    /// which will occur when converting from one pixel format to another.
    ///
    /// @param[in] dst_pix_fmt destination pixel format
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @return Combination of flags informing you what kind of losses will occur
    /// (maximum loss for an invalid dst_pix_fmt).
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
        loss_ptr: *mut lang_items::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    /// Compute the max pixel step for each plane of an image with a
    /// format described by pixdesc.
    ///
    /// The pixel step is the distance in bytes between the first byte of
    /// the group of bytes which describe a pixel component and the first
    /// byte of the successive group in the same plane for the same
    /// component.
    ///
    /// @param max_pixsteps an array which is filled with the max pixel step
    /// for each plane. Since a plane may contain different pixel
    /// components, the computed max_pixsteps[plane] is relative to the
    /// component in the plane with the max pixel step.
    /// @param max_pixstep_comps an array which is filled with the component
    /// for each plane which has the max pixel step. May be NULL.
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut lang_items::c_int,
        max_pixstep_comps: *mut lang_items::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    /// Compute the size of an image line with format pix_fmt and width
    /// width for the plane plane.
    ///
    /// @return the computed size in bytes
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        plane: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill plane linesizes for an image with pixel format pix_fmt and
    /// width width.
    ///
    /// @param linesizes array to be filled with the linesize for each plane
    /// @return >= 0 in case of success, a negative error code otherwise
    pub fn av_image_fill_linesizes(
        linesizes: *mut lang_items::c_int,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill plane data pointers for an image with pixel format pix_fmt and
    /// height height.
    ///
    /// @param data pointers array to be filled with the pointer for each image plane
    /// @param ptr the pointer to a buffer which will contain the image
    /// @param linesizes the array containing the linesize for each
    /// plane, should be filled by av_image_fill_linesizes()
    /// @return the size in bytes required for the image buffer, a negative
    /// error code in case of failure
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: lang_items::c_int,
        ptr: *mut u8,
        linesizes: *const lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate an image with size w and h and pixel format pix_fmt, and
    /// fill pointers and linesizes accordingly.
    /// The allocated image buffer has to be freed by using
    /// av_freep(&pointers[0]).
    ///
    /// @param align the value to use for buffer size alignment
    /// @return the size in bytes required for the image buffer, a negative
    /// error code in case of failure
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut lang_items::c_int,
        w: lang_items::c_int,
        h: lang_items::c_int,
        pix_fmt: AVPixelFormat,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy image plane from src to dst.
    /// That is, copy "height" number of lines of "bytewidth" bytes each.
    /// The first byte of each successive line is separated by *_linesize
    /// bytes.
    ///
    /// bytewidth must be contained by both absolute values of dst_linesize
    /// and src_linesize, otherwise the function behavior is undefined.
    ///
    /// @param dst_linesize linesize for the image plane in dst
    /// @param src_linesize linesize for the image plane in src
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: lang_items::c_int,
        src: *const u8,
        src_linesize: lang_items::c_int,
        bytewidth: lang_items::c_int,
        height: lang_items::c_int,
    );
}
extern "C" {
    /// Copy image in src_data to dst_data.
    ///
    /// @param dst_linesizes linesizes for the image in dst_data
    /// @param src_linesizes linesizes for the image in src_data
    pub fn av_image_copy(
        dst_data: *mut *mut u8,
        dst_linesizes: *mut lang_items::c_int,
        src_data: *mut *const u8,
        src_linesizes: *const lang_items::c_int,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    );
}
extern "C" {
    /// Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
    /// available, this function will use special functionality for reading from such
    /// memory, which may result in greatly improved performance compared to plain
    /// av_image_copy().
    ///
    /// The data pointers and the linesizes must be aligned to the maximum required
    /// by the CPU architecture.
    ///
    /// @note The linesize parameters have the type ptrdiff_t here, while they are
    /// int for av_image_copy().
    /// @note On x86, the linesizes currently need to be aligned to the cacheline
    /// size (i.e. 64) to get improved performance.
    pub fn av_image_copy_uc_from(
        dst_data: *mut *mut u8,
        dst_linesizes: *const isize,
        src_data: *mut *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    );
}
extern "C" {
    /// Setup the data pointers and linesizes based on the specified image
    /// parameters and the provided array.
    ///
    /// The fields of the given image are filled in by using the src
    /// address which points to the image data buffer. Depending on the
    /// specified pixel format, one or multiple image data pointers and
    /// line sizes will be set.  If a planar format is specified, several
    /// pointers will be set pointing to the different picture planes and
    /// the line sizes of the different planes will be stored in the
    /// lines_sizes array. Call with src == NULL to get the required
    /// size for the src buffer.
    ///
    /// To allocate the buffer and fill in the dst_data and dst_linesize in
    /// one call, use av_image_alloc().
    ///
    /// @param dst_data      data pointers to be filled in
    /// @param dst_linesize  linesizes for the image in dst_data to be filled in
    /// @param src           buffer which will contain or contains the actual image data, can be NULL
    /// @param pix_fmt       the pixel format of the image
    /// @param width         the width of the image in pixels
    /// @param height        the height of the image in pixels
    /// @param align         the value used in src for linesize alignment
    /// @return the size in bytes required for src, a negative error code
    /// in case of failure
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut lang_items::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return the size in bytes of the amount of data required to store an
    /// image with the given parameters.
    ///
    /// @param pix_fmt  the pixel format of the image
    /// @param width    the width of the image in pixels
    /// @param height   the height of the image in pixels
    /// @param align    the assumed linesize alignment
    /// @return the buffer size in bytes, a negative error code in case of failure
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy image data from an image into a buffer.
    ///
    /// av_image_get_buffer_size() can be used to compute the required size
    /// for the buffer to fill.
    ///
    /// @param dst           a buffer into which picture data will be copied
    /// @param dst_size      the size in bytes of dst
    /// @param src_data      pointers containing the source image data
    /// @param src_linesize  linesizes for the image in src_data
    /// @param pix_fmt       the pixel format of the source image
    /// @param width         the width of the source image in pixels
    /// @param height        the height of the source image in pixels
    /// @param align         the assumed linesize alignment for dst
    /// @return the number of bytes written to dst, or a negative value
    /// (error code) on error
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: lang_items::c_int,
        src_data: *const *const u8,
        src_linesize: *const lang_items::c_int,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check if the given dimension of an image is valid, meaning that all
    /// bytes of the image can be addressed with a signed int.
    ///
    /// @param w the width of the picture
    /// @param h the height of the picture
    /// @param log_offset the offset to sum to the log level for logging with log_ctx
    /// @param log_ctx the parent logging context, it may be NULL
    /// @return >= 0 if valid, a negative error code otherwise
    pub fn av_image_check_size(
        w: lang_items::c_uint,
        h: lang_items::c_uint,
        log_offset: lang_items::c_int,
        log_ctx: *mut lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check if the given dimension of an image is valid, meaning that all
    /// bytes of a plane of an image with the specified pix_fmt can be addressed
    /// with a signed int.
    ///
    /// @param w the width of the picture
    /// @param h the height of the picture
    /// @param max_pixels the maximum number of pixels the user wants to accept
    /// @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.
    /// @param log_offset the offset to sum to the log level for logging with log_ctx
    /// @param log_ctx the parent logging context, it may be NULL
    /// @return >= 0 if valid, a negative error code otherwise
    pub fn av_image_check_size2(
        w: lang_items::c_uint,
        h: lang_items::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: lang_items::c_int,
        log_ctx: *mut lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check if the given sample aspect ratio of an image is valid.
    ///
    /// It is considered invalid if the denominator is 0 or if applying the ratio
    /// to the image size would make the smaller dimension less than 1. If the
    /// sar numerator is 0, it is considered unknown and will return as valid.
    ///
    /// @param w width of the image
    /// @param h height of the image
    /// @param sar sample aspect ratio of the image
    /// @return 0 if valid, a negative AVERROR code otherwise
    pub fn av_image_check_sar(
        w: lang_items::c_uint,
        h: lang_items::c_uint,
        sar: AVRational,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Overwrite the image data with black. This is suitable for filling a
    /// sub-rectangle of an image, meaning the padding between the right most pixel
    /// and the left most pixel on the next line will not be overwritten. For some
    /// formats, the image size might be rounded up due to inherent alignment.
    ///
    /// If the pixel format has alpha, the alpha is cleared to opaque.
    ///
    /// This can return an error if the pixel format is not supported. Normally, all
    /// non-hwaccel pixel formats should be supported.
    ///
    /// Passing NULL for dst_data is allowed. Then the function returns whether the
    /// operation would have succeeded. (It can return an error if the pix_fmt is
    /// not supported.)
    ///
    /// @param dst_data      data pointers to destination image
    /// @param dst_linesize  linesizes for the destination image
    /// @param pix_fmt       the pixel format of the image
    /// @param range         the color range of the image (important for colorspaces such as YUV)
    /// @param width         the width of the image in pixels
    /// @param height        the height of the image in pixels
    /// @return 0 if the image data was cleared, a negative AVERROR code otherwise
    pub fn av_image_fill_black(
        dst_data: *mut *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: lang_items::c_int,
        height: lang_items::c_int,
    ) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
    pub key: *mut lang_items::c_char,
    pub value: *mut lang_items::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    assert_eq!(
        std::mem::size_of::<AVDictionaryEntry>(),
        16usize,
        concat!("Size of: ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        std::mem::align_of::<AVDictionaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVDictionaryEntry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVDictionaryEntry>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    /// Get a dictionary entry with matching key.
    ///
    /// The returned entry key or value must not be changed, or it will
    /// cause undefined behavior.
    ///
    /// To iterate through all the dictionary entries, you can set the matching key
    /// to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
    ///
    /// @param prev Set to the previous matching element to find the next.
    /// If set to NULL the first matching element is returned.
    /// @param key matching key
    /// @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
    /// @return found entry or NULL in case no matching entry was found in the dictionary
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const lang_items::c_char,
        prev: *const AVDictionaryEntry,
        flags: lang_items::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    /// Get number of entries in dictionary.
    ///
    /// @param m dictionary
    /// @return  number of entries in dictionary
    pub fn av_dict_count(m: *const AVDictionary) -> lang_items::c_int;
}
extern "C" {
    /// Set the given entry in *pm, overwriting an existing entry.
    ///
    /// Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
    /// these arguments will be freed on error.
    ///
    /// Warning: Adding a new entry to a dictionary invalidates all existing entries
    /// previously returned with av_dict_get.
    ///
    /// @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
    /// a dictionary struct is allocated and put in *pm.
    /// @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
    /// @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
    /// Passing a NULL value will cause an existing entry to be deleted.
    /// @return >= 0 on success otherwise an error code <0
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const lang_items::c_char,
        value: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Convenience wrapper for av_dict_set that converts the value to a string
    /// and stores it.
    ///
    /// Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const lang_items::c_char,
        value: i64,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Parse the key/value pairs list and add the parsed entries to a dictionary.
    ///
    /// In case of failure, all the successfully set entries are stored in
    /// *pm. You may need to manually free the created dictionary.
    ///
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other
    /// @param flags        flags to use when adding to dictionary.
    /// AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
    /// are ignored since the key/value tokens will always
    /// be duplicated.
    /// @return             0 on success, negative AVERROR code on failure
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str: *const lang_items::c_char,
        key_val_sep: *const lang_items::c_char,
        pairs_sep: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy entries from one AVDictionary struct into another.
    /// @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,
    /// this function will allocate a struct for you and put it in *dst
    /// @param src pointer to source AVDictionary struct
    /// @param flags flags to use when setting entries in *dst
    /// @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag
    /// @return 0 on success, negative AVERROR code on failure. If dst was allocated
    /// by this function, callers should free the associated memory.
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Free all the memory allocated for an AVDictionary struct
    /// and all keys and values.
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    /// Get dictionary entries as a string.
    ///
    /// Create a string containing dictionary's entries.
    /// Such string may be passed back to av_dict_parse_string().
    /// @note String is escaped with backslashes ('\').
    ///
    /// @param[in]  m             dictionary
    /// @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
    /// Buffer must be freed by the caller when is no longer needed.
    /// @param[in]  key_val_sep   character used to separate key from value
    /// @param[in]  pairs_sep     character used to separate two pairs from each other
    /// @return                   >= 0 on success, negative on error
    /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut lang_items::c_char,
        key_val_sep: lang_items::c_char,
        pairs_sep: lang_items::c_char,
    ) -> lang_items::c_int;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
/// < unsigned 8 bits
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
/// < signed 16 bits
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
/// < signed 32 bits
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
/// < float
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
/// < double
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
/// < unsigned 8 bits, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
/// < signed 16 bits, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
/// < signed 32 bits, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
/// < float, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
/// < double, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
/// < signed 64 bits
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
/// < signed 64 bits, planar
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
/// < Number of sample formats. DO NOT USE if linking dynamically
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
/// Audio sample formats
///
/// - The data described by the sample format is always in native-endian order.
/// Sample values can be expressed by native C types, hence the lack of a signed
/// 24-bit sample format even though it is a common raw audio data format.
///
/// - The floating-point formats are based on full volume being in the range
/// [-1.0, 1.0]. Any values outside this range are beyond full volume level.
///
/// - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
/// (such as AVFrame in libavcodec) is as follows:
///
/// @par
/// For planar sample formats, each audio channel is in a separate data plane,
/// and linesize is the buffer size, in bytes, for a single plane. All data
/// planes must be the same size. For packed sample formats, only the first data
/// plane is used, and samples for each channel are interleaved. In this case,
/// linesize is the buffer size, in bytes, for the 1 plane.
///
pub type AVSampleFormat = i32;
extern "C" {
    /// Return the name of sample_fmt, or NULL if sample_fmt is not
    /// recognized.
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const lang_items::c_char;
}
extern "C" {
    /// Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
    /// on error.
    pub fn av_get_sample_fmt(name: *const lang_items::c_char) -> AVSampleFormat;
}
extern "C" {
    /// Return the planar<->packed alternative form of the given sample format, or
    /// AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
    /// requested planar/packed format, the format returned is the same as the
    /// input.
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: lang_items::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    /// Get the packed alternative form of the given sample format.
    ///
    /// If the passed sample_fmt is already in packed format, the format returned is
    /// the same as the input.
    ///
    /// @return  the packed alternative form of the given sample format or
    /// AV_SAMPLE_FMT_NONE on error.
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    /// Get the planar alternative form of the given sample format.
    ///
    /// If the passed sample_fmt is already in planar format, the format returned is
    /// the same as the input.
    ///
    /// @return  the planar alternative form of the given sample format or
    /// AV_SAMPLE_FMT_NONE on error.
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    /// Generate a string corresponding to the sample format with
    /// sample_fmt, or a header if sample_fmt is negative.
    ///
    /// @param buf the buffer where to write the string
    /// @param buf_size the size of buf
    /// @param sample_fmt the number of the sample format to print the
    /// corresponding info string, or a negative value to print the
    /// corresponding header.
    /// @return the pointer to the filled buffer or NULL if sample_fmt is
    /// unknown or in case of other errors
    pub fn av_get_sample_fmt_string(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    /// Return number of bytes per sample.
    ///
    /// @param sample_fmt the sample format
    /// @return number of bytes per sample or zero if unknown for the given
    /// sample format
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> lang_items::c_int;
}
extern "C" {
    /// Check if the sample format is planar.
    ///
    /// @param sample_fmt the sample format to inspect
    /// @return 1 if the sample format is planar, 0 if it is interleaved
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> lang_items::c_int;
}
extern "C" {
    /// Get the required buffer size for the given audio parameters.
    ///
    /// @param[out] linesize calculated linesize, may be NULL
    /// @param nb_channels   the number of channels
    /// @param nb_samples    the number of samples in a single channel
    /// @param sample_fmt    the sample format
    /// @param align         buffer size alignment (0 = default, 1 = no alignment)
    /// @return              required buffer size, or negative error code on failure
    pub fn av_samples_get_buffer_size(
        linesize: *mut lang_items::c_int,
        nb_channels: lang_items::c_int,
        nb_samples: lang_items::c_int,
        sample_fmt: AVSampleFormat,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill plane data pointers and linesize for samples with sample
    /// format sample_fmt.
    ///
    /// The audio_data array is filled with the pointers to the samples data planes:
    /// for planar, set the start point of each channel's data within the buffer,
    /// for packed, set the start point of the entire buffer only.
    ///
    /// The value pointed to by linesize is set to the aligned size of each
    /// channel's data buffer for planar layout, or to the aligned size of the
    /// buffer for all channels for packed layout.
    ///
    /// The buffer in buf must be big enough to contain all the samples
    /// (use av_samples_get_buffer_size() to compute its minimum size),
    /// otherwise the audio_data pointers will point to invalid data.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param[out] audio_data  array to be filled with the pointer for each channel
    /// @param[out] linesize    calculated linesize, may be NULL
    /// @param buf              the pointer to a buffer containing the samples
    /// @param nb_channels      the number of channels
    /// @param nb_samples       the number of samples in a single channel
    /// @param sample_fmt       the sample format
    /// @param align            buffer size alignment (0 = default, 1 = no alignment)
    /// @return                 >=0 on success or a negative error code on failure
    /// @todo return minimum size in bytes required for the buffer in case
    /// of success at the next bump
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut lang_items::c_int,
        buf: *const u8,
        nb_channels: lang_items::c_int,
        nb_samples: lang_items::c_int,
        sample_fmt: AVSampleFormat,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate a samples buffer for nb_samples samples, and fill data pointers and
    /// linesize accordingly.
    /// The allocated samples buffer can be freed by using av_freep(&audio_data[0])
    /// Allocated data will be initialized to silence.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param[out] audio_data  array to be filled with the pointer for each channel
    /// @param[out] linesize    aligned size for audio buffer(s), may be NULL
    /// @param nb_channels      number of audio channels
    /// @param nb_samples       number of samples per channel
    /// @param align            buffer size alignment (0 = default, 1 = no alignment)
    /// @return                 >=0 on success or a negative error code on failure
    /// @todo return the size of the allocated buffer in case of success at the next bump
    /// @see av_samples_fill_arrays()
    /// @see av_samples_alloc_array_and_samples()
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut lang_items::c_int,
        nb_channels: lang_items::c_int,
        nb_samples: lang_items::c_int,
        sample_fmt: AVSampleFormat,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate a data pointers array, samples buffer for nb_samples
    /// samples, and fill data pointers and linesize accordingly.
    ///
    /// This is the same as av_samples_alloc(), but also allocates the data
    /// pointers array.
    ///
    /// @see av_samples_alloc()
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut lang_items::c_int,
        nb_channels: lang_items::c_int,
        nb_samples: lang_items::c_int,
        sample_fmt: AVSampleFormat,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy samples from src to dst.
    ///
    /// @param dst destination array of pointers to data planes
    /// @param src source array of pointers to data planes
    /// @param dst_offset offset in samples at which the data will be written to dst
    /// @param src_offset offset in samples at which the data will be read from src
    /// @param nb_samples number of samples to be copied
    /// @param nb_channels number of audio channels
    /// @param sample_fmt audio sample format
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: lang_items::c_int,
        src_offset: lang_items::c_int,
        nb_samples: lang_items::c_int,
        nb_channels: lang_items::c_int,
        sample_fmt: AVSampleFormat,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill an audio buffer with silence.
    ///
    /// @param audio_data  array of pointers to data planes
    /// @param offset      offset in samples at which to start filling
    /// @param nb_samples  number of samples to fill
    /// @param nb_channels number of audio channels
    /// @param sample_fmt  audio sample format
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: lang_items::c_int,
        nb_samples: lang_items::c_int,
        nb_channels: lang_items::c_int,
        sample_fmt: AVSampleFormat,
    ) -> lang_items::c_int;
}
pub const AVOptionType_AV_OPT_TYPE_FLAGS: AVOptionType = 0;
pub const AVOptionType_AV_OPT_TYPE_INT: AVOptionType = 1;
pub const AVOptionType_AV_OPT_TYPE_INT64: AVOptionType = 2;
pub const AVOptionType_AV_OPT_TYPE_DOUBLE: AVOptionType = 3;
pub const AVOptionType_AV_OPT_TYPE_FLOAT: AVOptionType = 4;
pub const AVOptionType_AV_OPT_TYPE_STRING: AVOptionType = 5;
pub const AVOptionType_AV_OPT_TYPE_RATIONAL: AVOptionType = 6;
/// < offset must point to a pointer immediately followed by an int for the length
pub const AVOptionType_AV_OPT_TYPE_BINARY: AVOptionType = 7;
pub const AVOptionType_AV_OPT_TYPE_DICT: AVOptionType = 8;
pub const AVOptionType_AV_OPT_TYPE_UINT64: AVOptionType = 9;
pub const AVOptionType_AV_OPT_TYPE_CONST: AVOptionType = 10;
/// < offset must point to two consecutive integers
pub const AVOptionType_AV_OPT_TYPE_IMAGE_SIZE: AVOptionType = 11;
pub const AVOptionType_AV_OPT_TYPE_PIXEL_FMT: AVOptionType = 12;
pub const AVOptionType_AV_OPT_TYPE_SAMPLE_FMT: AVOptionType = 13;
/// < offset must point to AVRational
pub const AVOptionType_AV_OPT_TYPE_VIDEO_RATE: AVOptionType = 14;
pub const AVOptionType_AV_OPT_TYPE_DURATION: AVOptionType = 15;
pub const AVOptionType_AV_OPT_TYPE_COLOR: AVOptionType = 16;
pub const AVOptionType_AV_OPT_TYPE_CHANNEL_LAYOUT: AVOptionType = 17;
pub const AVOptionType_AV_OPT_TYPE_BOOL: AVOptionType = 18;
/// @defgroup avoptions AVOptions
/// @ingroup lavu_data
/// @{
/// AVOptions provide a generic system to declare options on arbitrary structs
/// ("objects"). An option can have a help text, a type and a range of possible
/// values. Options may then be enumerated, read and written to.
///
/// @section avoptions_implement Implementing AVOptions
/// This section describes how to add AVOptions capabilities to a struct.
///
/// All AVOptions-related information is stored in an AVClass. Therefore
/// the first member of the struct should be a pointer to an AVClass describing it.
/// The option field of the AVClass must be set to a NULL-terminated static array
/// of AVOptions. Each AVOption must have a non-empty name, a type, a default
/// value and for number-type AVOptions also a range of allowed values. It must
/// also declare an offset in bytes from the start of the struct, where the field
/// associated with this AVOption is located. Other fields in the AVOption struct
/// should also be set when applicable, but are not required.
///
/// The following example illustrates an AVOptions-enabled struct:
/// @code
/// typedef struct test_struct {
/// const AVClass *class;
/// int      int_opt;
/// char    *str_opt;
/// uint8_t *bin_opt;
/// int      bin_len;
/// } test_struct;
///
/// static const AVOption test_options[] = {
/// { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),
/// AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
/// { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),
/// AV_OPT_TYPE_STRING },
/// { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),
/// AV_OPT_TYPE_BINARY },
/// { NULL },
/// };
///
/// static const AVClass test_class = {
/// .class_name = "test class",
/// .item_name  = av_default_item_name,
/// .option     = test_options,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
/// @endcode
///
/// Next, when allocating your struct, you must ensure that the AVClass pointer
/// is set to the correct value. Then, av_opt_set_defaults() can be called to
/// initialize defaults. After that the struct is ready to be used with the
/// AVOptions API.
///
/// When cleaning up, you may use the av_opt_free() function to automatically
/// free all the allocated string and binary options.
///
/// Continuing with the above example:
///
/// @code
/// test_struct *alloc_test_struct(void)
/// {
/// test_struct *ret = av_mallocz(sizeof(*ret));
/// ret->class = &test_class;
/// av_opt_set_defaults(ret);
/// return ret;
/// }
/// void free_test_struct(test_struct **foo)
/// {
/// av_opt_free(*foo);
/// av_freep(foo);
/// }
/// @endcode
///
/// @subsection avoptions_implement_nesting Nesting
/// It may happen that an AVOptions-enabled struct contains another
/// AVOptions-enabled struct as a member (e.g. AVCodecContext in
/// libavcodec exports generic options, while its priv_data field exports
/// codec-specific options). In such a case, it is possible to set up the
/// parent struct to export a child's options. To do that, simply
/// implement AVClass.child_next() and AVClass.child_class_next() in the
/// parent struct's AVClass.
/// Assuming that the test_struct from above now also contains a
/// child_struct field:
///
/// @code
/// typedef struct child_struct {
/// AVClass *class;
/// int flags_opt;
/// } child_struct;
/// static const AVOption child_opts[] = {
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },
/// { NULL },
/// };
/// static const AVClass child_class = {
/// .class_name = "child class",
/// .item_name  = av_default_item_name,
/// .option     = child_opts,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
///
/// void *child_next(void *obj, void *prev)
/// {
/// test_struct *t = obj;
/// if (!prev && t->child_struct)
/// return t->child_struct;
/// return NULL
/// }
/// const AVClass child_class_next(const AVClass *prev)
/// {
/// return prev ? NULL : &child_class;
/// }
/// @endcode
/// Putting child_next() and child_class_next() as defined above into
/// test_class will now make child_struct's options accessible through
/// test_struct (again, proper setup as described above needs to be done on
/// child_struct right after it is created).
///
/// From the above example it might not be clear why both child_next()
/// and child_class_next() are needed. The distinction is that child_next()
/// iterates over actually existing objects, while child_class_next()
/// iterates over all possible child classes. E.g. if an AVCodecContext
/// was initialized to use a codec which has private options, then its
/// child_next() will return AVCodecContext.priv_data and finish
/// iterating. OTOH child_class_next() on AVCodecContext.av_class will
/// iterate over all available codecs with private options.
///
/// @subsection avoptions_implement_named_constants Named constants
/// It is possible to create named constants for options. Simply set the unit
/// field of the option the constants should apply to a string and
/// create the constants themselves as options of type AV_OPT_TYPE_CONST
/// with their unit field set to the same string.
/// Their default_val field should contain the value of the named
/// constant.
/// For example, to add some named constants for the test_flags option
/// above, put the following into the child_opts array:
/// @code
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },
/// { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },
/// @endcode
///
/// @section avoptions_use Using AVOptions
/// This section deals with accessing options in an AVOptions-enabled struct.
/// Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or
/// AVFormatContext in libavformat.
///
/// @subsection avoptions_use_examine Examining AVOptions
/// The basic functions for examining options are av_opt_next(), which iterates
/// over all options defined for one object, and av_opt_find(), which searches
/// for an option with the given name.
///
/// The situation is more complicated with nesting. An AVOptions-enabled struct
/// may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag
/// to av_opt_find() will make the function search children recursively.
///
/// For enumerating there are basically two cases. The first is when you want to
/// get all options that may potentially exist on the struct and its children
/// (e.g.  when constructing documentation). In that case you should call
/// av_opt_child_class_next() recursively on the parent struct's AVClass.  The
/// second case is when you have an already initialized struct with all its
/// children and you want to get all options that can be actually written or read
/// from it. In that case you should call av_opt_child_next() recursively (and
/// av_opt_next() on each result).
///
/// @subsection avoptions_use_get_set Reading and writing AVOptions
/// When setting options, you often have a string read directly from the
/// user. In such a case, simply passing it to av_opt_set() is enough. For
/// non-string type options, av_opt_set() will parse the string according to the
/// option type.
///
/// Similarly av_opt_get() will read any option type and convert it to a string
/// which will be returned. Do not forget that the string is allocated, so you
/// have to free it with av_free().
///
/// In some cases it may be more convenient to put all options into an
/// AVDictionary and call av_opt_set_dict() on it. A specific case of this
/// are the format/codec open functions in lavf/lavc which take a dictionary
/// filled with option as a parameter. This makes it possible to set some options
/// that cannot be set otherwise, since e.g. the input file format is not known
/// before the file is actually opened.
pub type AVOptionType = u32;
/// AVOption
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const lang_items::c_char,
    /// short English help text
    /// @todo What about other languages?
    pub help: *const lang_items::c_char,
    /// The offset relative to the context structure where the option
    /// value is stored. It should be 0 for named constants.
    pub offset: lang_items::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    /// < minimum valid value for the option
    pub min: f64,
    /// < maximum valid value for the option
    pub max: f64,
    pub flags: lang_items::c_int,
    /// The logical unit to which the option belongs. Non-constant
    /// options and corresponding named constants share the same
    /// unit. May be NULL.
    pub unit: *const lang_items::c_char,
}
/// the default value for scalar options
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64: i64,
    pub dbl: f64,
    pub str: *const lang_items::c_char,
    pub q: AVRational,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_AVOption__bindgen_ty_1() {
    assert_eq!(
        std::mem::size_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        std::mem::align_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption__bindgen_ty_1>())).i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(i64)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption__bindgen_ty_1>())).dbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(dbl)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption__bindgen_ty_1>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_AVOption() {
    assert_eq!(
        std::mem::size_of::<AVOption>(),
        64usize,
        concat!("Size of: ", stringify!(AVOption))
    );
    assert_eq!(
        std::mem::align_of::<AVOption>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).help as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).default_val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(default_val)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOption>())).unit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(unit)
        )
    );
}
/// A single allowed range of values, or a single allowed value.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRange {
    pub str: *const lang_items::c_char,
    /// Value range.
    /// For string ranges this represents the min/max length.
    /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
    pub value_min: f64,
    /// Value range.
    /// For string ranges this represents the min/max length.
    /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
    pub value_max: f64,
    /// Value's component range.
    /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
    pub component_min: f64,
    /// Value's component range.
    /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
    pub component_max: f64,
    /// Range flag.
    /// If set to 1 the struct encodes a range, if set to 0 a single value.
    pub is_range: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRange() {
    assert_eq!(
        std::mem::size_of::<AVOptionRange>(),
        48usize,
        concat!("Size of: ", stringify!(AVOptionRange))
    );
    assert_eq!(
        std::mem::align_of::<AVOptionRange>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRange))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).value_min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).value_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_max)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).component_min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).component_max as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_max)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRange>())).is_range as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(is_range)
        )
    );
}
/// List of AVOptionRange structs.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    /// Array of option ranges.
    ///
    /// Most of option types use just one component.
    /// Following describes multi-component option types:
    ///
    /// AV_OPT_TYPE_IMAGE_SIZE:
    /// component index 0: range of pixel count (width * height).
    /// component index 1: range of width.
    /// component index 2: range of height.
    ///
    /// @note To obtain multi-component version of this structure, user must
    /// provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or
    /// av_opt_query_ranges_default function.
    ///
    /// Multi-component range can be read as in following example:
    ///
    /// @code
    /// int range_index, component_index;
    /// AVOptionRanges *ranges;
    /// AVOptionRange *range[3]; //may require more than 3 in the future.
    /// av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);
    /// for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {
    /// for (component_index = 0; component_index < ranges->nb_components; component_index++)
    /// range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];
    /// //do something with range here.
    /// }
    /// av_opt_freep_ranges(&ranges);
    /// @endcode
    pub range: *mut *mut AVOptionRange,
    /// Number of ranges per component.
    pub nb_ranges: lang_items::c_int,
    /// Number of componentes.
    pub nb_components: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRanges() {
    assert_eq!(
        std::mem::size_of::<AVOptionRanges>(),
        16usize,
        concat!("Size of: ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        std::mem::align_of::<AVOptionRanges>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRanges>())).range as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRanges>())).nb_ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOptionRanges>())).nb_components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_components)
        )
    );
}
extern "C" {
    /// Show the obj options.
    ///
    /// @param req_flags requested flags for the options to show. Show only the
    /// options for which it is opt->flags & req_flags.
    /// @param rej_flags rejected flags for the options to show. Show only the
    /// options for which it is !(opt->flags & req_flags).
    /// @param av_log_obj log context to use for showing the options
    pub fn av_opt_show2(
        obj: *mut lang_items::c_void,
        av_log_obj: *mut lang_items::c_void,
        req_flags: lang_items::c_int,
        rej_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Set the values of all AVOption fields to their default values.
    ///
    /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
    pub fn av_opt_set_defaults(s: *mut lang_items::c_void);
}
extern "C" {
    /// Set the values of all AVOption fields to their default values. Only these
    /// AVOption fields for which (opt->flags & mask) == flags will have their
    /// default applied to s.
    ///
    /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
    /// @param mask combination of AV_OPT_FLAG_*
    /// @param flags combination of AV_OPT_FLAG_*
    pub fn av_opt_set_defaults2(
        s: *mut lang_items::c_void,
        mask: lang_items::c_int,
        flags: lang_items::c_int,
    );
}
extern "C" {
    /// Parse the key/value pairs list in opts. For each key/value pair
    /// found, stores the value in the field in ctx that is named like the
    /// key. ctx must be an AVClass context, storing is done using
    /// AVOptions.
    ///
    /// @param opts options string to parse, may be NULL
    /// @param key_val_sep a 0-terminated list of characters used to
    /// separate key from value
    /// @param pairs_sep a 0-terminated list of characters used to separate
    /// two pairs from each other
    /// @return the number of successfully set key/value pairs, or a negative
    /// value corresponding to an AVERROR code in case of error:
    /// AVERROR(EINVAL) if opts cannot be parsed,
    /// the error code issued by av_opt_set() if a key/value pair
    /// cannot be set
    pub fn av_set_options_string(
        ctx: *mut lang_items::c_void,
        opts: *const lang_items::c_char,
        key_val_sep: *const lang_items::c_char,
        pairs_sep: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Parse the key-value pairs list in opts. For each key=value pair found,
    /// set the value of the corresponding option in ctx.
    ///
    /// @param ctx          the AVClass object to set options on
    /// @param opts         the options string, key-value pairs separated by a
    /// delimiter
    /// @param shorthand    a NULL-terminated array of options names for shorthand
    /// notation: if the first field in opts has no key part,
    /// the key is taken from the first element of shorthand;
    /// then again for the second, etc., until either opts is
    /// finished, shorthand is finished or a named option is
    /// found; after that, all options must be named
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value, for example '='
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other, for example ':' or ','
    /// @return  the number of successfully set key=value pairs, or a negative
    /// value corresponding to an AVERROR code in case of error:
    /// AVERROR(EINVAL) if opts cannot be parsed,
    /// the error code issued by av_set_string3() if a key/value pair
    /// cannot be set
    ///
    /// Options names must use only the following characters: a-z A-Z 0-9 - . / _
    /// Separators must use characters distinct from option names and from each
    /// other.
    pub fn av_opt_set_from_string(
        ctx: *mut lang_items::c_void,
        opts: *const lang_items::c_char,
        shorthand: *const *const lang_items::c_char,
        key_val_sep: *const lang_items::c_char,
        pairs_sep: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Free all allocated objects in obj.
    pub fn av_opt_free(obj: *mut lang_items::c_void);
}
extern "C" {
    /// Check whether a particular flag is set in a flags field.
    ///
    /// @param field_name the name of the flag field option
    /// @param flag_name the name of the flag to check
    /// @return non-zero if the flag is set, zero if the flag isn't set,
    /// isn't of the right type, or the flags field doesn't exist.
    pub fn av_opt_flag_is_set(
        obj: *mut lang_items::c_void,
        field_name: *const lang_items::c_char,
        flag_name: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Set all the options from a given dictionary on an object.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass
    /// @param options options to process. This dictionary will be freed and replaced
    /// by a new one containing all options not found in obj.
    /// Of course this new dictionary needs to be freed by caller
    /// with av_dict_free().
    ///
    /// @return 0 on success, a negative AVERROR if some option was found in obj,
    /// but could not be set.
    ///
    /// @see av_dict_copy()
    pub fn av_opt_set_dict(
        obj: *mut lang_items::c_void,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Set all the options from a given dictionary on an object.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass
    /// @param options options to process. This dictionary will be freed and replaced
    /// by a new one containing all options not found in obj.
    /// Of course this new dictionary needs to be freed by caller
    /// with av_dict_free().
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    ///
    /// @return 0 on success, a negative AVERROR if some option was found in obj,
    /// but could not be set.
    ///
    /// @see av_dict_copy()
    pub fn av_opt_set_dict2(
        obj: *mut lang_items::c_void,
        options: *mut *mut AVDictionary,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Extract a key-value pair from the beginning of a string.
    ///
    /// @param ropts        pointer to the options string, will be updated to
    /// point to the rest of the string (one of the pairs_sep
    /// or the final NUL)
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value, for example '='
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other, for example ':' or ','
    /// @param flags        flags; see the AV_OPT_FLAG_* values below
    /// @param rkey         parsed key; must be freed using av_free()
    /// @param rval         parsed value; must be freed using av_free()
    ///
    /// @return  >=0 for success, or a negative value corresponding to an
    /// AVERROR code in case of error; in particular:
    /// AVERROR(EINVAL) if no key is present
    ///
    pub fn av_opt_get_key_value(
        ropts: *mut *const lang_items::c_char,
        key_val_sep: *const lang_items::c_char,
        pairs_sep: *const lang_items::c_char,
        flags: lang_items::c_uint,
        rkey: *mut *mut lang_items::c_char,
        rval: *mut *mut lang_items::c_char,
    ) -> lang_items::c_int;
}
/// Accept to parse a value without a key; the key will then be returned
/// as NULL.
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
extern "C" {
    /// @defgroup opt_eval_funcs Evaluating option strings
    /// @{
    /// This group of functions can be used to evaluate option strings
    /// and get numbers out of them. They do the same thing as av_opt_set(),
    /// except the result is written into the caller-supplied pointer.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass.
    /// @param o an option for which the string is to be evaluated.
    /// @param val string to be evaluated.
    /// @param *_out value of the string will be written here.
    ///
    /// @return 0 on success, a negative number on failure.
    pub fn av_opt_eval_flags(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        flags_out: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        int_out: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        int64_out: *mut i64,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        float_out: *mut f32,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        double_out: *mut f64,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
        val: *const lang_items::c_char,
        q_out: *mut AVRational,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Look for an option in an object. Consider only options which
    /// have all the specified flags set.
    ///
    /// @param[in] obj A pointer to a struct whose first element is a
    /// pointer to an AVClass.
    /// Alternatively a double pointer to an AVClass, if
    /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
    /// @param[in] name The name of the option to look for.
    /// @param[in] unit When searching for named constants, name of the unit
    /// it belongs to.
    /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    ///
    /// @return A pointer to the option found, or NULL if no option
    /// was found.
    ///
    /// @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
    /// directly with av_opt_set(). Use special calls which take an options
    /// AVDictionary (e.g. avformat_open_input()) to set options found with this
    /// flag.
    pub fn av_opt_find(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        unit: *const lang_items::c_char,
        opt_flags: lang_items::c_int,
        search_flags: lang_items::c_int,
    ) -> *const AVOption;
}
extern "C" {
    /// Look for an option in an object. Consider only options which
    /// have all the specified flags set.
    ///
    /// @param[in] obj A pointer to a struct whose first element is a
    /// pointer to an AVClass.
    /// Alternatively a double pointer to an AVClass, if
    /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
    /// @param[in] name The name of the option to look for.
    /// @param[in] unit When searching for named constants, name of the unit
    /// it belongs to.
    /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    /// @param[out] target_obj if non-NULL, an object to which the option belongs will be
    /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
    /// in search_flags. This parameter is ignored if search_flags contain
    /// AV_OPT_SEARCH_FAKE_OBJ.
    ///
    /// @return A pointer to the option found, or NULL if no option
    /// was found.
    pub fn av_opt_find2(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        unit: *const lang_items::c_char,
        opt_flags: lang_items::c_int,
        search_flags: lang_items::c_int,
        target_obj: *mut *mut lang_items::c_void,
    ) -> *const AVOption;
}
extern "C" {
    /// Iterate over all AVOptions belonging to obj.
    ///
    /// @param obj an AVOptions-enabled struct or a double pointer to an
    /// AVClass describing it.
    /// @param prev result of the previous call to av_opt_next() on this object
    /// or NULL
    /// @return next AVOption or NULL
    pub fn av_opt_next(obj: *const lang_items::c_void, prev: *const AVOption) -> *const AVOption;
}
extern "C" {
    /// Iterate over AVOptions-enabled children of obj.
    ///
    /// @param prev result of a previous call to this function or NULL
    /// @return next AVOptions-enabled child or NULL
    pub fn av_opt_child_next(
        obj: *mut lang_items::c_void,
        prev: *mut lang_items::c_void,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Iterate over potential AVOptions-enabled children of parent.
    ///
    /// @param prev result of a previous call to this function or NULL
    /// @return AVClass corresponding to next potential child or NULL
    pub fn av_opt_child_class_next(parent: *const AVClass, prev: *const AVClass) -> *const AVClass;
}
extern "C" {
    /// @defgroup opt_set_funcs Option setting functions
    /// @{
    /// Those functions set the field of obj with the given name to value.
    ///
    /// @param[in] obj A struct whose first element is a pointer to an AVClass.
    /// @param[in] name the name of the field to set
    /// @param[in] val The value to set. In case of av_opt_set() if the field is not
    /// of a string type, then the given string is parsed.
    /// SI postfixes and some named scalars are supported.
    /// If the field is of a numeric type, it has to be a numeric or named
    /// scalar. Behavior with more than one scalar and +- infix operators
    /// is undefined.
    /// If the field is of a flags type, it has to be a sequence of numeric
    /// scalars or named flags separated by '+' or '-'. Prefixing a flag
    /// with '+' causes it to be set without affecting the other flags;
    /// similarly, '-' unsets a flag.
    /// @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
    /// is passed here, then the option may be set on a child of obj.
    ///
    /// @return 0 if the value has been set, or an AVERROR code in case of
    /// error:
    /// AVERROR_OPTION_NOT_FOUND if no matching option exists
    /// AVERROR(ERANGE) if the value is out of range
    /// AVERROR(EINVAL) if the value is not valid
    pub fn av_opt_set(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: *const lang_items::c_char,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: i64,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: f64,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: AVRational,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: *const u8,
        size: lang_items::c_int,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        w: lang_items::c_int,
        h: lang_items::c_int,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        fmt: AVPixelFormat,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        fmt: AVSampleFormat,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: AVRational,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        ch_layout: i64,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @note Any old dictionary present is discarded and replaced with a copy of the new one. The
    /// caller still owns val is and responsible for freeing it.
    pub fn av_opt_set_dict_val(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        val: *const AVDictionary,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @defgroup opt_get_funcs Option getting functions
    /// @{
    /// Those functions get a value of the option with the given name from an object.
    ///
    /// @param[in] obj a struct whose first element is a pointer to an AVClass.
    /// @param[in] name name of the option to get.
    /// @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
    /// is passed here, then the option may be found in a child of obj.
    /// @param[out] out_val value of the option will be written here
    /// @return >=0 on success, a negative error code otherwise
    /// /
    /// /**
    /// @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
    ///
    /// @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has
    /// AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set
    /// to NULL instead of an allocated empty string.
    pub fn av_opt_get(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut *mut u8,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut i64,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut f64,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut AVRational,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        w_out: *mut lang_items::c_int,
        h_out: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut AVRational,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        ch_layout: *mut i64,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @param[out] out_val The returned dictionary is a copy of the actual value and must
    /// be freed with av_dict_free() by the caller
    pub fn av_opt_get_dict_val(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @}
    /// /
    /// /**
    /// Gets a pointer to the requested field in a struct.
    /// This function allows accessing a struct even when its fields are moved or
    /// renamed since the application making the access has been compiled,
    ///
    /// @returns a pointer to the field, it can be cast to the correct type and read
    /// or written to.
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    /// Free an AVOptionRanges struct and set it to NULL.
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    /// Get a list of allowed ranges for the given option.
    ///
    /// The returned list may depend on other fields in obj like for example profile.
    ///
    /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
    /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
    /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
    ///
    /// The result must be freed with av_opt_freep_ranges.
    ///
    /// @return number of compontents returned on success, a negative errro code otherwise
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut lang_items::c_void,
        key: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy options from src object into dest object.
    ///
    /// Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
    /// Original memory allocated for such options is freed unless both src and dest options points to the same memory.
    ///
    /// @param dest Object to copy from
    /// @param src  Object to copy into
    /// @return 0 on success, negative on error
    pub fn av_opt_copy(
        dest: *mut lang_items::c_void,
        src: *const lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get a default list of allowed ranges for the given option.
    ///
    /// This list is constructed without using the AVClass.query_ranges() callback
    /// and can be used as fallback from within the callback.
    ///
    /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
    /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
    /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
    ///
    /// The result must be freed with av_opt_free_ranges.
    ///
    /// @return number of compontents returned on success, a negative errro code otherwise
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut lang_items::c_void,
        key: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check if given option is set to its default value.
    ///
    /// Options o must belong to the obj. This function must not be called to check child's options state.
    /// @see av_opt_is_set_to_default_by_name().
    ///
    /// @param obj  AVClass object to check option on
    /// @param o    option to be checked
    /// @return     >0 when option is set to its default,
    /// 0 when option is not set its default,
    /// <0 on error
    pub fn av_opt_is_set_to_default(
        obj: *mut lang_items::c_void,
        o: *const AVOption,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check if given option is set to its default value.
    ///
    /// @param obj          AVClass object to check option on
    /// @param name         option name
    /// @param search_flags combination of AV_OPT_SEARCH_*
    /// @return             >0 when option is set to its default,
    /// 0 when option is not set its default,
    /// <0 on error
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut lang_items::c_void,
        name: *const lang_items::c_char,
        search_flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Serialize object's options.
    ///
    /// Create a string containing object's serialized options.
    /// Such string may be passed back to av_opt_set_from_string() in order to restore option values.
    /// A key/value or pairs separator occurring in the serialized value or
    /// name string are escaped through the av_escape() function.
    ///
    /// @param[in]  obj           AVClass object to serialize
    /// @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)
    /// @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags
    /// @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.
    /// Buffer must be freed by the caller when is no longer needed.
    /// @param[in]  key_val_sep   character used to separate key from value
    /// @param[in]  pairs_sep     character used to separate two pairs from each other
    /// @return                   >= 0 on success, negative on error
    /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
    pub fn av_opt_serialize(
        obj: *mut lang_items::c_void,
        opt_flags: lang_items::c_int,
        flags: lang_items::c_int,
        buffer: *mut *mut lang_items::c_char,
        key_val_sep: lang_items::c_char,
        pairs_sep: lang_items::c_char,
    ) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: lang_items::c_int,
    pub tm_min: lang_items::c_int,
    pub tm_hour: lang_items::c_int,
    pub tm_mday: lang_items::c_int,
    pub tm_mon: lang_items::c_int,
    pub tm_year: lang_items::c_int,
    pub tm_wday: lang_items::c_int,
    pub tm_yday: lang_items::c_int,
    pub tm_isdst: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut lang_items::c_char,
        _maxsize: usize,
        _fmt: *const lang_items::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut lang_items::c_char,
        _maxsize: usize,
        _fmt: *const lang_items::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut lang_items::c_char) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: lang_items::c_char,
    pub m: lang_items::c_int,
    pub n: lang_items::c_int,
    pub d: lang_items::c_int,
    pub s: lang_items::c_int,
    pub change: time_t,
    pub offset: lang_items::c_long,
}
#[test]
fn bindgen_test_layout___tzrule_struct() {
    assert_eq!(
        std::mem::size_of::<__tzrule_struct>(),
        40usize,
        concat!("Size of: ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        std::mem::align_of::<__tzrule_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).ch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).m as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).change as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzrule_struct>())).offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(offset)
        )
    );
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: lang_items::c_int,
    pub __tzyear: lang_items::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
#[test]
fn bindgen_test_layout___tzinfo_struct() {
    assert_eq!(
        std::mem::size_of::<__tzinfo_struct>(),
        88usize,
        concat!("Size of: ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        std::mem::align_of::<__tzinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzinfo_struct>())).__tznorth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tznorth)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzinfo_struct>())).__tzyear as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzyear)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__tzinfo_struct>())).__tzrule as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzrule)
        )
    );
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: lang_items::c_long;
}
extern "C" {
    pub static mut _daylight: lang_items::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut lang_items::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: lang_items::c_int,
    pub sival_ptr: *mut lang_items::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: lang_items::c_int,
    pub sigev_signo: lang_items::c_int,
    pub sigev_value: sigval,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        std::mem::size_of::<sigevent>(),
        16usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: lang_items::c_int,
    pub si_code: lang_items::c_int,
    pub si_value: sigval,
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        std::mem::size_of::<siginfo_t>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<siginfo_t>())).si_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_value)
        )
    );
}
pub type _sig_func_ptr = std::option::Option<unsafe extern "C" fn(arg1: lang_items::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        std::mem::size_of::<sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut lang_items::c_void,
    pub ss_flags: lang_items::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        how: lang_items::c_int,
        set: *const sigset_t,
        oset: *mut sigset_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        how: lang_items::c_int,
        set: *const sigset_t,
        oset: *mut sigset_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: lang_items::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> lang_items::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> lang_items::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> lang_items::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> lang_items::c_int;
}
extern "C" {
    pub fn sigwait(set: *const sigset_t, sig: *mut lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigpause(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> lang_items::c_int;
}
extern "C" {
    pub fn pthread_kill(thread: pthread_t, sig: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> lang_items::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        set: *const sigset_t,
        info: *mut siginfo_t,
        timeout: *const timespec,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn sigqueue(pid: pid_t, signo: lang_items::c_int, value: sigval) -> lang_items::c_int;
}
pub type sig_atomic_t = lang_items::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(
        arg1: *mut _reent,
        arg2: lang_items::c_int,
        arg3: _sig_func_ptr,
    ) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn signal(arg1: lang_items::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    pub fn psignal(arg1: lang_items::c_int, arg2: *const lang_items::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> lang_items::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> lang_items::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> lang_items::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> lang_items::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: lang_items::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> lang_items::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> lang_items::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
/// A reference to a data buffer.
///
/// The size of this struct is not a part of the public ABI and it is not meant
/// to be allocated directly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    /// The data buffer. It is considered writable if and only if
    /// this is the only reference to the buffer, in which case
    /// av_buffer_is_writable() returns 1.
    pub data: *mut u8,
    /// Size of data in bytes.
    pub size: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    assert_eq!(
        std::mem::size_of::<AVBufferRef>(),
        24usize,
        concat!("Size of: ", stringify!(AVBufferRef))
    );
    assert_eq!(
        std::mem::align_of::<AVBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferRef))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBufferRef>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBufferRef>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBufferRef>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    /// Allocate an AVBuffer of the given size using av_malloc().
    ///
    /// @return an AVBufferRef of given size or NULL when out of memory
    pub fn av_buffer_alloc(size: lang_items::c_int) -> *mut AVBufferRef;
}
extern "C" {
    /// Same as av_buffer_alloc(), except the returned buffer will be initialized
    /// to zero.
    pub fn av_buffer_allocz(size: lang_items::c_int) -> *mut AVBufferRef;
}
extern "C" {
    /// Create an AVBuffer from an existing array.
    ///
    /// If this function is successful, data is owned by the AVBuffer. The caller may
    /// only access data through the returned AVBufferRef and references derived from
    /// it.
    /// If this function fails, data is left untouched.
    /// @param data   data array
    /// @param size   size of data in bytes
    /// @param free   a callback for freeing this buffer's data
    /// @param opaque parameter to be got for processing or passed to free
    /// @param flags  a combination of AV_BUFFER_FLAG_*
    ///
    /// @return an AVBufferRef referring to data on success, NULL on failure.
    pub fn av_buffer_create(
        data: *mut u8,
        size: lang_items::c_int,
        free: std::option::Option<
            unsafe extern "C" fn(opaque: *mut lang_items::c_void, data: *mut u8),
        >,
        opaque: *mut lang_items::c_void,
        flags: lang_items::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    /// Default free callback, which calls av_free() on the buffer data.
    /// This function is meant to be passed to av_buffer_create(), not called
    /// directly.
    pub fn av_buffer_default_free(opaque: *mut lang_items::c_void, data: *mut u8);
}
extern "C" {
    /// Create a new reference to an AVBuffer.
    ///
    /// @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
    /// failure.
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    /// Free a given reference and automatically free the buffer if there are no more
    /// references to it.
    ///
    /// @param buf the reference to be freed. The pointer is set to NULL on return.
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    /// @return 1 if the caller may write to the data referred to by buf (which is
    /// true if and only if buf is the only reference to the underlying AVBuffer).
    /// Return 0 otherwise.
    /// A positive answer is valid until av_buffer_ref() is called on buf.
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> lang_items::c_int;
}
extern "C" {
    /// @return the opaque parameter set by av_buffer_create.
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> lang_items::c_int;
}
extern "C" {
    /// Create a writable reference from a given buffer reference, avoiding data copy
    /// if possible.
    ///
    /// @param buf buffer reference to make writable. On success, buf is either left
    /// untouched, or it is unreferenced and a new writable AVBufferRef is
    /// written in its place. On failure, buf is left untouched.
    /// @return 0 on success, a negative AVERROR on failure.
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> lang_items::c_int;
}
extern "C" {
    /// Reallocate a given buffer.
    ///
    /// @param buf  a buffer reference to reallocate. On success, buf will be
    /// unreferenced and a new reference with the required size will be
    /// written in its place. On failure buf will be left untouched. *buf
    /// may be NULL, then a new buffer is allocated.
    /// @param size required new buffer size.
    /// @return 0 on success, a negative AVERROR on failure.
    ///
    /// @note the buffer is actually reallocated with av_realloc() only if it was
    /// initially allocated through av_buffer_realloc(NULL) and there is only one
    /// reference to it (i.e. the one passed to this function). In all other cases
    /// a new buffer is allocated and the data is copied.
    pub fn av_buffer_realloc(
        buf: *mut *mut AVBufferRef,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate and initialize a buffer pool.
    ///
    /// @param size size of each buffer in this pool
    /// @param alloc a function that will be used to allocate new buffers when the
    /// pool is empty. May be NULL, then the default allocator will be used
    /// (av_buffer_alloc()).
    /// @return newly created buffer pool on success, NULL on error.
    pub fn av_buffer_pool_init(
        size: lang_items::c_int,
        alloc: std::option::Option<
            unsafe extern "C" fn(size: lang_items::c_int) -> *mut AVBufferRef,
        >,
    ) -> *mut AVBufferPool;
}
extern "C" {
    /// Allocate and initialize a buffer pool with a more complex allocator.
    ///
    /// @param size size of each buffer in this pool
    /// @param opaque arbitrary user data used by the allocator
    /// @param alloc a function that will be used to allocate new buffers when the
    /// pool is empty.
    /// @param pool_free a function that will be called immediately before the pool
    /// is freed. I.e. after av_buffer_pool_uninit() is called
    /// by the caller and all the frames are returned to the pool
    /// and freed. It is intended to uninitialize the user opaque
    /// data.
    /// @return newly created buffer pool on success, NULL on error.
    pub fn av_buffer_pool_init2(
        size: lang_items::c_int,
        opaque: *mut lang_items::c_void,
        alloc: std::option::Option<
            unsafe extern "C" fn(opaque: *mut lang_items::c_void, size: lang_items::c_int)
                -> *mut AVBufferRef,
        >,
        pool_free: std::option::Option<unsafe extern "C" fn(opaque: *mut lang_items::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    /// Mark the pool as being available for freeing. It will actually be freed only
    /// once all the allocated buffers associated with the pool are released. Thus it
    /// is safe to call this function while some of the allocated buffers are still
    /// in use.
    ///
    /// @param pool pointer to the pool to be freed. It will be set to NULL.
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    /// Allocate a new AVBuffer, reusing an old buffer from the pool when available.
    /// This function may be called simultaneously from multiple threads.
    ///
    /// @return a reference to the new buffer on success, NULL on error.
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    /// Return the flags which specify extensions supported by the CPU.
    /// The returned value is affected by av_force_cpu_flags() if that was used
    /// before. So av_get_cpu_flags() can easily be used in an application to
    /// detect the enabled cpu flags.
    pub fn av_get_cpu_flags() -> lang_items::c_int;
}
extern "C" {
    /// Disables cpu detection and forces the specified flags.
    /// -1 is a special case that disables forcing of specific flags.
    pub fn av_force_cpu_flags(flags: lang_items::c_int);
}
extern "C" {
    /// Set a mask on flags returned by av_get_cpu_flags().
    /// This function is mainly useful for testing.
    /// Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
    pub fn av_set_cpu_flags_mask(mask: lang_items::c_int);
}
extern "C" {
    /// Parse CPU flags from a string.
    ///
    /// The returned flags contain the specified flags as well as related unspecified flags.
    ///
    /// This function exists only for compatibility with libav.
    /// Please use av_parse_cpu_caps() when possible.
    /// @return a combination of AV_CPU_* flags, negative on error.
    pub fn av_parse_cpu_flags(s: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
    ///
    /// @return negative on error.
    pub fn av_parse_cpu_caps(
        flags: *mut lang_items::c_uint,
        s: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @return the number of logical CPU cores present.
    pub fn av_cpu_count() -> lang_items::c_int;
}
extern "C" {
    /// Get the maximum data alignment that may be required by FFmpeg.
    ///
    /// Note that this is affected by the build configuration and the CPU flags mask,
    /// so e.g. if the CPU supports AVX, but libavutil has been built with
    /// --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
    /// av_set_cpu_flags_mask(), then this function will behave as if AVX is not
    /// present.
    pub fn av_cpu_max_align() -> usize;
}
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = u32;
extern "C" {
    /// Return a channel layout id that matches name, or 0 if no match is found.
    ///
    /// name can be one or several of the following notations,
    /// separated by '+' or '|':
    /// - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
    /// 5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
    /// - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
    /// SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
    /// - a number of channels, in decimal, followed by 'c', yielding
    /// the default channel layout for that number of channels (@see
    /// av_get_default_channel_layout);
    /// - a channel layout mask, in hexadecimal starting with "0x" (see the
    /// AV_CH_* macros).
    ///
    /// Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
    pub fn av_get_channel_layout(name: *const lang_items::c_char) -> u64;
}
extern "C" {
    /// Return a channel layout and the number of channels based on the specified name.
    ///
    /// This function is similar to (@see av_get_channel_layout), but can also parse
    /// unknown channel layout specifications.
    ///
    /// @param[in]  name             channel layout specification string
    /// @param[out] channel_layout   parsed channel layout (0 if unknown)
    /// @param[out] nb_channels      number of channels
    ///
    /// @return 0 on success, AVERROR(EINVAL) if the parsing fails.
    pub fn av_get_extended_channel_layout(
        name: *const lang_items::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return a description of a channel layout.
    /// If nb_channels is <= 0, it is guessed from the channel_layout.
    ///
    /// @param buf put here the string containing the channel layout
    /// @param buf_size size in bytes of the buffer
    pub fn av_get_channel_layout_string(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        nb_channels: lang_items::c_int,
        channel_layout: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    /// Append a description of a channel layout to a bprint buffer.
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: lang_items::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    /// Return the number of channels in the channel layout.
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> lang_items::c_int;
}
extern "C" {
    /// Return default channel layout for a given number of channels.
    pub fn av_get_default_channel_layout(nb_channels: lang_items::c_int) -> i64;
}
extern "C" {
    /// Get the index of a channel in channel_layout.
    ///
    /// @param channel a channel layout describing exactly one channel which must be
    /// present in channel_layout.
    ///
    /// @return index of channel in channel_layout on success, a negative AVERROR
    /// on error.
    pub fn av_get_channel_layout_channel_index(
        channel_layout: u64,
        channel: u64,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get the channel with the given index in channel_layout.
    pub fn av_channel_layout_extract_channel(channel_layout: u64, index: lang_items::c_int) -> u64;
}
extern "C" {
    /// Get the name of a given channel.
    ///
    /// @return channel name on success, NULL on error.
    pub fn av_get_channel_name(channel: u64) -> *const lang_items::c_char;
}
extern "C" {
    /// Get the description of a given channel.
    ///
    /// @param channel  a channel layout with a single channel
    /// @return  channel description on success, NULL on error
    pub fn av_get_channel_description(channel: u64) -> *const lang_items::c_char;
}
extern "C" {
    /// Get the value and name of a standard channel layout.
    ///
    /// @param[in]  index   index in an internal list, starting at 0
    /// @param[out] layout  channel layout mask
    /// @param[out] name    name of the layout
    /// @return  0  if the layout exists,
    /// <0 if index is beyond the limits
    pub fn av_get_standard_channel_layout(
        index: lang_items::c_uint,
        layout: *mut u64,
        name: *mut *const lang_items::c_char,
    ) -> lang_items::c_int;
}
/// The data is the AVPanScan struct defined in libavcodec.
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
/// ATSC A53 Part 4 Closed Captions.
/// A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.
/// The number of bytes of CC data is AVFrameSideData.size.
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
/// Stereoscopic 3d metadata.
/// The data is the AVStereo3D struct defined in libavutil/stereo3d.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
/// The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
/// Metadata relevant to a downmix procedure.
/// The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
/// ReplayGain information in the form of the AVReplayGain struct.
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
/// This side data contains a 3x3 transformation matrix describing an affine
/// transformation that needs to be applied to the frame for correct
/// presentation.
///
/// See libavutil/display.h for a detailed description of the data.
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
/// Active Format Description data consisting of a single byte as specified
/// in ETSI TS 101 154 using AVActiveFormatDescription enum.
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
/// Motion vectors exported by some codecs (on demand through the export_mvs
/// flag set in the libavcodec AVCodecContext flags2 option).
/// The data is the AVMotionVector struct defined in
/// libavutil/motion_vector.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
/// Recommmends skipping the specified number of samples. This is exported
/// only if the "skip_manual" AVOption is set in libavcodec.
/// This has the same format as AV_PKT_DATA_SKIP_SAMPLES.
/// @code
/// u32le number of samples to skip from start of this packet
/// u32le number of samples to skip from end of this packet
/// u8    reason for start skip
/// u8    reason for end   skip (0=padding silence, 1=convergence)
/// @endcode
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
/// This side data must be associated with an audio frame and corresponds to
/// enum AVAudioServiceType defined in avcodec.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
/// Mastering display metadata associated with a video frame. The payload is
/// an AVMasteringDisplayMetadata type and contains information about the
/// mastering display color volume.
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
/// The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.
/// This is set on the first frame of a GOP that has a temporal reference of 0.
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
/// The data represents the AVSphericalMapping structure defined in
/// libavutil/spherical.h.
pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
/// Content light level (based on CTA-861.3). This payload contains data in
/// the form of the AVContentLightMetadata struct.
pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
/// The data contains an ICC profile as an opaque octet buffer following the
/// format described by ISO 15076-1 with an optional name defined in the
/// metadata key entry "name".
pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
/// Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.
/// The contents of this side data are undocumented and internal; use
/// av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a
/// meaningful way instead.
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_PROPERTIES: AVFrameSideDataType = 16;
/// Raw QP table data. Its format is described by
/// AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and
/// av_frame_get_qp_table() to access this instead.
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_DATA: AVFrameSideDataType = 17;
/// @defgroup lavu_frame AVFrame
/// @ingroup lavu_data
///
/// @{
/// AVFrame is an abstraction for reference-counted raw multimedia data.
pub type AVFrameSideDataType = u32;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = u32;
/// Structure to hold side data for an AVFrame.
///
/// sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: lang_items::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    assert_eq!(
        std::mem::size_of::<AVFrameSideData>(),
        40usize,
        concat!("Size of: ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        std::mem::align_of::<AVFrameSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrameSideData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrameSideData>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrameSideData>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrameSideData>())).metadata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrameSideData>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(buf)
        )
    );
}
/// This structure describes decoded (raw) audio or video data.
///
/// AVFrame must be allocated using av_frame_alloc(). Note that this only
/// allocates the AVFrame itself, the buffers for the data must be managed
/// through other means (see below).
/// AVFrame must be freed with av_frame_free().
///
/// AVFrame is typically allocated once and then reused multiple times to hold
/// different data (e.g. a single AVFrame to hold frames received from a
/// decoder). In such a case, av_frame_unref() will free any references held by
/// the frame and reset it to its original clean state before it
/// is reused again.
///
/// The data described by an AVFrame is usually reference counted through the
/// AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
/// AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
/// least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
/// every single data plane must be contained in one of the buffers in
/// AVFrame.buf or AVFrame.extended_buf.
/// There may be a single buffer for all the data, or one separate buffer for
/// each plane, or anything in between.
///
/// sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
///
/// Fields can be accessed through AVOptions, the name string used, matches the
/// C structure field name for fields accessible through AVOptions. The AVClass
/// for AVFrame can be obtained from avcodec_get_frame_class()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrame {
    /// pointer to the picture/channel planes.
    /// This might be different from the first allocated byte
    ///
    /// Some decoders access areas outside 0,0 - width,height, please
    /// see avcodec_align_dimensions2(). Some filters and swscale can read
    /// up to 16 bytes beyond the planes, if these filters are to be used,
    /// then 16 extra bytes must be allocated.
    ///
    /// NOTE: Except for hwaccel formats, pointers not needed by the format
    /// MUST be set to NULL.
    pub data: [*mut u8; 8usize],
    /// For video, size in bytes of each picture line.
    /// For audio, size in bytes of each plane.
    ///
    /// For audio, only linesize[0] may be set. For planar audio, each channel
    /// plane must be the same size.
    ///
    /// For video the linesizes should be multiples of the CPUs alignment
    /// preference, this is 16 or 32 for modern desktop CPUs.
    /// Some code requires such alignment other code can be slower without
    /// correct alignment, for yet other it makes no difference.
    ///
    /// @note The linesize may be larger than the size of usable data -- there
    /// may be extra padding present for performance reasons.
    pub linesize: [lang_items::c_int; 8usize],
    /// pointers to the data planes/channels.
    ///
    /// For video, this should simply point to data[].
    ///
    /// For planar audio, each channel has a separate data pointer, and
    /// linesize[0] contains the size of each channel buffer.
    /// For packed audio, there is just one data pointer, and linesize[0]
    /// contains the total size of the buffer for all channels.
    ///
    /// Note: Both data and extended_data should always be set in a valid frame,
    /// but for planar audio with more channels that can fit in data,
    /// extended_data must be used in order to access all channels.
    pub extended_data: *mut *mut u8,
    /// @name Video dimensions
    /// Video frames only. The coded dimensions (in pixels) of the video frame,
    /// i.e. the size of the rectangle that contains some well-defined values.
    ///
    /// @note The part of the frame intended for display/presentation is further
    /// restricted by the @ref cropping "Cropping rectangle".
    /// @{
    pub width: lang_items::c_int,
    /// @name Video dimensions
    /// Video frames only. The coded dimensions (in pixels) of the video frame,
    /// i.e. the size of the rectangle that contains some well-defined values.
    ///
    /// @note The part of the frame intended for display/presentation is further
    /// restricted by the @ref cropping "Cropping rectangle".
    /// @{
    pub height: lang_items::c_int,
    /// number of audio samples (per channel) described by this frame
    pub nb_samples: lang_items::c_int,
    /// format of the frame, -1 if unknown or unset
    /// Values correspond to enum AVPixelFormat for video frames,
    /// enum AVSampleFormat for audio)
    pub format: lang_items::c_int,
    /// 1 -> keyframe, 0-> not
    pub key_frame: lang_items::c_int,
    /// Picture type of the frame.
    pub pict_type: AVPictureType,
    /// Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
    pub sample_aspect_ratio: AVRational,
    /// Presentation timestamp in time_base units (time when frame should be shown to user).
    pub pts: i64,
    /// PTS copied from the AVPacket that was decoded to produce this frame.
    /// @deprecated use the pts field instead
    pub pkt_pts: i64,
    /// DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
    /// This is also the Presentation time of this AVFrame calculated from
    /// only AVPacket.dts values without pts values.
    pub pkt_dts: i64,
    /// picture number in bitstream order
    pub coded_picture_number: lang_items::c_int,
    /// picture number in display order
    pub display_picture_number: lang_items::c_int,
    /// quality (between 1 (good) and FF_LAMBDA_MAX (bad))
    pub quality: lang_items::c_int,
    /// for some private data of the user
    pub opaque: *mut lang_items::c_void,
    /// @deprecated unused
    pub error: [u64; 8usize],
    /// When decoding, this signals how much the picture must be delayed.
    /// extra_delay = repeat_pict / (2*fps)
    pub repeat_pict: lang_items::c_int,
    /// The content of the picture is interlaced.
    pub interlaced_frame: lang_items::c_int,
    /// If the content is interlaced, is top field displayed first.
    pub top_field_first: lang_items::c_int,
    /// Tell user application that palette has changed from previous frame.
    pub palette_has_changed: lang_items::c_int,
    /// reordered opaque 64 bits (generally an integer or a double precision float
    /// PTS but can be anything).
    /// The user sets AVCodecContext.reordered_opaque to represent the input at
    /// that time,
    /// the decoder reorders values as needed and sets AVFrame.reordered_opaque
    /// to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
    /// @deprecated in favor of pkt_pts
    pub reordered_opaque: i64,
    /// Sample rate of the audio data.
    pub sample_rate: lang_items::c_int,
    /// Channel layout of the audio data.
    pub channel_layout: u64,
    /// AVBuffer references backing the data for this frame. If all elements of
    /// this array are NULL, then this frame is not reference counted. This array
    /// must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
    /// also be non-NULL for all j < i.
    ///
    /// There may be at most one AVBuffer per data plane, so for video this array
    /// always contains all the references. For planar audio with more than
    /// AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
    /// this array. Then the extra AVBufferRef pointers are stored in the
    /// extended_buf array.
    pub buf: [*mut AVBufferRef; 8usize],
    /// For planar audio which requires more than AV_NUM_DATA_POINTERS
    /// AVBufferRef pointers, this array will hold all the references which
    /// cannot fit into AVFrame.buf.
    ///
    /// Note that this is different from AVFrame.extended_data, which always
    /// contains all the pointers. This array only contains the extra pointers,
    /// which cannot fit into AVFrame.buf.
    ///
    /// This array is always allocated using av_malloc() by whoever constructs
    /// the frame. It is freed in av_frame_unref().
    pub extended_buf: *mut *mut AVBufferRef,
    /// Number of elements in extended_buf.
    pub nb_extended_buf: lang_items::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: lang_items::c_int,
    /// Frame flags, a combination of @ref lavu_frame_flags
    pub flags: lang_items::c_int,
    /// MPEG vs JPEG YUV range.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    /// YUV colorspace type.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /// frame timestamp estimated using various heuristics, in stream time base
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub best_effort_timestamp: i64,
    /// reordered pos from the last AVPacket that has been input into the decoder
    /// - encoding: unused
    /// - decoding: Read by user.
    pub pkt_pos: i64,
    /// duration of the corresponding packet, expressed in
    /// AVStream->time_base units, 0 if unknown.
    /// - encoding: unused
    /// - decoding: Read by user.
    pub pkt_duration: i64,
    /// metadata.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub metadata: *mut AVDictionary,
    /// decode error flags of the frame, set to a combination of
    /// FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
    /// were errors during the decoding.
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub decode_error_flags: lang_items::c_int,
    /// number of audio channels, only used for audio.
    /// - encoding: unused
    /// - decoding: Read by user.
    pub channels: lang_items::c_int,
    /// size of the corresponding packet containing the compressed
    /// frame.
    /// It is set to a negative value if unknown.
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub pkt_size: lang_items::c_int,
    /// QP table
    pub qscale_table: *mut i8,
    /// QP store stride
    pub qstride: lang_items::c_int,
    pub qscale_type: lang_items::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    /// For hwaccel-format frames, this should be a reference to the
    /// AVHWFramesContext describing the frame.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// AVBufferRef for free use by the API user. FFmpeg will never check the
    /// contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
    /// the frame is unreferenced. av_frame_copy_props() calls create a new
    /// reference with av_buffer_ref() for the target frame's opaque_ref field.
    ///
    /// This is unrelated to the opaque field, although it serves a similar
    /// purpose.
    pub opaque_ref: *mut AVBufferRef,
    /// @anchor cropping
    /// @name Cropping
    /// Video frames only. The number of pixels to discard from the the
    /// top/bottom/left/right border of the frame to obtain the sub-rectangle of
    /// the frame intended for presentation.
    /// @{
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    /// AVBufferRef for internal use by a single libav* library.
    /// Must not be used to transfer data between libraries.
    /// Has to be NULL when ownership of the frame leaves the respective library.
    ///
    /// Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
    ///
    /// FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
    /// av_frame_copy_props() calls create a new reference with av_buffer_ref()
    /// for the target frame's private_ref field.
    pub private_ref: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    assert_eq!(
        std::mem::size_of::<AVFrame>(),
        536usize,
        concat!("Size of: ", stringify!(AVFrame))
    );
    assert_eq!(
        std::mem::align_of::<AVFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrame))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).extended_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).width as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).height as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).nb_samples as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).format as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).key_frame as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pict_type as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).sample_aspect_ratio as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pts as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pkt_pts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pkt_dts as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).coded_picture_number as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(coded_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).display_picture_number as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(display_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).quality as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).opaque as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).error as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).repeat_pict as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).interlaced_frame as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(interlaced_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).top_field_first as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).palette_has_changed as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(palette_has_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).reordered_opaque as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).sample_rate as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).channel_layout as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).buf as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).extended_buf as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).nb_extended_buf as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).side_data as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).nb_side_data as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).flags as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).color_range as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).color_primaries as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).color_trc as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).colorspace as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).chroma_location as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).best_effort_timestamp as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(best_effort_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pkt_pos as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pkt_duration as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).metadata as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).decode_error_flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(decode_error_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).channels as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).pkt_size as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).qscale_table as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_table)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).qstride as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qstride)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).qscale_type as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).qp_table_buf as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qp_table_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).hw_frames_ctx as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).opaque_ref as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).crop_top as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).crop_bottom as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).crop_left as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).crop_right as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_right)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFrame>())).private_ref as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(private_ref)
        )
    );
}
extern "C" {
    /// Accessors for some AVFrame fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: lang_items::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: lang_items::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: lang_items::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: lang_items::c_int);
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut lang_items::c_int,
        type_: *mut lang_items::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: lang_items::c_int,
        type_: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    /// Get the name of a colorspace.
    /// @return a static string identifying the colorspace; can be NULL.
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const lang_items::c_char;
}
extern "C" {
    /// Allocate an AVFrame and set its fields to default values.  The resulting
    /// struct must be freed using av_frame_free().
    ///
    /// @return An AVFrame filled with default values or NULL on failure.
    ///
    /// @note this only allocates the AVFrame itself, not the data buffers. Those
    /// must be allocated through other means, e.g. with av_frame_get_buffer() or
    /// manually.
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    /// Free the frame and any dynamically allocated objects in it,
    /// e.g. extended_data. If the frame is reference counted, it will be
    /// unreferenced first.
    ///
    /// @param frame frame to be freed. The pointer will be set to NULL.
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    /// Set up a new reference to the data described by the source frame.
    ///
    /// Copy frame properties from src to dst and create a new reference for each
    /// AVBufferRef from src.
    ///
    /// If src is not reference counted, new buffers are allocated and the data is
    /// copied.
    ///
    /// @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
    /// or newly allocated with av_frame_alloc() before calling this
    /// function, or undefined behavior will occur.
    ///
    /// @return 0 on success, a negative AVERROR on error
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    /// Create a new frame that references the same data as src.
    ///
    /// This is a shortcut for av_frame_alloc()+av_frame_ref().
    ///
    /// @return newly created AVFrame on success, NULL on error.
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    /// Unreference all the buffers referenced by frame and reset the frame fields.
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    /// Move everything contained in src to dst and reset src.
    ///
    /// @warning: dst is not unreferenced, but directly overwritten without reading
    /// or deallocating its contents. Call av_frame_unref(dst) manually
    /// before calling this function to ensure that no memory is leaked.
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    /// Allocate new buffer(s) for audio or video data.
    ///
    /// The following fields must be set on frame before calling this function:
    /// - format (pixel format for video, sample format for audio)
    /// - width and height for video
    /// - nb_samples and channel_layout for audio
    ///
    /// This function will fill AVFrame.data and AVFrame.buf arrays and, if
    /// necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
    /// For planar formats, one buffer will be allocated for each plane.
    ///
    /// @warning: if frame already has been allocated, calling this function will
    /// leak memory. In addition, undefined behavior can occur in certain
    /// cases.
    ///
    /// @param frame frame in which to store the new buffers.
    /// @param align Required buffer size alignment. If equal to 0, alignment will be
    /// chosen automatically for the current CPU. It is highly
    /// recommended to pass 0 here unless you know what you are doing.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Check if the frame data is writable.
    ///
    /// @return A positive value if the frame data is writable (which is true if and
    /// only if each of the underlying buffers has only one reference, namely the one
    /// stored in this frame). Return 0 otherwise.
    ///
    /// If 1 is returned the answer is valid until av_buffer_ref() is called on any
    /// of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
    ///
    /// @see av_frame_make_writable(), av_buffer_is_writable()
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> lang_items::c_int;
}
extern "C" {
    /// Ensure that the frame data is writable, avoiding data copy if possible.
    ///
    /// Do nothing if the frame is writable, allocate new buffers and copy the data
    /// if it is not.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    ///
    /// @see av_frame_is_writable(), av_buffer_is_writable(),
    /// av_buffer_make_writable()
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> lang_items::c_int;
}
extern "C" {
    /// Copy the frame data from src to dst.
    ///
    /// This function does not allocate anything, dst must be already initialized and
    /// allocated with the same parameters as src.
    ///
    /// This function only copies the frame data (i.e. the contents of the data /
    /// extended data arrays), not any other properties.
    ///
    /// @return >= 0 on success, a negative AVERROR on error.
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    /// Copy only "metadata" fields from src to dst.
    ///
    /// Metadata for the purpose of this function are those fields that do not affect
    /// the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
    /// aspect ratio (for video), but not width/height or channel layout.
    /// Side data is also copied.
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> lang_items::c_int;
}
extern "C" {
    /// Get the buffer reference a given data plane is stored in.
    ///
    /// @param plane index of the data plane of interest in frame->extended_data.
    ///
    /// @return the buffer reference that contains the plane or NULL if the input
    /// frame is not valid.
    pub fn av_frame_get_plane_buffer(
        frame: *mut AVFrame,
        plane: lang_items::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    /// Add a new side data to a frame.
    ///
    /// @param frame a frame to which the side data should be added
    /// @param type type of the added side data
    /// @param size size of the side data
    ///
    /// @return newly added side data on success, NULL on error
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: lang_items::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    /// Add a new side data to a frame from an existing AVBufferRef
    ///
    /// @param frame a frame to which the side data should be added
    /// @param type  the type of the added side data
    /// @param buf   an AVBufferRef to add as side data. The ownership of
    /// the reference is transferred to the frame.
    ///
    /// @return newly added side data on success, NULL on error. On failure
    /// the frame is unchanged and the AVBufferRef remains owned by
    /// the caller.
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    /// @return a pointer to the side data of a given type on success, NULL if there
    /// is no side data with such type in this frame.
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    /// If side data of the supplied type exists in the frame, free it and remove it
    /// from the frame.
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
/// Apply the maximum possible cropping, even if it requires setting the
/// AVFrame.data[] entries to unaligned pointers. Passing unaligned data
/// to FFmpeg API is generally not allowed, and causes undefined behavior
/// (such as crashes). You can pass unaligned data only to FFmpeg APIs that
/// are explicitly documented to accept it. Use this flag only if you
/// absolutely know what you are doing.
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_2 = 1;
/// Flags for frame cropping.
pub type _bindgen_ty_2 = u32;
extern "C" {
    /// Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
    /// crop_bottom fields. If cropping is successful, the function will adjust the
    /// data pointers and the width/height fields, and set the crop fields to 0.
    ///
    /// In all cases, the cropping boundaries will be rounded to the inherent
    /// alignment of the pixel format. In some cases, such as for opaque hwaccel
    /// formats, the left/top cropping is ignored. The crop fields are set to 0 even
    /// if the cropping was rounded or ignored.
    ///
    /// @param frame the frame which should be cropped
    /// @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
    ///
    /// @return >= 0 on success, a negative AVERROR on error. If the cropping fields
    /// were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @return a string identifying the side data type
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const lang_items::c_char;
}
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_NONE: AVHWDeviceType = 0;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VDPAU: AVHWDeviceType = 1;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_CUDA: AVHWDeviceType = 2;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VAAPI: AVHWDeviceType = 3;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DXVA2: AVHWDeviceType = 4;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_QSV: AVHWDeviceType = 5;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VIDEOTOOLBOX: AVHWDeviceType = 6;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_D3D11VA: AVHWDeviceType = 7;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DRM: AVHWDeviceType = 8;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_OPENCL: AVHWDeviceType = 9;
pub const AVHWDeviceType_AV_HWDEVICE_TYPE_MEDIACODEC: AVHWDeviceType = 10;
pub type AVHWDeviceType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
/// This struct aggregates all the (hardware/vendor-specific) "high-level" state,
/// i.e. state that is not tied to a concrete processing configuration.
/// E.g., in an API that supports hardware-accelerated encoding and decoding,
/// this struct will (if possible) wrap the state that is common to both encoding
/// and decoding and from which specific instances of encoders or decoders can be
/// derived.
///
/// This struct is reference-counted with the AVBuffer mechanism. The
/// av_hwdevice_ctx_alloc() constructor yields a reference, whose data field
/// points to the actual AVHWDeviceContext. Further objects derived from
/// AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with
/// specific properties) will hold an internal reference to it. After all the
/// references are released, the AVHWDeviceContext itself will be freed,
/// optionally invoking a user-specified callback for uninitializing the hardware
/// state.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceContext {
    /// A class for logging. Set by av_hwdevice_ctx_alloc().
    pub av_class: *const AVClass,
    /// Private data used internally by libavutil. Must not be accessed in any
    /// way by the caller.
    pub internal: *mut AVHWDeviceInternal,
    /// This field identifies the underlying API used for hardware access.
    ///
    /// This field is set when this struct is allocated and never changed
    /// afterwards.
    pub type_: AVHWDeviceType,
    /// The format-specific data, allocated and freed by libavutil along with
    /// this context.
    ///
    /// Should be cast by the user to the format-specific context defined in the
    /// corresponding header (hwcontext_*.h) and filled as described in the
    /// documentation before calling av_hwdevice_ctx_init().
    ///
    /// After calling av_hwdevice_ctx_init() this struct should not be modified
    /// by the caller.
    pub hwctx: *mut lang_items::c_void,
    /// This field may be set by the caller before calling av_hwdevice_ctx_init().
    ///
    /// If non-NULL, this callback will be called when the last reference to
    /// this context is unreferenced, immediately before it is freed.
    ///
    /// @note when other objects (e.g an AVHWFramesContext) are derived from this
    /// struct, this callback will be invoked after all such child objects
    /// are fully uninitialized and their respective destructors invoked.
    pub free: std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    /// Arbitrary user data, to be used e.g. by the free() callback.
    pub user_opaque: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_AVHWDeviceContext() {
    assert_eq!(
        std::mem::size_of::<AVHWDeviceContext>(),
        48usize,
        concat!("Size of: ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        std::mem::align_of::<AVHWDeviceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).hwctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWDeviceContext>())).user_opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(user_opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
/// This struct describes a set or pool of "hardware" frames (i.e. those with
/// data not located in normal system memory). All the frames in the pool are
/// assumed to be allocated in the same way and interchangeable.
///
/// This struct is reference-counted with the AVBuffer mechanism and tied to a
/// given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor
/// yields a reference, whose data field points to the actual AVHWFramesContext
/// struct.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesContext {
    /// A class for logging.
    pub av_class: *const AVClass,
    /// Private data used internally by libavutil. Must not be accessed in any
    /// way by the caller.
    pub internal: *mut AVHWFramesInternal,
    /// A reference to the parent AVHWDeviceContext. This reference is owned and
    /// managed by the enclosing AVHWFramesContext, but the caller may derive
    /// additional references from it.
    pub device_ref: *mut AVBufferRef,
    /// The parent AVHWDeviceContext. This is simply a pointer to
    /// device_ref->data provided for convenience.
    ///
    /// Set by libavutil in av_hwframe_ctx_init().
    pub device_ctx: *mut AVHWDeviceContext,
    /// The format-specific data, allocated and freed automatically along with
    /// this context.
    ///
    /// Should be cast by the user to the format-specific context defined in the
    /// corresponding header (hwframe_*.h) and filled as described in the
    /// documentation before calling av_hwframe_ctx_init().
    ///
    /// After any frames using this context are created, the contents of this
    /// struct should not be modified by the caller.
    pub hwctx: *mut lang_items::c_void,
    /// This field may be set by the caller before calling av_hwframe_ctx_init().
    ///
    /// If non-NULL, this callback will be called when the last reference to
    /// this context is unreferenced, immediately before it is freed.
    pub free: std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    /// Arbitrary user data, to be used e.g. by the free() callback.
    pub user_opaque: *mut lang_items::c_void,
    /// A pool from which the frames are allocated by av_hwframe_get_buffer().
    /// This field may be set by the caller before calling av_hwframe_ctx_init().
    /// The buffers returned by calling av_buffer_pool_get() on this pool must
    /// have the properties described in the documentation in the corresponding hw
    /// type's header (hwcontext_*.h). The pool will be freed strictly before
    /// this struct's free() callback is invoked.
    ///
    /// This field may be NULL, then libavutil will attempt to allocate a pool
    /// internally. Note that certain device types enforce pools allocated at
    /// fixed size (frame count), which cannot be extended dynamically. In such a
    /// case, initial_pool_size must be set appropriately.
    pub pool: *mut AVBufferPool,
    /// Initial size of the frame pool. If a device type does not support
    /// dynamically resizing the pool, then this is also the maximum pool size.
    ///
    /// May be set by the caller before calling av_hwframe_ctx_init(). Must be
    /// set if pool is NULL and the device type does not support dynamic pools.
    pub initial_pool_size: lang_items::c_int,
    /// The pixel format identifying the underlying HW surface type.
    ///
    /// Must be a hwaccel format, i.e. the corresponding descriptor must have the
    /// AV_PIX_FMT_FLAG_HWACCEL flag set.
    ///
    /// Must be set by the user before calling av_hwframe_ctx_init().
    pub format: AVPixelFormat,
    /// The pixel format identifying the actual data layout of the hardware
    /// frames.
    ///
    /// Must be set by the caller before calling av_hwframe_ctx_init().
    ///
    /// @note when the underlying API does not provide the exact data layout, but
    /// only the colorspace/bit depth, this field should be set to the fully
    /// planar version of that format (e.g. for 8-bit 420 YUV it should be
    /// AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else).
    pub sw_format: AVPixelFormat,
    /// The allocated dimensions of the frames in this pool.
    ///
    /// Must be set by the user before calling av_hwframe_ctx_init().
    pub width: lang_items::c_int,
    /// The allocated dimensions of the frames in this pool.
    ///
    /// Must be set by the user before calling av_hwframe_ctx_init().
    pub height: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesContext() {
    assert_eq!(
        std::mem::size_of::<AVHWFramesContext>(),
        88usize,
        concat!("Size of: ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        std::mem::align_of::<AVHWFramesContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).device_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).device_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).hwctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).user_opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(user_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).pool as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesContext>())).initial_pool_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(initial_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).sw_format as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(sw_format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).width as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWFramesContext>())).height as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    /// Look up an AVHWDeviceType by name.
    ///
    /// @param name String name of the device type (case-insensitive).
    /// @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if
    /// not found.
    pub fn av_hwdevice_find_type_by_name(name: *const lang_items::c_char) -> AVHWDeviceType;
}
extern "C" {
    /// Get the string name of an AVHWDeviceType.
    ///
    /// @param type Type from enum AVHWDeviceType.
    /// @return Pointer to a static string containing the name, or NULL if the type
    /// is not valid.
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const lang_items::c_char;
}
extern "C" {
    /// Iterate over supported device types.
    ///
    /// @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type
    /// returned by this function in subsequent iterations.
    /// @return The next usable device type from enum AVHWDeviceType, or
    /// AV_HWDEVICE_TYPE_NONE if there are no more.
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    /// Allocate an AVHWDeviceContext for a given hardware type.
    ///
    /// @param type the type of the hardware device to allocate.
    /// @return a reference to the newly created AVHWDeviceContext on success or NULL
    /// on failure.
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    /// Finalize the device context before use. This function must be called after
    /// the context is filled with all the required information and before it is
    /// used in any way.
    ///
    /// @param ref a reference to the AVHWDeviceContext
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> lang_items::c_int;
}
extern "C" {
    /// Open a device of the specified type and create an AVHWDeviceContext for it.
    ///
    /// This is a convenience function intended to cover the simple cases. Callers
    /// who need to fine-tune device creation/management should open the device
    /// manually and then wrap it in an AVHWDeviceContext using
    /// av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
    ///
    /// The returned context is already initialized and ready for use, the caller
    /// should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of
    /// the created AVHWDeviceContext are set by this function and should not be
    /// touched by the caller.
    ///
    /// @param device_ctx On success, a reference to the newly-created device context
    /// will be written here. The reference is owned by the caller
    /// and must be released with av_buffer_unref() when no longer
    /// needed. On failure, NULL will be written to this pointer.
    /// @param type The type of the device to create.
    /// @param device A type-specific string identifying the device to open.
    /// @param opts A dictionary of additional (type-specific) options to use in
    /// opening the device. The dictionary remains owned by the caller.
    /// @param flags currently unused
    ///
    /// @return 0 on success, a negative AVERROR code on failure.
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const lang_items::c_char,
        opts: *mut AVDictionary,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Create a new device of the specified type from an existing device.
    ///
    /// If the source device is a device of the target type or was originally
    /// derived from such a device (possibly through one or more intermediate
    /// devices of other types), then this will return a reference to the
    /// existing device of the same type as is requested.
    ///
    /// Otherwise, it will attempt to derive a new device from the given source
    /// device.  If direct derivation to the new type is not implemented, it will
    /// attempt the same derivation from each ancestor of the source device in
    /// turn looking for an implemented derivation method.
    ///
    /// @param dst_ctx On success, a reference to the newly-created
    /// AVHWDeviceContext.
    /// @param type    The type of the new device to create.
    /// @param src_ctx A reference to an existing AVHWDeviceContext which will be
    /// used to create the new device.
    /// @param flags   Currently unused; should be set to zero.
    /// @return        Zero on success, a negative AVERROR code on failure.
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate an AVHWFramesContext tied to a given device context.
    ///
    /// @param device_ctx a reference to a AVHWDeviceContext. This function will make
    /// a new reference for internal use, the one passed to the
    /// function remains owned by the caller.
    /// @return a reference to the newly created AVHWFramesContext on success or NULL
    /// on failure.
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    /// Finalize the context before use. This function must be called after the
    /// context is filled with all the required information and before it is attached
    /// to any frames.
    ///
    /// @param ref a reference to the AVHWFramesContext
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> lang_items::c_int;
}
extern "C" {
    /// Allocate a new frame attached to the given AVHWFramesContext.
    ///
    /// @param hwframe_ctx a reference to an AVHWFramesContext
    /// @param frame an empty (freshly allocated or unreffed) frame to be filled with
    /// newly allocated buffers.
    /// @param flags currently unused, should be set to zero
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Copy data to or from a hw surface. At least one of dst/src must have an
    /// AVHWFramesContext attached.
    ///
    /// If src has an AVHWFramesContext attached, then the format of dst (if set)
    /// must use one of the formats returned by av_hwframe_transfer_get_formats(src,
    /// AV_HWFRAME_TRANSFER_DIRECTION_FROM).
    /// If dst has an AVHWFramesContext attached, then the format of src must use one
    /// of the formats returned by av_hwframe_transfer_get_formats(dst,
    /// AV_HWFRAME_TRANSFER_DIRECTION_TO)
    ///
    /// dst may be "clean" (i.e. with data/buf pointers unset), in which case the
    /// data buffers will be allocated by this function using av_frame_get_buffer().
    /// If dst->format is set, then this format will be used, otherwise (when
    /// dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.
    ///
    /// The two frames must have matching allocated dimensions (i.e. equal to
    /// AVHWFramesContext.width/height), since not all device types support
    /// transferring a sub-rectangle of the whole surface. The display dimensions
    /// (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but
    /// also have to be equal for both frames. When the display dimensions are
    /// smaller than the allocated dimensions, the content of the padding in the
    /// destination frame is unspecified.
    ///
    /// @param dst the destination frame. dst is not touched on failure.
    /// @param src the source frame.
    /// @param flags currently unused, should be set to zero
    /// @return 0 on success, a negative AVERROR error code on failure.
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
/// Transfer the data from the queried hw frame.
pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_FROM:
    AVHWFrameTransferDirection = 0;
/// Transfer the data to the queried hw frame.
pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_TO: AVHWFrameTransferDirection =
    1;
pub type AVHWFrameTransferDirection = u32;
extern "C" {
    /// Get a list of possible source or target formats usable in
    /// av_hwframe_transfer_data().
    ///
    /// @param hwframe_ctx the frame context to obtain the information for
    /// @param dir the direction of the transfer
    /// @param formats the pointer to the output format list will be written here.
    /// The list is terminated with AV_PIX_FMT_NONE and must be freed
    /// by the caller when no longer needed using av_free().
    /// If this function returns successfully, the format list will
    /// have at least one item (not counting the terminator).
    /// On failure, the contents of this pointer are unspecified.
    /// @param flags currently unused, should be set to zero
    /// @return 0 on success, a negative AVERROR code on failure.
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
/// This struct describes the constraints on hardware frames attached to
/// a given device with a hardware-specific configuration.  This is returned
/// by av_hwdevice_get_hwframe_constraints() and must be freed by
/// av_hwframe_constraints_free() after use.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesConstraints {
    /// A list of possible values for format in the hw_frames_ctx,
    /// terminated by AV_PIX_FMT_NONE.  This member will always be filled.
    pub valid_hw_formats: *mut AVPixelFormat,
    /// A list of possible values for sw_format in the hw_frames_ctx,
    /// terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is
    /// not known.
    pub valid_sw_formats: *mut AVPixelFormat,
    /// The minimum size of frames in this hw_frames_ctx.
    /// (Zero if not known.)
    pub min_width: lang_items::c_int,
    pub min_height: lang_items::c_int,
    /// The maximum size of frames in this hw_frames_ctx.
    /// (INT_MAX if not known / no limit.)
    pub max_width: lang_items::c_int,
    pub max_height: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesConstraints() {
    assert_eq!(
        std::mem::size_of::<AVHWFramesConstraints>(),
        32usize,
        concat!("Size of: ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        std::mem::align_of::<AVHWFramesConstraints>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).valid_hw_formats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_hw_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).valid_sw_formats as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_sw_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).min_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).min_height as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).max_width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVHWFramesConstraints>())).max_height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_height)
        )
    );
}
extern "C" {
    /// Allocate a HW-specific configuration structure for a given HW device.
    /// After use, the user must free all members as required by the specific
    /// hardware structure being used, then free the structure itself with
    /// av_free().
    ///
    /// @param device_ctx a reference to the associated AVHWDeviceContext.
    /// @return The newly created HW-specific configuration structure on
    /// success or NULL on failure.
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut lang_items::c_void;
}
extern "C" {
    /// Get the constraints on HW frames given a device and the HW-specific
    /// configuration to be used with that device.  If no HW-specific
    /// configuration is provided, returns the maximum possible capabilities
    /// of the device.
    ///
    /// @param ref a reference to the associated AVHWDeviceContext.
    /// @param hwconfig a filled HW-specific configuration structure, or NULL
    /// to return the maximum possible capabilities of the device.
    /// @return AVHWFramesConstraints structure describing the constraints
    /// on the device, or NULL if not available.
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const lang_items::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    /// Free an AVHWFrameConstraints structure.
    ///
    /// @param constraints The (filled or unfilled) AVHWFrameConstraints structure.
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
/// The mapping must be readable.
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_3 = 1;
/// The mapping must be writeable.
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_3 = 2;
/// The mapped frame will be overwritten completely in subsequent
/// operations, so the current frame data need not be loaded.  Any values
/// which are not overwritten are unspecified.
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_3 = 4;
/// The mapping must be direct.  That is, there must not be any copying in
/// the map or unmap steps.  Note that performance of direct mappings may
/// be much lower than normal memory.
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_3 = 8;
/// Flags to apply to frame mappings.
pub type _bindgen_ty_3 = u32;
extern "C" {
    /// Map a hardware frame.
    ///
    /// This has a number of different possible effects, depending on the format
    /// and origin of the src and dst frames.  On input, src should be a usable
    /// frame with valid buffers and dst should be blank (typically as just created
    /// by av_frame_alloc()).  src should have an associated hwframe context, and
    /// dst may optionally have a format and associated hwframe context.
    ///
    /// If src was created by mapping a frame from the hwframe context of dst,
    /// then this function undoes the mapping - dst is replaced by a reference to
    /// the frame that src was originally mapped from.
    ///
    /// If both src and dst have an associated hwframe context, then this function
    /// attempts to map the src frame from its hardware context to that of dst and
    /// then fill dst with appropriate data to be usable there.  This will only be
    /// possible if the hwframe contexts and associated devices are compatible -
    /// given compatible devices, av_hwframe_ctx_create_derived() can be used to
    /// create a hwframe context for dst in which mapping should be possible.
    ///
    /// If src has a hwframe context but dst does not, then the src frame is
    /// mapped to normal memory and should thereafter be usable as a normal frame.
    /// If the format is set on dst, then the mapping will attempt to create dst
    /// with that format and fail if it is not possible.  If format is unset (is
    /// AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate
    /// format to use is (probably the sw_format of the src hwframe context).
    ///
    /// A return value of AVERROR(ENOSYS) indicates that the mapping is not
    /// possible with the given arguments and hwframe setup, while other return
    /// values indicate that it failed somehow.
    ///
    /// @param dst Destination frame, to contain the mapping.
    /// @param src Source frame, to be mapped.
    /// @param flags Some combination of AV_HWFRAME_MAP_* flags.
    /// @return Zero on success, negative AVERROR code on failure.
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Create and initialise an AVHWFramesContext as a mapping of another existing
    /// AVHWFramesContext on a different device.
    ///
    /// av_hwframe_ctx_init() should not be called after this.
    ///
    /// @param derived_frame_ctx  On success, a reference to the newly created
    /// AVHWFramesContext.
    /// @param derived_device_ctx A reference to the device to create the new
    /// AVHWFramesContext on.
    /// @param source_frame_ctx   A reference to an existing AVHWFramesContext
    /// which will be mapped to the derived context.
    /// @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the
    /// mapping parameters to apply to frames which are allocated
    /// in the derived device.
    /// @return       Zero on success, negative AVERROR code on failure.
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
pub const AVCodecID_AV_CODEC_ID_NONE: AVCodecID = 0;
pub const AVCodecID_AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
/// < preferred ID for MPEG-1/2 video decoding
pub const AVCodecID_AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
pub const AVCodecID_AV_CODEC_ID_H261: AVCodecID = 3;
pub const AVCodecID_AV_CODEC_ID_H263: AVCodecID = 4;
pub const AVCodecID_AV_CODEC_ID_RV10: AVCodecID = 5;
pub const AVCodecID_AV_CODEC_ID_RV20: AVCodecID = 6;
pub const AVCodecID_AV_CODEC_ID_MJPEG: AVCodecID = 7;
pub const AVCodecID_AV_CODEC_ID_MJPEGB: AVCodecID = 8;
pub const AVCodecID_AV_CODEC_ID_LJPEG: AVCodecID = 9;
pub const AVCodecID_AV_CODEC_ID_SP5X: AVCodecID = 10;
pub const AVCodecID_AV_CODEC_ID_JPEGLS: AVCodecID = 11;
pub const AVCodecID_AV_CODEC_ID_MPEG4: AVCodecID = 12;
pub const AVCodecID_AV_CODEC_ID_RAWVIDEO: AVCodecID = 13;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V1: AVCodecID = 14;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V2: AVCodecID = 15;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V3: AVCodecID = 16;
pub const AVCodecID_AV_CODEC_ID_WMV1: AVCodecID = 17;
pub const AVCodecID_AV_CODEC_ID_WMV2: AVCodecID = 18;
pub const AVCodecID_AV_CODEC_ID_H263P: AVCodecID = 19;
pub const AVCodecID_AV_CODEC_ID_H263I: AVCodecID = 20;
pub const AVCodecID_AV_CODEC_ID_FLV1: AVCodecID = 21;
pub const AVCodecID_AV_CODEC_ID_SVQ1: AVCodecID = 22;
pub const AVCodecID_AV_CODEC_ID_SVQ3: AVCodecID = 23;
pub const AVCodecID_AV_CODEC_ID_DVVIDEO: AVCodecID = 24;
pub const AVCodecID_AV_CODEC_ID_HUFFYUV: AVCodecID = 25;
pub const AVCodecID_AV_CODEC_ID_CYUV: AVCodecID = 26;
pub const AVCodecID_AV_CODEC_ID_H264: AVCodecID = 27;
pub const AVCodecID_AV_CODEC_ID_INDEO3: AVCodecID = 28;
pub const AVCodecID_AV_CODEC_ID_VP3: AVCodecID = 29;
pub const AVCodecID_AV_CODEC_ID_THEORA: AVCodecID = 30;
pub const AVCodecID_AV_CODEC_ID_ASV1: AVCodecID = 31;
pub const AVCodecID_AV_CODEC_ID_ASV2: AVCodecID = 32;
pub const AVCodecID_AV_CODEC_ID_FFV1: AVCodecID = 33;
pub const AVCodecID_AV_CODEC_ID_4XM: AVCodecID = 34;
pub const AVCodecID_AV_CODEC_ID_VCR1: AVCodecID = 35;
pub const AVCodecID_AV_CODEC_ID_CLJR: AVCodecID = 36;
pub const AVCodecID_AV_CODEC_ID_MDEC: AVCodecID = 37;
pub const AVCodecID_AV_CODEC_ID_ROQ: AVCodecID = 38;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 39;
pub const AVCodecID_AV_CODEC_ID_XAN_WC3: AVCodecID = 40;
pub const AVCodecID_AV_CODEC_ID_XAN_WC4: AVCodecID = 41;
pub const AVCodecID_AV_CODEC_ID_RPZA: AVCodecID = 42;
pub const AVCodecID_AV_CODEC_ID_CINEPAK: AVCodecID = 43;
pub const AVCodecID_AV_CODEC_ID_WS_VQA: AVCodecID = 44;
pub const AVCodecID_AV_CODEC_ID_MSRLE: AVCodecID = 45;
pub const AVCodecID_AV_CODEC_ID_MSVIDEO1: AVCodecID = 46;
pub const AVCodecID_AV_CODEC_ID_IDCIN: AVCodecID = 47;
pub const AVCodecID_AV_CODEC_ID_8BPS: AVCodecID = 48;
pub const AVCodecID_AV_CODEC_ID_SMC: AVCodecID = 49;
pub const AVCodecID_AV_CODEC_ID_FLIC: AVCodecID = 50;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION1: AVCodecID = 51;
pub const AVCodecID_AV_CODEC_ID_VMDVIDEO: AVCodecID = 52;
pub const AVCodecID_AV_CODEC_ID_MSZH: AVCodecID = 53;
pub const AVCodecID_AV_CODEC_ID_ZLIB: AVCodecID = 54;
pub const AVCodecID_AV_CODEC_ID_QTRLE: AVCodecID = 55;
pub const AVCodecID_AV_CODEC_ID_TSCC: AVCodecID = 56;
pub const AVCodecID_AV_CODEC_ID_ULTI: AVCodecID = 57;
pub const AVCodecID_AV_CODEC_ID_QDRAW: AVCodecID = 58;
pub const AVCodecID_AV_CODEC_ID_VIXL: AVCodecID = 59;
pub const AVCodecID_AV_CODEC_ID_QPEG: AVCodecID = 60;
pub const AVCodecID_AV_CODEC_ID_PNG: AVCodecID = 61;
pub const AVCodecID_AV_CODEC_ID_PPM: AVCodecID = 62;
pub const AVCodecID_AV_CODEC_ID_PBM: AVCodecID = 63;
pub const AVCodecID_AV_CODEC_ID_PGM: AVCodecID = 64;
pub const AVCodecID_AV_CODEC_ID_PGMYUV: AVCodecID = 65;
pub const AVCodecID_AV_CODEC_ID_PAM: AVCodecID = 66;
pub const AVCodecID_AV_CODEC_ID_FFVHUFF: AVCodecID = 67;
pub const AVCodecID_AV_CODEC_ID_RV30: AVCodecID = 68;
pub const AVCodecID_AV_CODEC_ID_RV40: AVCodecID = 69;
pub const AVCodecID_AV_CODEC_ID_VC1: AVCodecID = 70;
pub const AVCodecID_AV_CODEC_ID_WMV3: AVCodecID = 71;
pub const AVCodecID_AV_CODEC_ID_LOCO: AVCodecID = 72;
pub const AVCodecID_AV_CODEC_ID_WNV1: AVCodecID = 73;
pub const AVCodecID_AV_CODEC_ID_AASC: AVCodecID = 74;
pub const AVCodecID_AV_CODEC_ID_INDEO2: AVCodecID = 75;
pub const AVCodecID_AV_CODEC_ID_FRAPS: AVCodecID = 76;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2: AVCodecID = 77;
pub const AVCodecID_AV_CODEC_ID_BMP: AVCodecID = 78;
pub const AVCodecID_AV_CODEC_ID_CSCD: AVCodecID = 79;
pub const AVCodecID_AV_CODEC_ID_MMVIDEO: AVCodecID = 80;
pub const AVCodecID_AV_CODEC_ID_ZMBV: AVCodecID = 81;
pub const AVCodecID_AV_CODEC_ID_AVS: AVCodecID = 82;
pub const AVCodecID_AV_CODEC_ID_SMACKVIDEO: AVCodecID = 83;
pub const AVCodecID_AV_CODEC_ID_NUV: AVCodecID = 84;
pub const AVCodecID_AV_CODEC_ID_KMVC: AVCodecID = 85;
pub const AVCodecID_AV_CODEC_ID_FLASHSV: AVCodecID = 86;
pub const AVCodecID_AV_CODEC_ID_CAVS: AVCodecID = 87;
pub const AVCodecID_AV_CODEC_ID_JPEG2000: AVCodecID = 88;
pub const AVCodecID_AV_CODEC_ID_VMNC: AVCodecID = 89;
pub const AVCodecID_AV_CODEC_ID_VP5: AVCodecID = 90;
pub const AVCodecID_AV_CODEC_ID_VP6: AVCodecID = 91;
pub const AVCodecID_AV_CODEC_ID_VP6F: AVCodecID = 92;
pub const AVCodecID_AV_CODEC_ID_TARGA: AVCodecID = 93;
pub const AVCodecID_AV_CODEC_ID_DSICINVIDEO: AVCodecID = 94;
pub const AVCodecID_AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 95;
pub const AVCodecID_AV_CODEC_ID_TIFF: AVCodecID = 96;
pub const AVCodecID_AV_CODEC_ID_GIF: AVCodecID = 97;
pub const AVCodecID_AV_CODEC_ID_DXA: AVCodecID = 98;
pub const AVCodecID_AV_CODEC_ID_DNXHD: AVCodecID = 99;
pub const AVCodecID_AV_CODEC_ID_THP: AVCodecID = 100;
pub const AVCodecID_AV_CODEC_ID_SGI: AVCodecID = 101;
pub const AVCodecID_AV_CODEC_ID_C93: AVCodecID = 102;
pub const AVCodecID_AV_CODEC_ID_BETHSOFTVID: AVCodecID = 103;
pub const AVCodecID_AV_CODEC_ID_PTX: AVCodecID = 104;
pub const AVCodecID_AV_CODEC_ID_TXD: AVCodecID = 105;
pub const AVCodecID_AV_CODEC_ID_VP6A: AVCodecID = 106;
pub const AVCodecID_AV_CODEC_ID_AMV: AVCodecID = 107;
pub const AVCodecID_AV_CODEC_ID_VB: AVCodecID = 108;
pub const AVCodecID_AV_CODEC_ID_PCX: AVCodecID = 109;
pub const AVCodecID_AV_CODEC_ID_SUNRAST: AVCodecID = 110;
pub const AVCodecID_AV_CODEC_ID_INDEO4: AVCodecID = 111;
pub const AVCodecID_AV_CODEC_ID_INDEO5: AVCodecID = 112;
pub const AVCodecID_AV_CODEC_ID_MIMIC: AVCodecID = 113;
pub const AVCodecID_AV_CODEC_ID_RL2: AVCodecID = 114;
pub const AVCodecID_AV_CODEC_ID_ESCAPE124: AVCodecID = 115;
pub const AVCodecID_AV_CODEC_ID_DIRAC: AVCodecID = 116;
pub const AVCodecID_AV_CODEC_ID_BFI: AVCodecID = 117;
pub const AVCodecID_AV_CODEC_ID_CMV: AVCodecID = 118;
pub const AVCodecID_AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 119;
pub const AVCodecID_AV_CODEC_ID_TGV: AVCodecID = 120;
pub const AVCodecID_AV_CODEC_ID_TGQ: AVCodecID = 121;
pub const AVCodecID_AV_CODEC_ID_TQI: AVCodecID = 122;
pub const AVCodecID_AV_CODEC_ID_AURA: AVCodecID = 123;
pub const AVCodecID_AV_CODEC_ID_AURA2: AVCodecID = 124;
pub const AVCodecID_AV_CODEC_ID_V210X: AVCodecID = 125;
pub const AVCodecID_AV_CODEC_ID_TMV: AVCodecID = 126;
pub const AVCodecID_AV_CODEC_ID_V210: AVCodecID = 127;
pub const AVCodecID_AV_CODEC_ID_DPX: AVCodecID = 128;
pub const AVCodecID_AV_CODEC_ID_MAD: AVCodecID = 129;
pub const AVCodecID_AV_CODEC_ID_FRWU: AVCodecID = 130;
pub const AVCodecID_AV_CODEC_ID_FLASHSV2: AVCodecID = 131;
pub const AVCodecID_AV_CODEC_ID_CDGRAPHICS: AVCodecID = 132;
pub const AVCodecID_AV_CODEC_ID_R210: AVCodecID = 133;
pub const AVCodecID_AV_CODEC_ID_ANM: AVCodecID = 134;
pub const AVCodecID_AV_CODEC_ID_BINKVIDEO: AVCodecID = 135;
pub const AVCodecID_AV_CODEC_ID_IFF_ILBM: AVCodecID = 136;
pub const AVCodecID_AV_CODEC_ID_KGV1: AVCodecID = 137;
pub const AVCodecID_AV_CODEC_ID_YOP: AVCodecID = 138;
pub const AVCodecID_AV_CODEC_ID_VP8: AVCodecID = 139;
pub const AVCodecID_AV_CODEC_ID_PICTOR: AVCodecID = 140;
pub const AVCodecID_AV_CODEC_ID_ANSI: AVCodecID = 141;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI: AVCodecID = 142;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI5: AVCodecID = 143;
pub const AVCodecID_AV_CODEC_ID_R10K: AVCodecID = 144;
pub const AVCodecID_AV_CODEC_ID_MXPEG: AVCodecID = 145;
pub const AVCodecID_AV_CODEC_ID_LAGARITH: AVCodecID = 146;
pub const AVCodecID_AV_CODEC_ID_PRORES: AVCodecID = 147;
pub const AVCodecID_AV_CODEC_ID_JV: AVCodecID = 148;
pub const AVCodecID_AV_CODEC_ID_DFA: AVCodecID = 149;
pub const AVCodecID_AV_CODEC_ID_WMV3IMAGE: AVCodecID = 150;
pub const AVCodecID_AV_CODEC_ID_VC1IMAGE: AVCodecID = 151;
pub const AVCodecID_AV_CODEC_ID_UTVIDEO: AVCodecID = 152;
pub const AVCodecID_AV_CODEC_ID_BMV_VIDEO: AVCodecID = 153;
pub const AVCodecID_AV_CODEC_ID_VBLE: AVCodecID = 154;
pub const AVCodecID_AV_CODEC_ID_DXTORY: AVCodecID = 155;
pub const AVCodecID_AV_CODEC_ID_V410: AVCodecID = 156;
pub const AVCodecID_AV_CODEC_ID_XWD: AVCodecID = 157;
pub const AVCodecID_AV_CODEC_ID_CDXL: AVCodecID = 158;
pub const AVCodecID_AV_CODEC_ID_XBM: AVCodecID = 159;
pub const AVCodecID_AV_CODEC_ID_ZEROCODEC: AVCodecID = 160;
pub const AVCodecID_AV_CODEC_ID_MSS1: AVCodecID = 161;
pub const AVCodecID_AV_CODEC_ID_MSA1: AVCodecID = 162;
pub const AVCodecID_AV_CODEC_ID_TSCC2: AVCodecID = 163;
pub const AVCodecID_AV_CODEC_ID_MTS2: AVCodecID = 164;
pub const AVCodecID_AV_CODEC_ID_CLLC: AVCodecID = 165;
pub const AVCodecID_AV_CODEC_ID_MSS2: AVCodecID = 166;
pub const AVCodecID_AV_CODEC_ID_VP9: AVCodecID = 167;
pub const AVCodecID_AV_CODEC_ID_AIC: AVCodecID = 168;
pub const AVCodecID_AV_CODEC_ID_ESCAPE130: AVCodecID = 169;
pub const AVCodecID_AV_CODEC_ID_G2M: AVCodecID = 170;
pub const AVCodecID_AV_CODEC_ID_WEBP: AVCodecID = 171;
pub const AVCodecID_AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 172;
pub const AVCodecID_AV_CODEC_ID_HEVC: AVCodecID = 173;
pub const AVCodecID_AV_CODEC_ID_FIC: AVCodecID = 174;
pub const AVCodecID_AV_CODEC_ID_ALIAS_PIX: AVCodecID = 175;
pub const AVCodecID_AV_CODEC_ID_BRENDER_PIX: AVCodecID = 176;
pub const AVCodecID_AV_CODEC_ID_PAF_VIDEO: AVCodecID = 177;
pub const AVCodecID_AV_CODEC_ID_EXR: AVCodecID = 178;
pub const AVCodecID_AV_CODEC_ID_VP7: AVCodecID = 179;
pub const AVCodecID_AV_CODEC_ID_SANM: AVCodecID = 180;
pub const AVCodecID_AV_CODEC_ID_SGIRLE: AVCodecID = 181;
pub const AVCodecID_AV_CODEC_ID_MVC1: AVCodecID = 182;
pub const AVCodecID_AV_CODEC_ID_MVC2: AVCodecID = 183;
pub const AVCodecID_AV_CODEC_ID_HQX: AVCodecID = 184;
pub const AVCodecID_AV_CODEC_ID_TDSC: AVCodecID = 185;
pub const AVCodecID_AV_CODEC_ID_HQ_HQA: AVCodecID = 186;
pub const AVCodecID_AV_CODEC_ID_HAP: AVCodecID = 187;
pub const AVCodecID_AV_CODEC_ID_DDS: AVCodecID = 188;
pub const AVCodecID_AV_CODEC_ID_DXV: AVCodecID = 189;
pub const AVCodecID_AV_CODEC_ID_SCREENPRESSO: AVCodecID = 190;
pub const AVCodecID_AV_CODEC_ID_RSCC: AVCodecID = 191;
pub const AVCodecID_AV_CODEC_ID_Y41P: AVCodecID = 32768;
pub const AVCodecID_AV_CODEC_ID_AVRP: AVCodecID = 32769;
pub const AVCodecID_AV_CODEC_ID_012V: AVCodecID = 32770;
pub const AVCodecID_AV_CODEC_ID_AVUI: AVCodecID = 32771;
pub const AVCodecID_AV_CODEC_ID_AYUV: AVCodecID = 32772;
pub const AVCodecID_AV_CODEC_ID_TARGA_Y216: AVCodecID = 32773;
pub const AVCodecID_AV_CODEC_ID_V308: AVCodecID = 32774;
pub const AVCodecID_AV_CODEC_ID_V408: AVCodecID = 32775;
pub const AVCodecID_AV_CODEC_ID_YUV4: AVCodecID = 32776;
pub const AVCodecID_AV_CODEC_ID_AVRN: AVCodecID = 32777;
pub const AVCodecID_AV_CODEC_ID_CPIA: AVCodecID = 32778;
pub const AVCodecID_AV_CODEC_ID_XFACE: AVCodecID = 32779;
pub const AVCodecID_AV_CODEC_ID_SNOW: AVCodecID = 32780;
pub const AVCodecID_AV_CODEC_ID_SMVJPEG: AVCodecID = 32781;
pub const AVCodecID_AV_CODEC_ID_APNG: AVCodecID = 32782;
pub const AVCodecID_AV_CODEC_ID_DAALA: AVCodecID = 32783;
pub const AVCodecID_AV_CODEC_ID_CFHD: AVCodecID = 32784;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 32785;
pub const AVCodecID_AV_CODEC_ID_M101: AVCodecID = 32786;
pub const AVCodecID_AV_CODEC_ID_MAGICYUV: AVCodecID = 32787;
pub const AVCodecID_AV_CODEC_ID_SHEERVIDEO: AVCodecID = 32788;
pub const AVCodecID_AV_CODEC_ID_YLC: AVCodecID = 32789;
pub const AVCodecID_AV_CODEC_ID_PSD: AVCodecID = 32790;
pub const AVCodecID_AV_CODEC_ID_PIXLET: AVCodecID = 32791;
pub const AVCodecID_AV_CODEC_ID_SPEEDHQ: AVCodecID = 32792;
pub const AVCodecID_AV_CODEC_ID_FMVC: AVCodecID = 32793;
pub const AVCodecID_AV_CODEC_ID_SCPR: AVCodecID = 32794;
pub const AVCodecID_AV_CODEC_ID_CLEARVIDEO: AVCodecID = 32795;
pub const AVCodecID_AV_CODEC_ID_XPM: AVCodecID = 32796;
pub const AVCodecID_AV_CODEC_ID_AV1: AVCodecID = 32797;
pub const AVCodecID_AV_CODEC_ID_BITPACKED: AVCodecID = 32798;
pub const AVCodecID_AV_CODEC_ID_MSCC: AVCodecID = 32799;
pub const AVCodecID_AV_CODEC_ID_SRGC: AVCodecID = 32800;
pub const AVCodecID_AV_CODEC_ID_SVG: AVCodecID = 32801;
pub const AVCodecID_AV_CODEC_ID_GDV: AVCodecID = 32802;
pub const AVCodecID_AV_CODEC_ID_FITS: AVCodecID = 32803;
/// < A dummy id pointing at the start of audio codecs
pub const AVCodecID_AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
pub const AVCodecID_AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
pub const AVCodecID_AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
pub const AVCodecID_AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
pub const AVCodecID_AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
pub const AVCodecID_AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
pub const AVCodecID_AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
pub const AVCodecID_AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
pub const AVCodecID_AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
pub const AVCodecID_AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
pub const AVCodecID_AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
pub const AVCodecID_AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
pub const AVCodecID_AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
pub const AVCodecID_AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
pub const AVCodecID_AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
pub const AVCodecID_AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
pub const AVCodecID_AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
pub const AVCodecID_AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
pub const AVCodecID_AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
pub const AVCodecID_AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
pub const AVCodecID_AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
pub const AVCodecID_AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
pub const AVCodecID_AV_CODEC_ID_S302M: AVCodecID = 65562;
pub const AVCodecID_AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
pub const AVCodecID_AV_CODEC_ID_PCM_S64LE: AVCodecID = 67584;
pub const AVCodecID_AV_CODEC_ID_PCM_S64BE: AVCodecID = 67585;
pub const AVCodecID_AV_CODEC_ID_PCM_F16LE: AVCodecID = 67586;
pub const AVCodecID_AV_CODEC_ID_PCM_F24LE: AVCodecID = 67587;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
pub const AVCodecID_AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
pub const AVCodecID_AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
pub const AVCodecID_AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
pub const AVCodecID_AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
pub const AVCodecID_AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
pub const AVCodecID_AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AFC: AVCodecID = 71680;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 71681;
pub const AVCodecID_AV_CODEC_ID_ADPCM_DTK: AVCodecID = 71682;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 71683;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 71684;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 71685;
pub const AVCodecID_AV_CODEC_ID_ADPCM_PSX: AVCodecID = 71686;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AICA: AVCodecID = 71687;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 71688;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 71689;
pub const AVCodecID_AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
pub const AVCodecID_AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
pub const AVCodecID_AV_CODEC_ID_RA_144: AVCodecID = 77824;
pub const AVCodecID_AV_CODEC_ID_RA_288: AVCodecID = 77825;
pub const AVCodecID_AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
pub const AVCodecID_AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
pub const AVCodecID_AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
pub const AVCodecID_AV_CODEC_ID_SDX2_DPCM: AVCodecID = 83968;
pub const AVCodecID_AV_CODEC_ID_GREMLIN_DPCM: AVCodecID = 83969;
pub const AVCodecID_AV_CODEC_ID_MP2: AVCodecID = 86016;
/// < preferred ID for decoding MPEG audio layer 1, 2 or 3
pub const AVCodecID_AV_CODEC_ID_MP3: AVCodecID = 86017;
pub const AVCodecID_AV_CODEC_ID_AAC: AVCodecID = 86018;
pub const AVCodecID_AV_CODEC_ID_AC3: AVCodecID = 86019;
pub const AVCodecID_AV_CODEC_ID_DTS: AVCodecID = 86020;
pub const AVCodecID_AV_CODEC_ID_VORBIS: AVCodecID = 86021;
pub const AVCodecID_AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
pub const AVCodecID_AV_CODEC_ID_WMAV1: AVCodecID = 86023;
pub const AVCodecID_AV_CODEC_ID_WMAV2: AVCodecID = 86024;
pub const AVCodecID_AV_CODEC_ID_MACE3: AVCodecID = 86025;
pub const AVCodecID_AV_CODEC_ID_MACE6: AVCodecID = 86026;
pub const AVCodecID_AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
pub const AVCodecID_AV_CODEC_ID_FLAC: AVCodecID = 86028;
pub const AVCodecID_AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
pub const AVCodecID_AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
pub const AVCodecID_AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
pub const AVCodecID_AV_CODEC_ID_ALAC: AVCodecID = 86032;
pub const AVCodecID_AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
/// < as in Berlin toast format
pub const AVCodecID_AV_CODEC_ID_GSM: AVCodecID = 86034;
pub const AVCodecID_AV_CODEC_ID_QDM2: AVCodecID = 86035;
pub const AVCodecID_AV_CODEC_ID_COOK: AVCodecID = 86036;
pub const AVCodecID_AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
pub const AVCodecID_AV_CODEC_ID_TTA: AVCodecID = 86038;
pub const AVCodecID_AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
pub const AVCodecID_AV_CODEC_ID_QCELP: AVCodecID = 86040;
pub const AVCodecID_AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
pub const AVCodecID_AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
pub const AVCodecID_AV_CODEC_ID_IMC: AVCodecID = 86043;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
pub const AVCodecID_AV_CODEC_ID_MLP: AVCodecID = 86045;
pub const AVCodecID_AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
pub const AVCodecID_AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
pub const AVCodecID_AV_CODEC_ID_APE: AVCodecID = 86048;
pub const AVCodecID_AV_CODEC_ID_NELLYMOSER: AVCodecID = 86049;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK8: AVCodecID = 86050;
pub const AVCodecID_AV_CODEC_ID_SPEEX: AVCodecID = 86051;
pub const AVCodecID_AV_CODEC_ID_WMAVOICE: AVCodecID = 86052;
pub const AVCodecID_AV_CODEC_ID_WMAPRO: AVCodecID = 86053;
pub const AVCodecID_AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86054;
pub const AVCodecID_AV_CODEC_ID_ATRAC3P: AVCodecID = 86055;
pub const AVCodecID_AV_CODEC_ID_EAC3: AVCodecID = 86056;
pub const AVCodecID_AV_CODEC_ID_SIPR: AVCodecID = 86057;
pub const AVCodecID_AV_CODEC_ID_MP1: AVCodecID = 86058;
pub const AVCodecID_AV_CODEC_ID_TWINVQ: AVCodecID = 86059;
pub const AVCodecID_AV_CODEC_ID_TRUEHD: AVCodecID = 86060;
pub const AVCodecID_AV_CODEC_ID_MP4ALS: AVCodecID = 86061;
pub const AVCodecID_AV_CODEC_ID_ATRAC1: AVCodecID = 86062;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86063;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86064;
pub const AVCodecID_AV_CODEC_ID_AAC_LATM: AVCodecID = 86065;
pub const AVCodecID_AV_CODEC_ID_QDMC: AVCodecID = 86066;
pub const AVCodecID_AV_CODEC_ID_CELT: AVCodecID = 86067;
pub const AVCodecID_AV_CODEC_ID_G723_1: AVCodecID = 86068;
pub const AVCodecID_AV_CODEC_ID_G729: AVCodecID = 86069;
pub const AVCodecID_AV_CODEC_ID_8SVX_EXP: AVCodecID = 86070;
pub const AVCodecID_AV_CODEC_ID_8SVX_FIB: AVCodecID = 86071;
pub const AVCodecID_AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86072;
pub const AVCodecID_AV_CODEC_ID_RALF: AVCodecID = 86073;
pub const AVCodecID_AV_CODEC_ID_IAC: AVCodecID = 86074;
pub const AVCodecID_AV_CODEC_ID_ILBC: AVCodecID = 86075;
pub const AVCodecID_AV_CODEC_ID_OPUS: AVCodecID = 86076;
pub const AVCodecID_AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86077;
pub const AVCodecID_AV_CODEC_ID_TAK: AVCodecID = 86078;
pub const AVCodecID_AV_CODEC_ID_METASOUND: AVCodecID = 86079;
pub const AVCodecID_AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86080;
pub const AVCodecID_AV_CODEC_ID_ON2AVC: AVCodecID = 86081;
pub const AVCodecID_AV_CODEC_ID_DSS_SP: AVCodecID = 86082;
pub const AVCodecID_AV_CODEC_ID_CODEC2: AVCodecID = 86083;
pub const AVCodecID_AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 88064;
pub const AVCodecID_AV_CODEC_ID_SONIC: AVCodecID = 88065;
pub const AVCodecID_AV_CODEC_ID_SONIC_LS: AVCodecID = 88066;
pub const AVCodecID_AV_CODEC_ID_EVRC: AVCodecID = 88067;
pub const AVCodecID_AV_CODEC_ID_SMV: AVCodecID = 88068;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF: AVCodecID = 88069;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF: AVCodecID = 88070;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 88071;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 88072;
pub const AVCodecID_AV_CODEC_ID_4GV: AVCodecID = 88073;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 88074;
pub const AVCodecID_AV_CODEC_ID_XMA1: AVCodecID = 88075;
pub const AVCodecID_AV_CODEC_ID_XMA2: AVCodecID = 88076;
pub const AVCodecID_AV_CODEC_ID_DST: AVCodecID = 88077;
pub const AVCodecID_AV_CODEC_ID_ATRAC3AL: AVCodecID = 88078;
pub const AVCodecID_AV_CODEC_ID_ATRAC3PAL: AVCodecID = 88079;
pub const AVCodecID_AV_CODEC_ID_DOLBY_E: AVCodecID = 88080;
pub const AVCodecID_AV_CODEC_ID_APTX: AVCodecID = 88081;
pub const AVCodecID_AV_CODEC_ID_APTX_HD: AVCodecID = 88082;
pub const AVCodecID_AV_CODEC_ID_SBC: AVCodecID = 88083;
/// < A dummy ID pointing at the start of subtitle codecs.
pub const AVCodecID_AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
/// < raw UTF-8 text
pub const AVCodecID_AV_CODEC_ID_TEXT: AVCodecID = 94210;
pub const AVCodecID_AV_CODEC_ID_XSUB: AVCodecID = 94211;
pub const AVCodecID_AV_CODEC_ID_SSA: AVCodecID = 94212;
pub const AVCodecID_AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
pub const AVCodecID_AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
pub const AVCodecID_AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
pub const AVCodecID_AV_CODEC_ID_SRT: AVCodecID = 94216;
pub const AVCodecID_AV_CODEC_ID_MICRODVD: AVCodecID = 96256;
pub const AVCodecID_AV_CODEC_ID_EIA_608: AVCodecID = 96257;
pub const AVCodecID_AV_CODEC_ID_JACOSUB: AVCodecID = 96258;
pub const AVCodecID_AV_CODEC_ID_SAMI: AVCodecID = 96259;
pub const AVCodecID_AV_CODEC_ID_REALTEXT: AVCodecID = 96260;
pub const AVCodecID_AV_CODEC_ID_STL: AVCodecID = 96261;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER1: AVCodecID = 96262;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER: AVCodecID = 96263;
pub const AVCodecID_AV_CODEC_ID_SUBRIP: AVCodecID = 96264;
pub const AVCodecID_AV_CODEC_ID_WEBVTT: AVCodecID = 96265;
pub const AVCodecID_AV_CODEC_ID_MPL2: AVCodecID = 96266;
pub const AVCodecID_AV_CODEC_ID_VPLAYER: AVCodecID = 96267;
pub const AVCodecID_AV_CODEC_ID_PJS: AVCodecID = 96268;
pub const AVCodecID_AV_CODEC_ID_ASS: AVCodecID = 96269;
pub const AVCodecID_AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 96270;
/// < A dummy ID pointing at the start of various fake codecs.
pub const AVCodecID_AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
pub const AVCodecID_AV_CODEC_ID_TTF: AVCodecID = 98304;
/// < Contain timestamp estimated through PCR of program stream.
pub const AVCodecID_AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
pub const AVCodecID_AV_CODEC_ID_BINTEXT: AVCodecID = 100352;
pub const AVCodecID_AV_CODEC_ID_XBIN: AVCodecID = 100353;
pub const AVCodecID_AV_CODEC_ID_IDF: AVCodecID = 100354;
pub const AVCodecID_AV_CODEC_ID_OTF: AVCodecID = 100355;
pub const AVCodecID_AV_CODEC_ID_SMPTE_KLV: AVCodecID = 100356;
pub const AVCodecID_AV_CODEC_ID_DVD_NAV: AVCodecID = 100357;
pub const AVCodecID_AV_CODEC_ID_TIMED_ID3: AVCodecID = 100358;
pub const AVCodecID_AV_CODEC_ID_BIN_DATA: AVCodecID = 100359;
/// < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
pub const AVCodecID_AV_CODEC_ID_PROBE: AVCodecID = 102400;
/// < _FAKE_ codec to indicate a raw MPEG-2 TS
/// stream (only used by libavformat)
pub const AVCodecID_AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
/// < _FAKE_ codec to indicate a MPEG-4 Systems
/// stream (only used by libavformat)
pub const AVCodecID_AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
/// < Dummy codec for streams containing only metadata information.
pub const AVCodecID_AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
/// < Passthrough codec, AVFrames wrapped in AVPacket
pub const AVCodecID_AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
/// Identify the syntax and semantics of the bitstream.
/// The principle is roughly:
/// Two decoders with the same ID can decode the same streams.
/// Two encoders with the same ID can encode compatible streams.
/// There may be slight deviations from the principle due to implementation
/// details.
///
/// If you add a codec ID to this list, add it so that
/// 1. no value of an existing codec ID changes (that would break ABI),
/// 2. it is as close as possible to similar codecs
///
/// After adding new codec IDs, do not forget to add an entry to the codec
/// descriptor list and bump libavcodec minor version.
pub type AVCodecID = u32;
/// This struct describes the properties of a single codec described by an
/// AVCodecID.
/// @see avcodec_descriptor_get()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    /// Name of the codec described by this descriptor. It is non-empty and
    /// unique for each codec descriptor. It should contain alphanumeric
    /// characters and '_' only.
    pub name: *const lang_items::c_char,
    /// A more descriptive name for this codec. May be NULL.
    pub long_name: *const lang_items::c_char,
    /// Codec properties, a combination of AV_CODEC_PROP_* flags.
    pub props: lang_items::c_int,
    /// MIME type(s) associated with the codec.
    /// May be NULL; if not, a NULL-terminated array of MIME types.
    /// The first item is always non-NULL and is the preferred MIME type.
    pub mime_types: *const *const lang_items::c_char,
    /// If non-NULL, an array of profiles recognized for this codec.
    /// Terminated with FF_PROFILE_UNKNOWN.
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    assert_eq!(
        std::mem::size_of::<AVCodecDescriptor>(),
        48usize,
        concat!("Size of: ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).long_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).props as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).mime_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecDescriptor>())).profiles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(profiles)
        )
    );
}
/// < discard nothing
pub const AVDiscard_AVDISCARD_NONE: AVDiscard = -16;
/// < discard useless packets like 0 size packets in avi
pub const AVDiscard_AVDISCARD_DEFAULT: AVDiscard = 0;
/// < discard all non reference
pub const AVDiscard_AVDISCARD_NONREF: AVDiscard = 8;
/// < discard all bidirectional frames
pub const AVDiscard_AVDISCARD_BIDIR: AVDiscard = 16;
/// < discard all non intra frames
pub const AVDiscard_AVDISCARD_NONINTRA: AVDiscard = 24;
/// < discard all frames except keyframes
pub const AVDiscard_AVDISCARD_NONKEY: AVDiscard = 32;
/// < discard all
pub const AVDiscard_AVDISCARD_ALL: AVDiscard = 48;
/// @ingroup lavc_decoding
pub type AVDiscard = i32;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
/// < Not part of ABI
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
pub type AVAudioServiceType = u32;
/// @ingroup lavc_encoding
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RcOverride {
    pub start_frame: lang_items::c_int,
    pub end_frame: lang_items::c_int,
    pub qscale: lang_items::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    assert_eq!(
        std::mem::size_of::<RcOverride>(),
        16usize,
        concat!("Size of: ", stringify!(RcOverride))
    );
    assert_eq!(
        std::mem::align_of::<RcOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(RcOverride))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<RcOverride>())).start_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<RcOverride>())).end_frame as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<RcOverride>())).qscale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(qscale)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<RcOverride>())).quality_factor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(quality_factor)
        )
    );
}
/// Pan Scan area.
/// This specifies the area which should be displayed.
/// Note there may be multiple such areas for one frame.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPanScan {
    /// id
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub id: lang_items::c_int,
    /// width and height in 1/16 pel
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub width: lang_items::c_int,
    pub height: lang_items::c_int,
    /// position of the top left corner in 1/16 pel for up to 3 fields/frames
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    assert_eq!(
        std::mem::size_of::<AVPanScan>(),
        24usize,
        concat!("Size of: ", stringify!(AVPanScan))
    );
    assert_eq!(
        std::mem::align_of::<AVPanScan>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPanScan))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPanScan>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPanScan>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPanScan>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPanScan>())).position as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(position)
        )
    );
}
/// This structure describes the bitrate properties of an encoded bitstream. It
/// roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
/// parameters for H.264/HEVC.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCPBProperties {
    /// Maximum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub max_bitrate: lang_items::c_int,
    /// Minimum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub min_bitrate: lang_items::c_int,
    /// Average bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub avg_bitrate: lang_items::c_int,
    /// The size of the buffer to which the ratecontrol is applied, in bits.
    /// Zero if unknown or unspecified.
    pub buffer_size: lang_items::c_int,
    /// The delay between the time the packet this structure is associated with
    /// is received and the time when it should be decoded, in periods of a 27MHz
    /// clock.
    ///
    /// UINT64_MAX when unknown or unspecified.
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    assert_eq!(
        std::mem::size_of::<AVCPBProperties>(),
        24usize,
        concat!("Size of: ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        std::mem::align_of::<AVCPBProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCPBProperties>())).max_bitrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(max_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCPBProperties>())).min_bitrate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(min_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCPBProperties>())).avg_bitrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(avg_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCPBProperties>())).buffer_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCPBProperties>())).vbv_delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(vbv_delay)
        )
    );
}
/// An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
/// bytes worth of palette. This side data signals that a new palette is
/// present.
pub const AVPacketSideDataType_AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
/// The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
/// that the extradata buffer was changed and the receiving side should
/// act upon it appropriately. The new extradata is embedded in the side
/// data buffer and should be immediately used for processing the current
/// frame or packet.
pub const AVPacketSideDataType_AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
/// An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
/// @code
/// u32le param_flags
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
/// s32le channel_count
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
/// u64le channel_layout
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
/// s32le sample_rate
/// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
/// s32le width
/// s32le height
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
/// An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
/// structures with info about macroblocks relevant to splitting the
/// packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
/// That is, it does not necessarily contain info about all macroblocks,
/// as long as the distance between macroblocks in the info is smaller
/// than the target payload size.
/// Each MB info structure is 12 bytes, and is laid out as follows:
/// @code
/// u32le bit offset from the start of the packet
/// u8    current quantizer at the start of the macroblock
/// u8    GOB number
/// u16le macroblock address within the GOB
/// u8    horizontal MV predictor
/// u8    vertical MV predictor
/// u8    horizontal MV predictor for block number 3
/// u8    vertical MV predictor for block number 3
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
/// This side data should be associated with an audio stream and contains
/// ReplayGain information in form of the AVReplayGain struct.
pub const AVPacketSideDataType_AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
/// This side data contains a 3x3 transformation matrix describing an affine
/// transformation that needs to be applied to the decoded video frames for
/// correct presentation.
///
/// See libavutil/display.h for a detailed description of the data.
pub const AVPacketSideDataType_AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
/// This side data should be associated with a video stream and contains
/// Stereoscopic 3D information in form of the AVStereo3D struct.
pub const AVPacketSideDataType_AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
/// This side data should be associated with an audio stream and corresponds
/// to enum AVAudioServiceType.
pub const AVPacketSideDataType_AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
/// This side data contains quality related information from the encoder.
/// @code
/// u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
/// u8    picture type
/// u8    error count
/// u16   reserved
/// u64le[error count] sum of squared differences between encoder in and output
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
/// This side data contains an integer value representing the stream index
/// of a "fallback" track.  A fallback track indicates an alternate
/// track to use when the current track can not be decoded for some reason.
/// e.g. no decoder available for codec.
pub const AVPacketSideDataType_AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
/// This side data corresponds to the AVCPBProperties struct.
pub const AVPacketSideDataType_AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
/// Recommmends skipping the specified number of samples
/// @code
/// u32le number of samples to skip from start of this packet
/// u32le number of samples to skip from end of this packet
/// u8    reason for start skip
/// u8    reason for end   skip (0=padding silence, 1=convergence)
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 11;
/// An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
/// the packet may contain "dual mono" audio specific to Japanese DTV
/// and if it is true, recommends only the selected channel to be used.
/// @code
/// u8    selected channels (0=mail/left, 1=sub/right, 2=both)
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 12;
/// A list of zero terminated key/value strings. There is no end marker for
/// the list, so it is required to rely on the side data size to stop.
pub const AVPacketSideDataType_AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 13;
/// Subtitle event position
/// @code
/// u32le x1
/// u32le y1
/// u32le x2
/// u32le y2
/// @endcode
pub const AVPacketSideDataType_AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 14;
/// Data found in BlockAdditional element of matroska container. There is
/// no end marker for the data, so it is required to rely on the side data
/// size to recognize the end. 8 byte id (as found in BlockAddId) followed
/// by data.
pub const AVPacketSideDataType_AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 15;
/// The optional first identifier line of a WebVTT cue.
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 16;
/// The optional settings (rendering instructions) that immediately
/// follow the timestamp specifier of a WebVTT cue.
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 17;
/// A list of zero terminated key/value strings. There is no end marker for
/// the list, so it is required to rely on the side data size to stop. This
/// side data includes updated metadata which appeared in the stream.
pub const AVPacketSideDataType_AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 18;
/// MPEGTS stream ID, this is required to pass the stream ID
/// information from the demuxer to the corresponding muxer.
pub const AVPacketSideDataType_AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 19;
/// Mastering display metadata (based on SMPTE-2086:2014). This metadata
/// should be associated with a video stream and contains data in the form
/// of the AVMasteringDisplayMetadata struct.
pub const AVPacketSideDataType_AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 20;
/// This side data should be associated with a video stream and corresponds
/// to the AVSphericalMapping structure.
pub const AVPacketSideDataType_AV_PKT_DATA_SPHERICAL: AVPacketSideDataType = 21;
/// Content light level (based on CTA-861.3). This metadata should be
/// associated with a video stream and contains data in the form of the
/// AVContentLightMetadata struct.
pub const AVPacketSideDataType_AV_PKT_DATA_CONTENT_LIGHT_LEVEL: AVPacketSideDataType = 22;
/// ATSC A53 Part 4 Closed Captions. This metadata should be associated with
/// a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
/// The number of bytes of CC data is AVPacketSideData.size.
pub const AVPacketSideDataType_AV_PKT_DATA_A53_CC: AVPacketSideDataType = 23;
/// This side data is encryption initialization data.
/// The format is not part of ABI, use av_encryption_init_info_* methods to
/// access.
pub const AVPacketSideDataType_AV_PKT_DATA_ENCRYPTION_INIT_INFO: AVPacketSideDataType = 24;
/// This side data contains encryption info for how to decrypt the packet.
/// The format is not part of ABI, use av_encryption_info_* methods to access.
pub const AVPacketSideDataType_AV_PKT_DATA_ENCRYPTION_INFO: AVPacketSideDataType = 25;
/// The number of side data types.
/// This is not part of the public API/ABI in the sense that it may
/// change when new side data types are added.
/// This must stay the last enum value.
/// If its value becomes huge, some code using it
/// needs to be updated as it assumes it to be smaller than other limits.
pub const AVPacketSideDataType_AV_PKT_DATA_NB: AVPacketSideDataType = 26;
/// @defgroup lavc_packet AVPacket
///
/// Types and functions for working with AVPacket.
/// @{
pub type AVPacketSideDataType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: lang_items::c_int,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    assert_eq!(
        std::mem::size_of::<AVPacketSideData>(),
        16usize,
        concat!("Size of: ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        std::mem::align_of::<AVPacketSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacketSideData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacketSideData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacketSideData>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(type_)
        )
    );
}
/// This structure stores compressed data. It is typically exported by demuxers
/// and then passed as input to decoders, or received as output from encoders and
/// then passed to muxers.
///
/// For video, it should typically contain one compressed frame. For audio it may
/// contain several compressed frames. Encoders are allowed to output empty
/// packets, with no compressed data, containing only side data
/// (e.g. to update some stream parameters at the end of encoding).
///
/// AVPacket is one of the few structs in FFmpeg, whose size is a part of public
/// ABI. Thus it may be allocated on stack and no new fields can be added to it
/// without libavcodec and libavformat major bump.
///
/// The semantics of data ownership depends on the buf field.
/// If it is set, the packet data is dynamically allocated and is
/// valid indefinitely until a call to av_packet_unref() reduces the
/// reference count to 0.
///
/// If the buf field is not set av_packet_ref() would make a copy instead
/// of increasing the reference count.
///
/// The side data is always allocated with av_malloc(), copied by
/// av_packet_ref() and freed by av_packet_unref().
///
/// @see av_packet_ref
/// @see av_packet_unref
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacket {
    /// A reference to the reference-counted buffer where the packet data is
    /// stored.
    /// May be NULL, then the packet data is not reference-counted.
    pub buf: *mut AVBufferRef,
    /// Presentation timestamp in AVStream->time_base units; the time at which
    /// the decompressed packet will be presented to the user.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    /// pts MUST be larger or equal to dts as presentation cannot happen before
    /// decompression, unless one wants to view hex dumps. Some formats misuse
    /// the terms dts and pts/cts to mean something different. Such timestamps
    /// must be converted to true pts/dts before they are stored in AVPacket.
    pub pts: i64,
    /// Decompression timestamp in AVStream->time_base units; the time at which
    /// the packet is decompressed.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    pub dts: i64,
    pub data: *mut u8,
    pub size: lang_items::c_int,
    pub stream_index: lang_items::c_int,
    /// A combination of AV_PKT_FLAG values
    pub flags: lang_items::c_int,
    /// Additional packet data that can be provided by the container.
    /// Packet can contain several types of side information.
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: lang_items::c_int,
    /// Duration of this packet in AVStream->time_base units, 0 if unknown.
    /// Equals next_pts - this_pts in presentation order.
    pub duration: i64,
    /// < byte position in stream, -1 if unknown
    pub pos: i64,
    /// @deprecated Same as the duration field, but as int64_t. This was required
    /// for Matroska subtitles, whose duration values could overflow when the
    /// duration field was still an int.
    pub convergence_duration: i64,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    assert_eq!(
        std::mem::size_of::<AVPacket>(),
        88usize,
        concat!("Size of: ", stringify!(AVPacket))
    );
    assert_eq!(
        std::mem::align_of::<AVPacket>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacket))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).dts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).stream_index as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).side_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).side_data_elems as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).duration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacket>())).convergence_duration as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(convergence_duration)
        )
    );
}
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT:
    AVSideDataParamChangeFlags = 1;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT:
    AVSideDataParamChangeFlags = 2;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE:
    AVSideDataParamChangeFlags = 4;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS:
    AVSideDataParamChangeFlags = 8;
pub type AVSideDataParamChangeFlags = u32;
/// @}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
pub const AVFieldOrder_AV_FIELD_UNKNOWN: AVFieldOrder = 0;
pub const AVFieldOrder_AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
pub const AVFieldOrder_AV_FIELD_TT: AVFieldOrder = 2;
pub const AVFieldOrder_AV_FIELD_BB: AVFieldOrder = 3;
pub const AVFieldOrder_AV_FIELD_TB: AVFieldOrder = 4;
pub const AVFieldOrder_AV_FIELD_BT: AVFieldOrder = 5;
pub type AVFieldOrder = u32;
/// main external API structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
/// applications.
/// The name string for AVOptions options matches the associated command line
/// parameter name and can be found in libavcodec/options_table.h
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
/// sizeof(AVCodecContext) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecContext {
    /// information on struct for av_log
    /// - set by avcodec_alloc_context3
    pub av_class: *const AVClass,
    pub log_level_offset: lang_items::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
    /// This is used to work around some encoder bugs.
    /// A demuxer should set this to what is stored in the field used to identify the codec.
    /// If there are multiple such fields in a container then the demuxer should choose the one
    /// which maximizes the information about the used codec.
    /// If the codec tag field in a container is larger than 32 bits then the demuxer should
    /// remap the longer ID to 32 bits with a table or other structure. Alternatively a new
    /// extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
    /// first.
    /// - encoding: Set by user, if not then the default based on codec_id will be used.
    /// - decoding: Set by user, will be converted to uppercase by libavcodec during init.
    pub codec_tag: lang_items::c_uint,
    pub priv_data: *mut lang_items::c_void,
    /// Private context used for internal data.
    ///
    /// Unlike priv_data, this is not codec-specific. It is used in general
    /// libavcodec functions.
    pub internal: *mut AVCodecInternal,
    /// Private data of the user, can be used to carry app specific stuff.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub opaque: *mut lang_items::c_void,
    /// the average bitrate
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: Set by user, may be overwritten by libavcodec
    /// if this info is available in the stream
    pub bit_rate: i64,
    /// number of bits the bitstream is allowed to diverge from the reference.
    /// the reference can be CBR (for CBR pass1) or VBR (for pass2)
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: unused
    pub bit_rate_tolerance: lang_items::c_int,
    /// Global quality for codecs which cannot change it per frame.
    /// This should be proportional to MPEG-1/2/4 qscale.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub global_quality: lang_items::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub compression_level: lang_items::c_int,
    /// AV_CODEC_FLAG_*.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags: lang_items::c_int,
    /// AV_CODEC_FLAG2_*
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags2: lang_items::c_int,
    /// some codecs need / can use extradata like Huffman tables.
    /// MJPEG: Huffman tables
    /// rv10: additional flags
    /// MPEG-4: global headers (they can be in the bitstream or here)
    /// The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
    /// than extradata_size to avoid problems if it is read with the bitstream reader.
    /// The bytewise contents of extradata must not depend on the architecture or CPU endianness.
    /// - encoding: Set/allocated/freed by libavcodec.
    /// - decoding: Set/allocated/freed by user.
    pub extradata: *mut u8,
    pub extradata_size: lang_items::c_int,
    /// This is the fundamental unit of time (in seconds) in terms
    /// of which frame timestamps are represented. For fixed-fps content,
    /// timebase should be 1/framerate and timestamp increments should be
    /// identically 1.
    /// This often, but not always is the inverse of the frame rate or field rate
    /// for video. 1/time_base is not the average frame rate if the frame rate is not
    /// constant.
    ///
    /// Like containers, elementary streams also can store timestamps, 1/time_base
    /// is the unit in which these timestamps are specified.
    /// As example of such codec time base see ISO/IEC 14496-2:2001(E)
    /// vop_time_increment_resolution and fixed_vop_rate
    /// (fixed_vop_rate == 0 implies that it is different from the framerate)
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: the use of this field for decoding is deprecated.
    /// Use framerate instead.
    pub time_base: AVRational,
    /// For some codecs, the time base is closer to the field rate than the frame rate.
    /// Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
    /// if no telecine is used ...
    ///
    /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
    pub ticks_per_frame: lang_items::c_int,
    /// Codec delay.
    ///
    /// Encoding: Number of frames delay there will be from the encoder input to
    /// the decoder output. (we assume the decoder matches the spec)
    /// Decoding: Number of frames delay in addition to what a standard decoder
    /// as specified in the spec would produce.
    ///
    /// Video:
    /// Number of frames the decoded output will be delayed relative to the
    /// encoded input.
    ///
    /// Audio:
    /// For encoding, this field is unused (see initial_padding).
    ///
    /// For decoding, this is the number of samples the decoder needs to
    /// output before the decoder's output is valid. When seeking, you should
    /// start decoding this many samples prior to your desired seek point.
    ///
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub delay: lang_items::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    /// from the container. Some decoders will require the dimensions
    /// to be set by the caller. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub width: lang_items::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    /// from the container. Some decoders will require the dimensions
    /// to be set by the caller. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub height: lang_items::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    /// e.g. from the container. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub coded_width: lang_items::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    /// e.g. from the container. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub coded_height: lang_items::c_int,
    /// the number of pictures in a group of pictures, or 0 for intra_only
    /// - encoding: Set by user.
    /// - decoding: unused
    pub gop_size: lang_items::c_int,
    /// Pixel format, see AV_PIX_FMT_xxx.
    /// May be set by the demuxer if known from headers.
    /// May be overridden by the decoder if it knows better.
    ///
    /// @note This field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: Set by user.
    /// - decoding: Set by user if known, overridden by libavcodec while
    /// parsing the data.
    pub pix_fmt: AVPixelFormat,
    /// If non NULL, 'draw_horiz_band' is called by the libavcodec
    /// decoder to draw a horizontal band. It improves cache usage. Not
    /// all codecs can do that. You must check the codec capabilities
    /// beforehand.
    /// When multithreading is used, it may be called from multiple threads
    /// at the same time; threads might draw different parts of the same AVFrame,
    /// or multiple AVFrames, and there is no guarantee that slices will be drawn
    /// in order.
    /// The function is also used by hardware acceleration APIs.
    /// It is called at least once during frame decoding to pass
    /// the data needed for hardware render.
    /// In that mode instead of pixel data, AVFrame points to
    /// a structure specific to the acceleration API. The application
    /// reads the structure and can change some fields to indicate progress
    /// or mark state.
    /// - encoding: unused
    /// - decoding: Set by user.
    /// @param height the height of the slice
    /// @param y the y position of the slice
    /// @param type 1->top field, 2->bottom field, 3->frame
    /// @param offset offset into the AVFrame.data from which the slice should be read
    pub draw_horiz_band: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut lang_items::c_int,
            y: lang_items::c_int,
            type_: lang_items::c_int,
            height: lang_items::c_int,
        ),
    >,
    /// callback to negotiate the pixelFormat
    /// @param fmt is the list of formats which are supported by the codec,
    /// it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
    /// The first is always the native one.
    /// @note The callback may be called again immediately if initialization for
    /// the selected (hardware-accelerated) pixel format failed.
    /// @warning Behavior is undefined if the callback returns a value not
    /// in the fmt list of formats.
    /// @return the chosen format
    /// - encoding: unused
    /// - decoding: Set by user, if not set the native format will be chosen.
    pub get_format: std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    /// maximum number of B-frames between non-B-frames
    /// Note: The output will be delayed by max_b_frames+1 relative to the input.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_b_frames: lang_items::c_int,
    /// qscale factor between IP and B-frames
    /// If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_factor: f32,
    /// @deprecated use encoder private options instead
    pub b_frame_strategy: lang_items::c_int,
    /// qscale offset between IP and B-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_offset: f32,
    /// Size of the frame reordering buffer in the decoder.
    /// For MPEG-2 it is 1 IPB or 0 low delay IP.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub has_b_frames: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub mpeg_quant: lang_items::c_int,
    /// qscale factor between P- and I-frames
    /// If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_factor: f32,
    /// qscale offset between P and I-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_offset: f32,
    /// luminance masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub lumi_masking: f32,
    /// temporary complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub temporal_cplx_masking: f32,
    /// spatial complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub spatial_cplx_masking: f32,
    /// p block masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub p_masking: f32,
    /// darkness masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dark_masking: f32,
    /// slice count
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user (or 0).
    pub slice_count: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub prediction_method: lang_items::c_int,
    /// slice offsets in the frame in bytes
    /// - encoding: Set/allocated by libavcodec.
    /// - decoding: Set/allocated by user (or NULL).
    pub slice_offset: *mut lang_items::c_int,
    /// sample aspect ratio (0 if unknown)
    /// That is the width of a pixel divided by the height of the pixel.
    /// Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub sample_aspect_ratio: AVRational,
    /// motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_cmp: lang_items::c_int,
    /// subpixel motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_sub_cmp: lang_items::c_int,
    /// macroblock comparison function (not supported yet)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_cmp: lang_items::c_int,
    /// interlaced DCT comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub ildct_cmp: lang_items::c_int,
    /// ME diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dia_size: lang_items::c_int,
    /// amount of previous MV predictors (2a+1 x 2a+1 square)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub last_predictor_count: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub pre_me: lang_items::c_int,
    /// motion estimation prepass comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_pre_cmp: lang_items::c_int,
    /// ME prepass diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub pre_dia_size: lang_items::c_int,
    /// subpel ME quality
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_subpel_quality: lang_items::c_int,
    /// maximum motion estimation search range in subpel units
    /// If 0 then no limit.
    ///
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_range: lang_items::c_int,
    /// slice flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub slice_flags: lang_items::c_int,
    /// macroblock decision mode
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_decision: lang_items::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub intra_matrix: *mut u16,
    /// custom inter quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub inter_matrix: *mut u16,
    /// @deprecated use encoder private options instead
    pub scenechange_threshold: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub noise_reduction: lang_items::c_int,
    /// precision of the intra DC coefficient - 8
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec
    pub intra_dc_precision: lang_items::c_int,
    /// Number of macroblock rows at the top which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_top: lang_items::c_int,
    /// Number of macroblock rows at the bottom which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_bottom: lang_items::c_int,
    /// minimum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmin: lang_items::c_int,
    /// maximum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmax: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub me_penalty_compensation: lang_items::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub bidir_refine: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub brd_scale: lang_items::c_int,
    /// minimum GOP size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub keyint_min: lang_items::c_int,
    /// number of reference frames
    /// - encoding: Set by user.
    /// - decoding: Set by lavc.
    pub refs: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub chromaoffset: lang_items::c_int,
    /// Note: Value depends upon the compare function used for fullpel ME.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mv0_threshold: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub b_sensitivity: lang_items::c_int,
    /// Chromaticity coordinates of the source primaries.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_primaries: AVColorPrimaries,
    /// Color Transfer Characteristic.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_trc: AVColorTransferCharacteristic,
    /// YUV colorspace type.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub colorspace: AVColorSpace,
    /// MPEG vs JPEG YUV range.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_range: AVColorRange,
    /// This defines the location of chroma samples.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub chroma_sample_location: AVChromaLocation,
    /// Number of slices.
    /// Indicates number of picture subdivisions. Used for parallelized
    /// decoding.
    /// - encoding: Set by user
    /// - decoding: unused
    pub slices: lang_items::c_int,
    /// Field order
    /// - encoding: set by libavcodec
    /// - decoding: Set by user.
    pub field_order: AVFieldOrder,
    /// < samples per second
    pub sample_rate: lang_items::c_int,
    /// < number of audio channels
    pub channels: lang_items::c_int,
    /// < sample format
    pub sample_fmt: AVSampleFormat,
    /// Number of samples per channel in an audio frame.
    ///
    /// - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
    /// except the last must contain exactly frame_size samples per channel.
    /// May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
    /// frame size is not restricted.
    /// - decoding: may be set by some decoders to indicate constant frame size
    pub frame_size: lang_items::c_int,
    /// Frame counter, set by libavcodec.
    ///
    /// - decoding: total number of frames returned from the decoder so far.
    /// - encoding: total number of frames passed to the encoder so far.
    ///
    /// @note the counter is not incremented if encoding/decoding resulted in
    /// an error.
    pub frame_number: lang_items::c_int,
    /// number of bytes per packet if constant and known or 0
    /// Used by some WAV based audio codecs.
    pub block_align: lang_items::c_int,
    /// Audio cutoff bandwidth (0 means "automatic")
    /// - encoding: Set by user.
    /// - decoding: unused
    pub cutoff: lang_items::c_int,
    /// Audio channel layout.
    /// - encoding: set by user.
    /// - decoding: set by user, may be overwritten by libavcodec.
    pub channel_layout: u64,
    /// Request decoder to use this channel layout if it can (0 for default)
    /// - encoding: unused
    /// - decoding: Set by user.
    pub request_channel_layout: u64,
    /// Type of service that the audio stream conveys.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub audio_service_type: AVAudioServiceType,
    /// desired sample format
    /// - encoding: Not used.
    /// - decoding: Set by user.
    /// Decoder will decode to this format if it can.
    pub request_sample_fmt: AVSampleFormat,
    /// This callback is called at the beginning of each frame to get data
    /// buffer(s) for it. There may be one contiguous buffer for all the data or
    /// there may be a buffer per each data plane or anything in between. What
    /// this means is, you may set however many entries in buf[] you feel necessary.
    /// Each buffer must be reference-counted using the AVBuffer API (see description
    /// of buf[] below).
    ///
    /// The following fields will be set in the frame before this callback is
    /// called:
    /// - format
    /// - width, height (video only)
    /// - sample_rate, channel_layout, nb_samples (audio only)
    /// Their values may differ from the corresponding values in
    /// AVCodecContext. This callback must use the frame values, not the codec
    /// context values, to calculate the required buffer size.
    ///
    /// This callback must fill the following fields in the frame:
    /// - data[]
    /// - linesize[]
    /// - extended_data:
    /// * if the data is planar audio with more than 8 channels, then this
    /// callback must allocate and fill extended_data to contain all pointers
    /// to all data planes. data[] must hold as many pointers as it can.
    /// extended_data must be allocated with av_malloc() and will be freed in
    /// av_frame_unref().
    /// * otherwise extended_data must point to data
    /// - buf[] must contain one or more pointers to AVBufferRef structures. Each of
    /// the frame's data and extended_data pointers must be contained in these. That
    /// is, one AVBufferRef for each allocated chunk of memory, not necessarily one
    /// AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
    /// and av_buffer_ref().
    /// - extended_buf and nb_extended_buf must be allocated with av_malloc() by
    /// this callback and filled with the extra buffers if there are more
    /// buffers than buf[] can hold. extended_buf will be freed in
    /// av_frame_unref().
    ///
    /// If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
    /// avcodec_default_get_buffer2() instead of providing buffers allocated by
    /// some other means.
    ///
    /// Each data plane must be aligned to the maximum required by the target
    /// CPU.
    ///
    /// @see avcodec_default_get_buffer2()
    ///
    /// Video:
    ///
    /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
    /// (read and/or written to if it is writable) later by libavcodec.
    ///
    /// avcodec_align_dimensions2() should be used to find the required width and
    /// height, as they normally need to be rounded up to the next multiple of 16.
    ///
    /// Some decoders do not support linesizes changing between frames.
    ///
    /// If frame multithreading is used and thread_safe_callbacks is set,
    /// this callback may be called from a different thread, but not from more
    /// than one at once. Does not need to be reentrant.
    ///
    /// @see avcodec_align_dimensions2()
    ///
    /// Audio:
    ///
    /// Decoders request a buffer of a particular size by setting
    /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
    /// however, utilize only part of the buffer by setting AVFrame.nb_samples
    /// to a smaller value in the output frame.
    ///
    /// As a convenience, av_samples_get_buffer_size() and
    /// av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
    /// functions to find the required data size and to fill data pointers and
    /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
    /// since all planes must be the same size.
    ///
    /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec, user can override.
    pub get_buffer2: std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, frame: *mut AVFrame, flags: lang_items::c_int)
            -> lang_items::c_int,
    >,
    /// If non-zero, the decoded audio and video frames returned from
    /// avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
    /// and are valid indefinitely. The caller must free them with
    /// av_frame_unref() when they are not needed anymore.
    /// Otherwise, the decoded frames must not be freed by the caller and are
    /// only valid until the next decode call.
    ///
    /// This is always automatically enabled if avcodec_receive_frame() is used.
    ///
    /// - encoding: unused
    /// - decoding: set by the caller before avcodec_open2().
    pub refcounted_frames: lang_items::c_int,
    /// < amount of qscale change between easy & hard scenes (0.0-1.0)
    pub qcompress: f32,
    /// < amount of qscale smoothing over time (0.0-1.0)
    pub qblur: f32,
    /// minimum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmin: lang_items::c_int,
    /// maximum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmax: lang_items::c_int,
    /// maximum quantizer difference between frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_qdiff: lang_items::c_int,
    /// decoder bitstream buffer size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_buffer_size: lang_items::c_int,
    /// ratecontrol override, see RcOverride
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub rc_override_count: lang_items::c_int,
    pub rc_override: *mut RcOverride,
    /// maximum bitrate
    /// - encoding: Set by user.
    /// - decoding: Set by user, may be overwritten by libavcodec.
    pub rc_max_rate: i64,
    /// minimum bitrate
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_min_rate: i64,
    /// Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_max_available_vbv_use: f32,
    /// Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_min_vbv_overflow_use: f32,
    /// Number of bits which should be loaded into the rc buffer before decoding starts.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_initial_buffer_occupancy: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub coder_type: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub context_model: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_threshold: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_factor: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_exp: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_cmp: lang_items::c_int,
    /// trellis RD quantization
    /// - encoding: Set by user.
    /// - decoding: unused
    pub trellis: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub min_prediction_order: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub max_prediction_order: lang_items::c_int,
    /// @deprecated use encoder private options instead
    pub timecode_frame_start: i64,
    /// @deprecated unused
    pub rtp_callback: std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            data: *mut lang_items::c_void,
            size: lang_items::c_int,
            mb_nb: lang_items::c_int,
        ),
    >,
    /// @deprecated use encoder private options instead
    pub rtp_payload_size: lang_items::c_int,
    pub mv_bits: lang_items::c_int,
    pub header_bits: lang_items::c_int,
    pub i_tex_bits: lang_items::c_int,
    pub p_tex_bits: lang_items::c_int,
    pub i_count: lang_items::c_int,
    pub p_count: lang_items::c_int,
    pub skip_count: lang_items::c_int,
    pub misc_bits: lang_items::c_int,
    /// @deprecated this field is unused
    pub frame_bits: lang_items::c_int,
    /// pass1 encoding statistics output buffer
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    pub stats_out: *mut lang_items::c_char,
    /// pass2 encoding statistics input buffer
    /// Concatenated stuff from stats_out of pass1 should be placed here.
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub stats_in: *mut lang_items::c_char,
    /// Work around bugs in encoders which sometimes cannot be detected automatically.
    /// - encoding: Set by user
    /// - decoding: Set by user
    pub workaround_bugs: lang_items::c_int,
    /// strictly follow the standard (MPEG-4, ...).
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    /// Setting this to STRICT or higher means the encoder and decoder will
    /// generally do stupid things, whereas setting it to unofficial or lower
    /// will mean the encoder might produce output that is not supported by all
    /// spec-compliant decoders. Decoders don't differentiate between normal,
    /// unofficial and experimental (that is, they always try to decode things
    /// when they can) unless they are explicitly asked to behave stupidly
    /// (=strictly conform to the specs)
    pub strict_std_compliance: lang_items::c_int,
    /// error concealment flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub error_concealment: lang_items::c_int,
    /// debug
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug: lang_items::c_int,
    /// Error recognition; may misdetect some more or less valid parts as errors.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub err_recognition: lang_items::c_int,
    /// opaque 64-bit number (generally a PTS) that will be reordered and
    /// output in AVFrame.reordered_opaque
    /// - encoding: unused
    /// - decoding: Set by user.
    pub reordered_opaque: i64,
    /// Hardware accelerator in use
    /// - encoding: unused.
    /// - decoding: Set by libavcodec
    pub hwaccel: *const AVHWAccel,
    /// Hardware accelerator context.
    /// For some hardware accelerators, a global context needs to be
    /// provided by the user. In that case, this holds display-dependent
    /// data FFmpeg cannot instantiate itself. Please refer to the
    /// FFmpeg HW accelerator documentation to know how to fill this
    /// is. e.g. for VA API, this is a struct vaapi_context.
    /// - encoding: unused
    /// - decoding: Set by user
    pub hwaccel_context: *mut lang_items::c_void,
    /// error
    /// - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
    /// - decoding: unused
    pub error: [u64; 8usize],
    /// DCT algorithm, see FF_DCT_* below
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dct_algo: lang_items::c_int,
    /// IDCT algorithm, see FF_IDCT_* below.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub idct_algo: lang_items::c_int,
    /// bits per sample/pixel from the demuxer (needed for huffyuv).
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user.
    pub bits_per_coded_sample: lang_items::c_int,
    /// Bits per sample/pixel of internal libavcodec pixel/sample format.
    /// - encoding: set by user.
    /// - decoding: set by libavcodec.
    pub bits_per_raw_sample: lang_items::c_int,
    /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
    /// - encoding: unused
    /// - decoding: Set by user.
    pub lowres: lang_items::c_int,
    /// the picture in the bitstream
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    ///
    /// @deprecated use the quality factor packet side data instead
    pub coded_frame: *mut AVFrame,
    /// thread count
    /// is used to decide how many independent tasks should be passed to execute()
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_count: lang_items::c_int,
    /// Which multithreading methods to use.
    /// Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
    /// so clients which cannot provide future frames should not use it.
    ///
    /// - encoding: Set by user, otherwise the default is used.
    /// - decoding: Set by user, otherwise the default is used.
    pub thread_type: lang_items::c_int,
    /// Which multithreading methods are in use by the codec.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub active_thread_type: lang_items::c_int,
    /// Set by the client if its custom get_buffer() callback can be called
    /// synchronously from another thread, which allows faster multithreaded decoding.
    /// draw_horiz_band() will be called from other threads regardless of this setting.
    /// Ignored if the default get_buffer() is used.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_safe_callbacks: lang_items::c_int,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// @param count the number of things to execute
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute: std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: std::option::Option<
                unsafe extern "C" fn(c2: *mut AVCodecContext, arg: *mut lang_items::c_void)
                    -> lang_items::c_int,
            >,
            arg2: *mut lang_items::c_void,
            ret: *mut lang_items::c_int,
            count: lang_items::c_int,
            size: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
    /// @param c context passed also to func
    /// @param count the number of things to execute
    /// @param arg2 argument passed unchanged to func
    /// @param ret return values of executed functions, must have space for "count" values. May be NULL.
    /// @param func function that will be called count times, with jobnr from 0 to count-1.
    /// threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
    /// two instances of func executing at the same time will have the same threadnr.
    /// @return always 0 currently, but code should handle a future improvement where when any call to func
    /// returns < 0 no further calls to func may be done and < 0 is returned.
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute2: std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut lang_items::c_void,
                    jobnr: lang_items::c_int,
                    threadnr: lang_items::c_int,
                ) -> lang_items::c_int,
            >,
            arg2: *mut lang_items::c_void,
            ret: *mut lang_items::c_int,
            count: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    /// noise vs. sse weight for the nsse comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub nsse_weight: lang_items::c_int,
    /// profile
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub profile: lang_items::c_int,
    /// level
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub level: lang_items::c_int,
    /// Skip loop filtering for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_loop_filter: AVDiscard,
    /// Skip IDCT/dequantization for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_idct: AVDiscard,
    /// Skip decoding for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_frame: AVDiscard,
    /// Header containing style information for text subtitles.
    /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
    /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
    /// the Format line following. It shouldn't include any Dialogue line.
    /// - encoding: Set/allocated/freed by user (before avcodec_open2())
    /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: lang_items::c_int,
    /// VBV delay coded in the last frame (in periods of a 27 MHz clock).
    /// Used for compliant TS muxing.
    /// - encoding: Set by libavcodec.
    /// - decoding: unused.
    /// @deprecated this value is now exported as a part of
    /// AV_PKT_DATA_CPB_PROPERTIES packet side data
    pub vbv_delay: u64,
    /// Encoding only and set by default. Allow encoders to output packets
    /// that do not contain any encoded data, only side data.
    ///
    /// Some encoders need to output such packets, e.g. to update some stream
    /// parameters at the end of encoding.
    ///
    /// @deprecated this field disables the default behaviour and
    /// it is kept only for compatibility.
    pub side_data_only_packets: lang_items::c_int,
    /// Audio only. The number of "priming" samples (padding) inserted by the
    /// encoder at the beginning of the audio. I.e. this number of leading
    /// decoded samples must be discarded by the caller to get the original audio
    /// without leading padding.
    ///
    /// - decoding: unused
    /// - encoding: Set by libavcodec. The timestamps on the output packets are
    /// adjusted by the encoder so that they always refer to the
    /// first sample of the data actually contained in the packet,
    /// including any added padding.  E.g. if the timebase is
    /// 1/samplerate and the timestamp of the first input sample is
    /// 0, the timestamp of the first output packet will be
    /// -initial_padding.
    pub initial_padding: lang_items::c_int,
    /// - decoding: For codecs that store a framerate value in the compressed
    /// bitstream, the decoder may export it here. { 0, 1} when
    /// unknown.
    /// - encoding: May be used to signal the framerate of CFR content to an
    /// encoder.
    pub framerate: AVRational,
    /// Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
    /// - encoding: unused.
    /// - decoding: Set by libavcodec before calling get_format()
    pub sw_pix_fmt: AVPixelFormat,
    /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
    /// - encoding unused.
    /// - decoding set by user.
    pub pkt_timebase: AVRational,
    /// AVCodecDescriptor
    /// - encoding: unused.
    /// - decoding: set by libavcodec.
    pub codec_descriptor: *const AVCodecDescriptor,
    /// Current statistics for PTS correction.
    /// - decoding: maintained and used by libavcodec, not intended to be used by user apps
    /// - encoding: unused
    pub pts_correction_num_faulty_pts: i64,
    /// Number of incorrect PTS values so far
    pub pts_correction_num_faulty_dts: i64,
    /// Number of incorrect DTS values so far
    pub pts_correction_last_pts: i64,
    /// PTS of the last frame
    pub pts_correction_last_dts: i64,
    /// Character encoding of the input subtitles file.
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_charenc: *mut lang_items::c_char,
    /// Subtitles character encoding mode. Formats or codecs might be adjusting
    /// this setting (if they are doing the conversion themselves for instance).
    /// - decoding: set by libavcodec
    /// - encoding: unused
    pub sub_charenc_mode: lang_items::c_int,
    /// Skip processing alpha if supported by codec.
    /// Note that if the format uses pre-multiplied alpha (common with VP6,
    /// and recommended due to better video quality/compression)
    /// the image will look as if alpha-blended onto a black background.
    /// However for formats that do not use pre-multiplied alpha
    /// there might be serious artefacts (though e.g. libswscale currently
    /// assumes pre-multiplied alpha anyway).
    ///
    /// - decoding: set by user
    /// - encoding: unused
    pub skip_alpha: lang_items::c_int,
    /// Number of samples to skip after a discontinuity
    /// - decoding: unused
    /// - encoding: set by libavcodec
    pub seek_preroll: lang_items::c_int,
    /// debug motion vectors
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug_mv: lang_items::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: unused.
    pub chroma_intra_matrix: *mut u16,
    /// dump format separator.
    /// can be ", " or "\n      " or anything else
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub dump_separator: *mut u8,
    /// ',' separated list of allowed decoders.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub codec_whitelist: *mut lang_items::c_char,
    /// Properties of the stream that gets decoded
    /// - encoding: unused
    /// - decoding: set by libavcodec
    pub properties: lang_items::c_uint,
    /// Additional data associated with the entire coded stream.
    ///
    /// - decoding: unused
    /// - encoding: may be set by libavcodec after avcodec_open2().
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: lang_items::c_int,
    /// A reference to the AVHWFramesContext describing the input (for encoding)
    /// or output (decoding) frames. The reference is set by the caller and
    /// afterwards owned (and freed) by libavcodec - it should never be read by
    /// the caller after being set.
    ///
    /// - decoding: This field should be set by the caller from the get_format()
    /// callback. The previous reference (if any) will always be
    /// unreffed by libavcodec before the get_format() call.
    ///
    /// If the default get_buffer2() is used with a hwaccel pixel
    /// format, then this AVHWFramesContext will be used for
    /// allocating the frame buffers.
    ///
    /// - encoding: For hardware encoders configured to use a hwaccel pixel
    /// format, this field should be set by the caller to a reference
    /// to the AVHWFramesContext describing input frames.
    /// AVHWFramesContext.format must be equal to
    /// AVCodecContext.pix_fmt.
    ///
    /// This field should be set before avcodec_open2() is called.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// Control the form of AVSubtitle.rects[N]->ass
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_text_format: lang_items::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    ///
    /// - decoding: unused
    /// - encoding: unused
    pub trailing_padding: lang_items::c_int,
    /// The number of pixels per image to maximally accept.
    ///
    /// - decoding: set by user
    /// - encoding: set by user
    pub max_pixels: i64,
    /// A reference to the AVHWDeviceContext describing the device which will
    /// be used by a hardware encoder/decoder.  The reference is set by the
    /// caller and afterwards owned (and freed) by libavcodec.
    ///
    /// This should be used if either the codec device does not require
    /// hardware frames or any that are used are to be allocated internally by
    /// libavcodec.  If the user wishes to supply any of the frames used as
    /// encoder input or decoder output then hw_frames_ctx should be used
    /// instead.  When hw_frames_ctx is set in get_format() for a decoder, this
    /// field will be ignored while decoding the associated stream segment, but
    /// may again be used on a following one after another get_format() call.
    ///
    /// For both encoders and decoders this field should be set before
    /// avcodec_open2() is called and must not be written to thereafter.
    ///
    /// Note that some decoders may require this field to be set initially in
    /// order to support hw_frames_ctx at all - in that case, all frames
    /// contexts used must be created on the same device.
    pub hw_device_ctx: *mut AVBufferRef,
    /// Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
    /// decoding (if active).
    /// - encoding: unused
    /// - decoding: Set by user (either before avcodec_open2(), or in the
    /// AVCodecContext.get_format callback)
    pub hwaccel_flags: lang_items::c_int,
    /// Video decoding only. Certain video codecs support cropping, meaning that
    /// only a sub-rectangle of the decoded frame is intended for display.  This
    /// option controls how cropping is handled by libavcodec.
    ///
    /// When set to 1 (the default), libavcodec will apply cropping internally.
    /// I.e. it will modify the output frame width/height fields and offset the
    /// data pointers (only by as much as possible while preserving alignment, or
    /// by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
    /// the frames output by the decoder refer only to the cropped area. The
    /// crop_* fields of the output frames will be zero.
    ///
    /// When set to 0, the width/height fields of the output frames will be set
    /// to the coded dimensions and the crop_* fields will describe the cropping
    /// rectangle. Applying the cropping is left to the caller.
    ///
    /// @warning When hardware acceleration with opaque output frames is used,
    /// libavcodec is unable to apply cropping from the top/left border.
    ///
    /// @note when this option is set to zero, the width/height fields of the
    /// AVCodecContext and output AVFrames have different meanings. The codec
    /// context fields store display dimensions (with the coded dimensions in
    /// coded_width/height), while the frame fields store the coded dimensions
    /// (with the display dimensions being determined by the crop_* fields).
    pub apply_cropping: lang_items::c_int,
    pub extra_hw_frames: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    assert_eq!(
        std::mem::size_of::<AVCodecContext>(),
        1056usize,
        concat!("Size of: ", stringify!(AVCodecContext))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).log_level_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(log_level_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).codec_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).codec_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).codec_tag as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).priv_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).internal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).bit_rate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).bit_rate_tolerance as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).global_quality as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(global_quality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).compression_level as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(compression_level)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).flags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).flags2 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).extradata as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).extradata_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).time_base as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).ticks_per_frame as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ticks_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).delay as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).width as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).coded_width as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).coded_height as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).gop_size as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(gop_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).pix_fmt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).draw_horiz_band as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(draw_horiz_band)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).get_format as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).max_b_frames as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).b_quant_factor as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).b_frame_strategy as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_frame_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).b_quant_offset as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).has_b_frames as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(has_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mpeg_quant as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mpeg_quant)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).i_quant_factor as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).i_quant_offset as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).lumi_masking as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lumi_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).temporal_cplx_masking as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(temporal_cplx_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).spatial_cplx_masking as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(spatial_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).p_masking as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).dark_masking as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dark_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).slice_count as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).prediction_method as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(prediction_method)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).slice_offset as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).sample_aspect_ratio as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).me_cmp as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).me_sub_cmp as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_sub_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mb_cmp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).ildct_cmp as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ildct_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).dia_size as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).last_predictor_count as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(last_predictor_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).pre_me as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_me)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).me_pre_cmp as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_pre_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).pre_dia_size as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).me_subpel_quality as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_subpel_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).me_range as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_range)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).slice_flags as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mb_decision as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_decision)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).intra_matrix as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).inter_matrix as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).scenechange_threshold as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(scenechange_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).noise_reduction as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(noise_reduction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).intra_dc_precision as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_top as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_top)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_bottom as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mb_lmin as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmin)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mb_lmax as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).me_penalty_compensation as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_penalty_compensation)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).bidir_refine as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bidir_refine)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).brd_scale as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(brd_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).keyint_min as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(keyint_min)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).refs as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).chromaoffset as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chromaoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mv0_threshold as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv0_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).b_sensitivity as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_sensitivity)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).color_primaries as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).color_trc as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).colorspace as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).color_range as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).chroma_sample_location as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_sample_location)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).slices as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slices)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).field_order as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).sample_rate as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).channels as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).sample_fmt as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).frame_size as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).frame_number as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).block_align as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).cutoff as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).channel_layout as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).request_channel_layout as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).audio_service_type as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(audio_service_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).request_sample_fmt as *const _ as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).get_buffer2 as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_buffer2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).refcounted_frames as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refcounted_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).qcompress as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qcompress)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).qblur as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qblur)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).qmin as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmin)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).qmax as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmax)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).max_qdiff as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_qdiff)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).rc_buffer_size as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).rc_override_count as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).rc_override as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).rc_max_rate as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).rc_min_rate as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).rc_max_available_vbv_use as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_available_vbv_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).rc_min_vbv_overflow_use as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_vbv_overflow_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).rc_initial_buffer_occupancy as *const _
                as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_buffer_occupancy)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).coder_type as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coder_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).context_model as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(context_model)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).frame_skip_threshold as *const _ as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).frame_skip_factor as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).frame_skip_exp as *const _ as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).frame_skip_cmp as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).trellis as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trellis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).min_prediction_order as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(min_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).max_prediction_order as *const _ as usize
        },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).timecode_frame_start as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(timecode_frame_start)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).rtp_callback as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).rtp_payload_size as *const _ as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).mv_bits as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).header_bits as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(header_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).i_tex_bits as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).p_tex_bits as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).i_count as *const _ as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).p_count as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_count as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).misc_bits as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(misc_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).frame_bits as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).stats_out as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_out)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).stats_in as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_in)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).workaround_bugs as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(workaround_bugs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).strict_std_compliance as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).error_concealment as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_concealment)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).debug as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).err_recognition as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(err_recognition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).reordered_opaque as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).hwaccel as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).hwaccel_context as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_context)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).error as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).dct_algo as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).idct_algo as *const _ as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).bits_per_coded_sample as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).bits_per_raw_sample as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).lowres as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).coded_frame as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).thread_count as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).thread_type as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).active_thread_type as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(active_thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).thread_safe_callbacks as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_safe_callbacks)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).execute as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).execute2 as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute2)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).nsse_weight as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nsse_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).profile as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).level as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).skip_loop_filter as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_loop_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_idct as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_idct)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_frame as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).subtitle_header as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).subtitle_header_size as *const _ as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).vbv_delay as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(vbv_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).side_data_only_packets as *const _ as usize
        },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(side_data_only_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).initial_padding as *const _ as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).framerate as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).sw_pix_fmt as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sw_pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).pkt_timebase as *const _ as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pkt_timebase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).codec_descriptor as *const _ as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_pts as *const _
                as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_dts as *const _
                as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).pts_correction_last_pts as *const _ as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).pts_correction_last_dts as *const _ as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).sub_charenc as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).sub_charenc_mode as *const _ as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).skip_alpha as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).seek_preroll as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).debug_mv as *const _ as usize },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug_mv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).chroma_intra_matrix as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).dump_separator as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).codec_whitelist as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).properties as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).coded_side_data as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).nb_coded_side_data as *const _ as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).hw_frames_ctx as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).sub_text_format as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_text_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecContext>())).trailing_padding as *const _ as usize
        },
        1020usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).max_pixels as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).hw_device_ctx as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).hwaccel_flags as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).apply_cropping as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(apply_cropping)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecContext>())).extra_hw_frames as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
}
extern "C" {
    /// Accessors for some AVCodecContext fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext) -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext, val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(
        avctx: *mut AVCodecContext,
        desc: *const AVCodecDescriptor,
    );
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> lang_items::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: lang_items::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext) -> lang_items::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: lang_items::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext) -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext, val: *mut u16);
}
/// AVProfile.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProfile {
    pub profile: lang_items::c_int,
    /// < short name for the profile
    pub name: *const lang_items::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    assert_eq!(
        std::mem::size_of::<AVProfile>(),
        16usize,
        concat!("Size of: ", stringify!(AVProfile))
    );
    assert_eq!(
        std::mem::align_of::<AVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProfile))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProfile>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProfile>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(name)
        )
    );
}
/// The codec supports this format via the hw_device_ctx interface.
///
/// When selecting this format, AVCodecContext.hw_device_ctx should
/// have been set to a device of the specified type before calling
/// avcodec_open2().
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_4 = 1;
/// The codec supports this format via the hw_frames_ctx interface.
///
/// When selecting this format for a decoder,
/// AVCodecContext.hw_frames_ctx should be set to a suitable frames
/// context inside the get_format() callback.  The frames context
/// must have been created on a device of the specified type.
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_4 = 2;
/// The codec supports this format by some internal method.
///
/// This format can be selected without any additional configuration -
/// no device or frames context is required.
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_4 = 4;
/// The codec supports this format by some ad-hoc method.
///
/// Additional settings and/or function calls are required.  See the
/// codec-specific documentation for details.  (Methods requiring
/// this sort of configuration are deprecated and others should be
/// used in preference.)
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_4 = 8;
pub type _bindgen_ty_4 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfig {
    /// A hardware pixel format which the codec can use.
    pub pix_fmt: AVPixelFormat,
    /// Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
    /// setup methods which can be used with this configuration.
    pub methods: lang_items::c_int,
    /// The device type associated with the configuration.
    ///
    /// Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
    /// AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
    pub device_type: AVHWDeviceType,
}
#[test]
fn bindgen_test_layout_AVCodecHWConfig() {
    assert_eq!(
        std::mem::size_of::<AVCodecHWConfig>(),
        12usize,
        concat!("Size of: ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecHWConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecHWConfig>())).pix_fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecHWConfig>())).methods as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecHWConfig>())).device_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(device_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
/// AVCodec.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodec {
    /// Name of the codec implementation.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    /// This is the primary way to find a codec from the user perspective.
    pub name: *const lang_items::c_char,
    /// Descriptive name for the codec, meant to be more human readable than name.
    /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
    pub long_name: *const lang_items::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    /// Codec capabilities.
    /// see AV_CODEC_CAP_*
    pub capabilities: lang_items::c_int,
    /// < array of supported framerates, or NULL if any, array is terminated by {0,0}
    pub supported_framerates: *const AVRational,
    /// < array of supported pixel formats, or NULL if unknown, array is terminated by -1
    pub pix_fmts: *const AVPixelFormat,
    /// < array of supported audio samplerates, or NULL if unknown, array is terminated by 0
    pub supported_samplerates: *const lang_items::c_int,
    /// < array of supported sample formats, or NULL if unknown, array is terminated by -1
    pub sample_fmts: *const AVSampleFormat,
    /// < array of support channel layouts, or NULL if unknown. array is terminated by 0
    pub channel_layouts: *const u64,
    /// < maximum value for lowres supported by the decoder
    pub max_lowres: u8,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// < array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
    pub profiles: *const AVProfile,
    /// Group name of the codec implementation.
    /// This is a short symbolic name of the wrapper backing this codec. A
    /// wrapper uses some kind of external implementation for the codec, such
    /// as an external library, or a codec implementation provided by the OS or
    /// the hardware.
    /// If this field is NULL, this is a builtin, libavcodec native codec.
    /// If non-NULL, this will be the suffix in AVCodec.name in most cases
    /// (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
    pub wrapper_name: *const lang_items::c_char,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: lang_items::c_int,
    pub next: *mut AVCodec,
    /// @name Frame-level threading support functions
    /// @{
    /// /
    /// /**
    /// If defined, called on thread contexts when they are created.
    /// If the codec allocates writable tables in init(), re-allocate them here.
    /// priv_data will be set to a copy of the original.
    pub init_thread_copy: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> lang_items::c_int,
    >,
    /// Copy necessary context variables from a previous thread context to the current one.
    /// If not defined, the next thread will start automatically; otherwise, the codec
    /// must call ff_thread_finish_setup().
    ///
    /// dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
    pub update_thread_context: std::option::Option<
        unsafe extern "C" fn(dst: *mut AVCodecContext, src: *const AVCodecContext)
            -> lang_items::c_int,
    >,
    /// Private codec-specific defaults.
    pub defaults: *const AVCodecDefault,
    /// Initialize codec static data, called from avcodec_register().
    ///
    /// This is not intended for time consuming operations as it is
    /// run for every codec regardless of that codec being used.
    pub init_static_data: std::option::Option<unsafe extern "C" fn(codec: *mut AVCodec)>,
    pub init: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> lang_items::c_int,
    >,
    pub encode_sub: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            buf: *mut u8,
            buf_size: lang_items::c_int,
            sub: *const AVSubtitle,
        ) -> lang_items::c_int,
    >,
    /// Encode data to an AVPacket.
    ///
    /// @param      avctx          codec context
    /// @param      avpkt          output AVPacket (may contain a user-provided buffer)
    /// @param[in]  frame          AVFrame containing the raw data to be encoded
    /// @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
    /// non-empty packet was returned in avpkt.
    /// @return 0 on success, negative error code on failure
    pub encode2: std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
            frame: *const AVFrame,
            got_packet_ptr: *mut lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub decode: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            outdata: *mut lang_items::c_void,
            outdata_size: *mut lang_items::c_int,
            avpkt: *mut AVPacket,
        ) -> lang_items::c_int,
    >,
    pub close: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> lang_items::c_int,
    >,
    /// Encode API with decoupled packet/frame dataflow. The API is the
    /// same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except
    /// that:
    /// - never called if the codec is closed or the wrong type,
    /// - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent,
    /// - only one drain frame is ever passed down,
    pub send_frame: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *const AVFrame)
            -> lang_items::c_int,
    >,
    pub receive_packet: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> lang_items::c_int,
    >,
    /// Decode API with decoupled packet/frame dataflow. This function is called
    /// to get one output frame. It should call ff_decode_get_packet() to obtain
    /// input data.
    pub receive_frame: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> lang_items::c_int,
    >,
    /// Flush buffers.
    /// Will be called when seeking
    pub flush: std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext)>,
    /// Internal codec capabilities.
    /// See FF_CODEC_CAP_* in internal.h
    pub caps_internal: lang_items::c_int,
    /// Decoding only, a comma-separated list of bitstream filters to apply to
    /// packets before decoding.
    pub bsfs: *const lang_items::c_char,
    /// Array of pointers to hardware configurations supported by the codec,
    /// or NULL if no hardware supported.  The array is terminated by a NULL
    /// pointer.
    ///
    /// The user can only access this field via avcodec_get_hw_config().
    pub hw_configs: *mut *mut AVCodecHWConfigInternal,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    assert_eq!(
        std::mem::size_of::<AVCodec>(),
        248usize,
        concat!("Size of: ", stringify!(AVCodec))
    );
    assert_eq!(
        std::mem::align_of::<AVCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodec))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).capabilities as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).supported_framerates as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_framerates)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).pix_fmts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(pix_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).supported_samplerates as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).sample_fmts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).channel_layouts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).max_lowres as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(max_lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).priv_class as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).profiles as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).wrapper_name as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(wrapper_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).priv_data_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).next as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).init_thread_copy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_thread_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).update_thread_context as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(update_thread_context)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).defaults as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).init_static_data as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_static_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).init as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).encode_sub as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode_sub)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).encode2 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode2)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).decode as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).close as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).send_frame as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).receive_packet as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).receive_frame as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).flush as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).caps_internal as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).bsfs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(bsfs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodec>())).hw_configs as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(hw_configs)
        )
    );
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Retrieve supported hardware configurations for a codec.
    ///
    /// Values of index from zero to some maximum return the indexed configuration
    /// descriptor; all other values return NULL.  If the codec does not support
    /// any hardware configurations then it will always return NULL.
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: lang_items::c_int,
    ) -> *const AVCodecHWConfig;
}
/// @defgroup lavc_hwaccel AVHWAccel
///
/// @note  Nothing in this structure should be accessed by the user.  At some
/// point in future it will not be externally visible at all.
///
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWAccel {
    /// Name of the hardware accelerated codec.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    pub name: *const lang_items::c_char,
    /// Type of codec implemented by the hardware accelerator.
    ///
    /// See AVMEDIA_TYPE_xxx
    pub type_: AVMediaType,
    /// Codec implemented by the hardware accelerator.
    ///
    /// See AV_CODEC_ID_xxx
    pub id: AVCodecID,
    /// Supported pixel format.
    ///
    /// Only hardware accelerated formats are supported here.
    pub pix_fmt: AVPixelFormat,
    /// Hardware accelerated codec capabilities.
    /// see AV_HWACCEL_CODEC_CAP_*
    pub capabilities: lang_items::c_int,
    /// Allocate a custom buffer
    pub alloc_frame: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> lang_items::c_int,
    >,
    /// Called at the beginning of each frame or field picture.
    ///
    /// Meaningful frame information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    ///
    /// Note that buf can be NULL along with buf_size set to 0.
    /// Otherwise, this means the whole frame is available at this point.
    ///
    /// @param avctx the codec context
    /// @param buf the frame data buffer base
    /// @param buf_size the size of the frame in bytes
    /// @return zero if successful, a negative value otherwise
    pub start_frame: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> lang_items::c_int,
    >,
    /// Callback for parameter data (SPS/PPS/VPS etc).
    ///
    /// Useful for hardware decoders which keep persistent state about the
    /// video parameters, and need to receive any changes to update that state.
    ///
    /// @param avctx the codec context
    /// @param type the nal unit type
    /// @param buf the nal unit data buffer
    /// @param buf_size the size of the nal unit in bytes
    /// @return zero if successful, a negative value otherwise
    pub decode_params: std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            type_: lang_items::c_int,
            buf: *const u8,
            buf_size: u32,
        ) -> lang_items::c_int,
    >,
    /// Callback for each slice.
    ///
    /// Meaningful slice information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    /// The only exception is XvMC, that works on MB level.
    ///
    /// @param avctx the codec context
    /// @param buf the slice data buffer base
    /// @param buf_size the size of the slice in bytes
    /// @return zero if successful, a negative value otherwise
    pub decode_slice: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> lang_items::c_int,
    >,
    /// Called at the end of each frame or field picture.
    ///
    /// The whole picture is parsed at this point and can now be sent
    /// to the hardware accelerator. This function is mandatory.
    ///
    /// @param avctx the codec context
    /// @return zero if successful, a negative value otherwise
    pub end_frame: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> lang_items::c_int,
    >,
    /// Size of per-frame hardware accelerator private data.
    ///
    /// Private data is allocated with av_mallocz() before
    /// AVCodecContext.get_buffer() and deallocated after
    /// AVCodecContext.release_buffer().
    pub frame_priv_data_size: lang_items::c_int,
    /// Called for every Macroblock in a slice.
    ///
    /// XvMC uses it to replace the ff_mpv_reconstruct_mb().
    /// Instead of decoding to raw picture, MB parameters are
    /// stored in an array provided by the video driver.
    ///
    /// @param s the mpeg context
    pub decode_mb: std::option::Option<unsafe extern "C" fn(s: *mut MpegEncContext)>,
    /// Initialize the hwaccel private data.
    ///
    /// This will be called from ff_get_format(), after hwaccel and
    /// hwaccel_context are set and the hwaccel private data in AVCodecInternal
    /// is allocated.
    pub init: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> lang_items::c_int,
    >,
    /// Uninitialize the hwaccel private data.
    ///
    /// This will be called from get_format() or avcodec_close(), after hwaccel
    /// and hwaccel_context are already uninitialized.
    pub uninit: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> lang_items::c_int,
    >,
    /// Size of the private data to allocate in
    /// AVCodecInternal.hwaccel_priv_data.
    pub priv_data_size: lang_items::c_int,
    /// Internal hwaccel capabilities.
    pub caps_internal: lang_items::c_int,
    /// Fill the given hw_frames context with current codec parameters. Called
    /// from get_format. Refer to avcodec_get_hw_frames_parameters() for
    /// details.
    ///
    /// This CAN be called before AVHWAccel.init is called, and you must assume
    /// that avctx->hwaccel_priv_data is invalid.
    pub frame_params: std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, hw_frames_ctx: *mut AVBufferRef)
            -> lang_items::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    assert_eq!(
        std::mem::size_of::<AVHWAccel>(),
        112usize,
        concat!("Size of: ", stringify!(AVHWAccel))
    );
    assert_eq!(
        std::mem::align_of::<AVHWAccel>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWAccel))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).pix_fmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).capabilities as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).alloc_frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(alloc_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).start_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).decode_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_params)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).decode_slice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).end_frame as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).frame_priv_data_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).decode_mb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_mb)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).init as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).uninit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).priv_data_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).caps_internal as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVHWAccel>())).frame_params as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_params)
        )
    );
}
/// Picture data structure.
///
/// Up to four components can be stored into it, the last component is
/// alpha.
/// @deprecated use AVFrame or imgutils functions instead
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPicture {
    /// < pointers to the image data planes
    pub data: [*mut u8; 8usize],
    /// < number of bytes per line
    pub linesize: [lang_items::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_AVPicture() {
    assert_eq!(
        std::mem::size_of::<AVPicture>(),
        96usize,
        concat!("Size of: ", stringify!(AVPicture))
    );
    assert_eq!(
        std::mem::align_of::<AVPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPicture))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPicture>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPicture>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(linesize)
        )
    );
}
pub const AVSubtitleType_SUBTITLE_NONE: AVSubtitleType = 0;
/// < A bitmap, pict will be set
pub const AVSubtitleType_SUBTITLE_BITMAP: AVSubtitleType = 1;
/// Plain text, the text field must be set by the decoder and is
/// authoritative. ass and pict fields may contain approximations.
pub const AVSubtitleType_SUBTITLE_TEXT: AVSubtitleType = 2;
/// Formatted text, the ass field must be set by the decoder and is
/// authoritative. pict and text fields may contain approximations.
pub const AVSubtitleType_SUBTITLE_ASS: AVSubtitleType = 3;
pub type AVSubtitleType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitleRect {
    /// < top left corner  of pict, undefined when pict is not set
    pub x: lang_items::c_int,
    /// < top left corner  of pict, undefined when pict is not set
    pub y: lang_items::c_int,
    /// < width            of pict, undefined when pict is not set
    pub w: lang_items::c_int,
    /// < height           of pict, undefined when pict is not set
    pub h: lang_items::c_int,
    /// < number of colors in pict, undefined when pict is not set
    pub nb_colors: lang_items::c_int,
    /// @deprecated unused
    pub pict: AVPicture,
    /// data+linesize for the bitmap of this subtitle.
    /// Can be set for text/ass as well once they are rendered.
    pub data: [*mut u8; 4usize],
    pub linesize: [lang_items::c_int; 4usize],
    pub type_: AVSubtitleType,
    /// < 0 terminated plain UTF-8 text
    pub text: *mut lang_items::c_char,
    /// 0 terminated ASS/SSA compatible event line.
    /// The presentation of this is unaffected by the other values in this
    /// struct.
    pub ass: *mut lang_items::c_char,
    pub flags: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    assert_eq!(
        std::mem::size_of::<AVSubtitleRect>(),
        200usize,
        concat!("Size of: ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        std::mem::align_of::<AVSubtitleRect>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).nb_colors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(nb_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).pict as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(pict)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).linesize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).type_ as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).text as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).ass as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(ass)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitleRect>())).flags as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: lang_items::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    /// < Same as packet pts, in AV_TIME_BASE
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    assert_eq!(
        std::mem::size_of::<AVSubtitle>(),
        32usize,
        concat!("Size of: ", stringify!(AVSubtitle))
    );
    assert_eq!(
        std::mem::align_of::<AVSubtitle>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitle))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).start_display_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(start_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).end_display_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(end_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).num_rects as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).rects as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(rects)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVSubtitle>())).pts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(pts)
        )
    );
}
/// This struct describes the properties of an encoded stream.
///
/// sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
/// be allocated with avcodec_parameters_alloc() and freed with
/// avcodec_parameters_free().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParameters {
    /// General type of the encoded data.
    pub codec_type: AVMediaType,
    /// Specific type of the encoded data (the codec used).
    pub codec_id: AVCodecID,
    /// Additional information about the codec (corresponds to the AVI FOURCC).
    pub codec_tag: u32,
    /// Extra binary data needed for initializing the decoder, codec-dependent.
    ///
    /// Must be allocated with av_malloc() and will be freed by
    /// avcodec_parameters_free(). The allocated size of extradata must be at
    /// least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
    /// bytes zeroed.
    pub extradata: *mut u8,
    /// Size of the extradata content in bytes.
    pub extradata_size: lang_items::c_int,
    /// - video: the pixel format, the value corresponds to enum AVPixelFormat.
    /// - audio: the sample format, the value corresponds to enum AVSampleFormat.
    pub format: lang_items::c_int,
    /// The average bitrate of the encoded data (in bits per second).
    pub bit_rate: i64,
    /// The number of bits per sample in the codedwords.
    ///
    /// This is basically the bitrate per sample. It is mandatory for a bunch of
    /// formats to actually decode them. It's the number of bits for one sample in
    /// the actual coded bitstream.
    ///
    /// This could be for example 4 for ADPCM
    /// For PCM formats this matches bits_per_raw_sample
    /// Can be 0
    pub bits_per_coded_sample: lang_items::c_int,
    /// This is the number of valid bits in each output sample. If the
    /// sample format has more bits, the least significant bits are additional
    /// padding bits, which are always 0. Use right shifts to reduce the sample
    /// to its actual size. For example, audio formats with 24 bit samples will
    /// have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
    /// To get the original sample use "(int32_t)sample >> 8"."
    ///
    /// For ADPCM this might be 12 or 16 or similar
    /// Can be 0
    pub bits_per_raw_sample: lang_items::c_int,
    /// Codec-specific bitstream restrictions that the stream conforms to.
    pub profile: lang_items::c_int,
    pub level: lang_items::c_int,
    /// Video only. The dimensions of the video frame in pixels.
    pub width: lang_items::c_int,
    pub height: lang_items::c_int,
    /// Video only. The aspect ratio (width / height) which a single pixel
    /// should have when displayed.
    ///
    /// When the aspect ratio is unknown / undefined, the numerator should be
    /// set to 0 (the denominator may have any value).
    pub sample_aspect_ratio: AVRational,
    /// Video only. The order of the fields in interlaced video.
    pub field_order: AVFieldOrder,
    /// Video only. Additional colorspace characteristics.
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /// Video only. Number of delayed frames.
    pub video_delay: lang_items::c_int,
    /// Audio only. The channel layout bitmask. May be 0 if the channel layout is
    /// unknown or unspecified, otherwise the number of bits set must be equal to
    /// the channels field.
    pub channel_layout: u64,
    /// Audio only. The number of audio channels.
    pub channels: lang_items::c_int,
    /// Audio only. The number of audio samples per second.
    pub sample_rate: lang_items::c_int,
    /// Audio only. The number of bytes per coded audio frame, required by some
    /// formats.
    ///
    /// Corresponds to nBlockAlign in WAVEFORMATEX.
    pub block_align: lang_items::c_int,
    /// Audio only. Audio frame size, if known. Required by some formats to be static.
    pub frame_size: lang_items::c_int,
    /// Audio only. The amount of padding (in samples) inserted by the encoder at
    /// the beginning of the audio. I.e. this number of leading decoded samples
    /// must be discarded by the caller to get the original audio without leading
    /// padding.
    pub initial_padding: lang_items::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    pub trailing_padding: lang_items::c_int,
    /// Audio only. Number of samples to skip after a discontinuity.
    pub seek_preroll: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    assert_eq!(
        std::mem::size_of::<AVCodecParameters>(),
        144usize,
        concat!("Size of: ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).codec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).codec_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).codec_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).extradata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).extradata_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).format as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).bit_rate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).bits_per_coded_sample as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).bits_per_raw_sample as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).profile as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).level as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).sample_aspect_ratio as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).field_order as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).color_range as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).color_primaries as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).color_trc as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).color_space as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).chroma_location as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).video_delay as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(video_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).channel_layout as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).channels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).sample_rate as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).block_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).frame_size as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).initial_padding as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParameters>())).trailing_padding as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParameters>())).seek_preroll as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(seek_preroll)
        )
    );
}
extern "C" {
    /// Iterate over all registered codecs.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered codec or NULL when the iteration is
    /// finished
    pub fn av_codec_iterate(opaque: *mut *mut lang_items::c_void) -> *const AVCodec;
}
extern "C" {
    /// If c is NULL, returns the first registered codec,
    /// if c is non-NULL, returns the next registered codec after c,
    /// or NULL if c is the last one.
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    /// Return the LIBAVCODEC_VERSION_INT constant.
    pub fn avcodec_version() -> lang_items::c_uint;
}
extern "C" {
    /// Return the libavcodec build-time configuration.
    pub fn avcodec_configuration() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the libavcodec license.
    pub fn avcodec_license() -> *const lang_items::c_char;
}
extern "C" {
    /// Register the codec codec and initialize libavcodec.
    ///
    /// @warning either this function or avcodec_register_all() must be called
    /// before any other libavcodec functions.
    ///
    /// @see avcodec_register_all()
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    /// Register all the codecs, parsers and bitstream filters which were enabled at
    /// configuration time. If you do not call this function you can select exactly
    /// which formats you want to support, by using the individual registration
    /// functions.
    ///
    /// @see avcodec_register
    /// @see av_register_codec_parser
    /// @see av_register_bitstream_filter
    pub fn avcodec_register_all();
}
extern "C" {
    /// Allocate an AVCodecContext and set its fields to default values. The
    /// resulting struct should be freed with avcodec_free_context().
    ///
    /// @param codec if non-NULL, allocate private data and initialize defaults
    /// for the given codec. It is illegal to then call avcodec_open2()
    /// with a different codec.
    /// If NULL, then the codec-specific defaults won't be initialized,
    /// which may result in suboptimal default settings (this is
    /// important mainly for encoders, e.g. libx264).
    ///
    /// @return An AVCodecContext filled with default values or NULL on failure.
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    /// Free the codec context and everything associated with it and write NULL to
    /// the provided pointer.
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    /// @deprecated This function should not be used, as closing and opening a codec
    /// context multiple time is not supported. A new codec context should be
    /// allocated for each new use.
    pub fn avcodec_get_context_defaults3(
        s: *mut AVCodecContext,
        codec: *const AVCodec,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get the AVClass for AVCodecContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVFrame. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVSubtitleRect. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    /// Copy the settings of the source AVCodecContext into the destination
    /// AVCodecContext. The resulting destination codec context will be
    /// unopened, i.e. you are required to call avcodec_open2() before you
    /// can use this AVCodecContext to decode/encode video/audio data.
    ///
    /// @param dest target codec context, should be initialized with
    /// avcodec_alloc_context3(NULL), but otherwise uninitialized
    /// @param src source codec context
    /// @return AVERROR() on error (e.g. memory allocation error), 0 on success
    ///
    /// @deprecated The semantics of this function are ill-defined and it should not
    /// be used. If you need to transfer the stream parameters from one codec context
    /// to another, use an intermediate AVCodecParameters instance and the
    /// avcodec_parameters_from_context() / avcodec_parameters_to_context()
    /// functions.
    pub fn avcodec_copy_context(
        dest: *mut AVCodecContext,
        src: *const AVCodecContext,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate a new AVCodecParameters and set its fields to default values
    /// (unknown/invalid/0). The returned struct must be freed with
    /// avcodec_parameters_free().
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    /// Free an AVCodecParameters instance and everything associated with it and
    /// write NULL to the supplied pointer.
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    /// Copy the contents of src to dst. Any allocated fields in dst are freed and
    /// replaced with newly allocated duplicates of the corresponding fields in src.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill the parameters struct based on the values from the supplied codec
    /// context. Any allocated fields in par are freed and replaced with duplicates
    /// of the corresponding fields in codec.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill the codec context based on the values from the supplied codec
    /// parameters. Any allocated fields in codec that have a corresponding field in
    /// par are freed and replaced with duplicates of the corresponding field in par.
    /// Fields in codec that do not have a counterpart in par are not touched.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Initialize the AVCodecContext to use the given AVCodec. Prior to using this
    /// function the context has to be allocated with avcodec_alloc_context3().
    ///
    /// The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
    /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
    /// retrieving a codec.
    ///
    /// @warning This function is not thread safe!
    ///
    /// @note Always call this function before using decoding routines (such as
    /// @ref avcodec_receive_frame()).
    ///
    /// @code
    /// avcodec_register_all();
    /// av_dict_set(&opts, "b", "2.5M", 0);
    /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    /// if (!codec)
    /// exit(1);
    ///
    /// context = avcodec_alloc_context3(codec);
    ///
    /// if (avcodec_open2(context, codec, opts) < 0)
    /// exit(1);
    /// @endcode
    ///
    /// @param avctx The context to initialize.
    /// @param codec The codec to open this context for. If a non-NULL codec has been
    /// previously passed to avcodec_alloc_context3() or
    /// for this context, then this parameter MUST be either NULL or
    /// equal to the previously passed codec.
    /// @param options A dictionary filled with AVCodecContext and codec-private options.
    /// On return this object will be filled with options that were not found.
    ///
    /// @return zero on success, a negative value on error
    /// @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
    /// av_dict_set(), av_opt_find().
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Close a given AVCodecContext and free all the data associated with it
    /// (but not the AVCodecContext itself).
    ///
    /// Calling this function on an AVCodecContext that hasn't been opened will free
    /// the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
    /// codec. Subsequent calls will do nothing.
    ///
    /// @note Do not use this function. Use avcodec_free_context() to destroy a
    /// codec context (either open or closed). Opening and closing a codec context
    /// multiple times is not supported anymore -- use multiple codec contexts
    /// instead.
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> lang_items::c_int;
}
extern "C" {
    /// Free all allocated data in the given subtitle struct.
    ///
    /// @param sub AVSubtitle to free.
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    /// Allocate an AVPacket and set its fields to default values.  The resulting
    /// struct must be freed using av_packet_free().
    ///
    /// @return An AVPacket filled with default values or NULL on failure.
    ///
    /// @note this only allocates the AVPacket itself, not the data buffers. Those
    /// must be allocated through other means such as av_new_packet.
    ///
    /// @see av_new_packet
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    /// Create a new packet that references the same data as src.
    ///
    /// This is a shortcut for av_packet_alloc()+av_packet_ref().
    ///
    /// @return newly created AVPacket on success, NULL on error.
    ///
    /// @see av_packet_alloc
    /// @see av_packet_ref
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    /// Free the packet, if the packet is reference counted, it will be
    /// unreferenced first.
    ///
    /// @param pkt packet to be freed. The pointer will be set to NULL.
    /// @note passing NULL is a no-op.
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    /// Initialize optional fields of a packet with default values.
    ///
    /// Note, this does not touch the data and size members, which have to be
    /// initialized separately.
    ///
    /// @param pkt packet
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate the payload of a packet and initialize its fields with
    /// default values.
    ///
    /// @param pkt packet
    /// @param size wanted payload size
    /// @return 0 if OK, AVERROR_xxx otherwise
    pub fn av_new_packet(pkt: *mut AVPacket, size: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Reduce packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param size new size
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: lang_items::c_int);
}
extern "C" {
    /// Increase packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param grow_by number of bytes by which to increase the size of the packet
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Initialize a reference-counted packet from av_malloc()ed data.
    ///
    /// @param pkt packet to be initialized. This function will set the data, size,
    /// buf and destruct fields, all others are left untouched.
    /// @param data Data allocated by av_malloc() to be used as packet data. If this
    /// function returns successfully, the data is owned by the underlying AVBuffer.
    /// The caller may not access the data through other means.
    /// @param size size of data in bytes, without the padding. I.e. the full buffer
    /// size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
    ///
    /// @return 0 on success, a negative AVERROR on error
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @warning This is a hack - the packet memory allocation stuff is broken. The
    /// packet is allocated if it was not really allocated.
    ///
    /// @deprecated Use av_packet_ref or av_packet_make_refcounted
    pub fn av_dup_packet(pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Copy packet, including contents
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_ref
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Copy packet side data
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_copy_props
    pub fn av_copy_packet_side_data(dst: *mut AVPacket, src: *const AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Free a packet.
    ///
    /// @deprecated Use av_packet_unref
    ///
    /// @param pkt packet to free
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate new information of a packet.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size side information size
    /// @return pointer to fresh allocated data or NULL otherwise
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: lang_items::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Wrap an existing array as a packet side data.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param data the side data array. It must be allocated with the av_malloc()
    /// family of functions. The ownership of the data is transferred to
    /// pkt.
    /// @param size side information size
    /// @return a non-negative number on success, a negative AVERROR code on
    /// failure. On failure, the packet is unchanged and the data remains
    /// owned by the caller.
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Shrink the already allocated side data buffer
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size new side information size
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get side information from packet.
    ///
    /// @param pkt packet
    /// @param type desired side information type
    /// @param size pointer for side information size to store (optional)
    /// @return pointer to data if present or NULL otherwise
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut lang_items::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const lang_items::c_char;
}
extern "C" {
    /// Pack a dictionary for use in side_data.
    ///
    /// @param dict The dictionary to pack.
    /// @param size pointer to store the size of the returned data
    /// @return pointer to data if successful, NULL otherwise
    pub fn av_packet_pack_dictionary(
        dict: *mut AVDictionary,
        size: *mut lang_items::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Unpack a dictionary from side_data.
    ///
    /// @param data data from side_data
    /// @param size size of the data
    /// @param dict the metadata storage dictionary
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: lang_items::c_int,
        dict: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Convenience function to free all the side data stored.
    /// All the other fields stay untouched.
    ///
    /// @param pkt packet
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    /// Setup a new reference to the data described by a given packet
    ///
    /// If src is reference-counted, setup dst as a new reference to the
    /// buffer in src. Otherwise allocate a new buffer in dst and copy the
    /// data from src into it.
    ///
    /// All the other fields are copied from src.
    ///
    /// @see av_packet_unref
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Wipe the packet.
    ///
    /// Unreference the buffer referenced by the packet and reset the
    /// remaining packet fields to their default values.
    ///
    /// @param pkt The packet to be unreferenced.
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    /// Move every field in src to dst and reset src.
    ///
    /// @see av_packet_unref
    ///
    /// @param src Source packet, will be reset
    /// @param dst Destination packet
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    /// Copy only "properties" fields from src to dst.
    ///
    /// Properties for the purpose of this function are all the fields
    /// beside those related to the packet data (buf, data, size)
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success AVERROR on failure.
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Ensure the data described by a given packet is reference counted.
    ///
    /// @note This function does not ensure that the reference will be writable.
    /// Use av_packet_make_writable instead for that purpose.
    ///
    /// @see av_packet_ref
    /// @see av_packet_make_writable
    ///
    /// @param pkt packet whose data should be made reference counted.
    ///
    /// @return 0 on success, a negative AVERROR on error. On failure, the
    /// packet is unchanged.
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Create a writable reference for the data described by a given packet,
    /// avoiding data copy if possible.
    ///
    /// @param pkt Packet whose data should be made writable.
    ///
    /// @return 0 on success, a negative AVERROR on failure. On failure, the
    /// packet is unchanged.
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Convert valid timing fields (timestamps / durations) in a packet from one
    /// timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
    /// ignored.
    ///
    /// @param pkt packet on which the conversion will be performed
    /// @param tb_src source timebase, in which the timing fields in pkt are
    /// expressed
    /// @param tb_dst destination timebase, to which the timing fields will be
    /// converted
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
extern "C" {
    /// Find a registered decoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered decoder with the specified name.
    ///
    /// @param name name of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder_by_name(name: *const lang_items::c_char) -> *mut AVCodec;
}
extern "C" {
    /// The default callback for AVCodecContext.get_buffer2(). It is made public so
    /// it can be called by custom get_buffer2() implementations for decoders without
    /// AV_CODEC_CAP_DR1 set.
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you do not use any horizontal
    /// padding.
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut lang_items::c_int,
        height: *mut lang_items::c_int,
    );
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you also ensure that all
    /// line sizes are a multiple of the respective linesize_align[i].
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut lang_items::c_int,
        height: *mut lang_items::c_int,
        linesize_align: *mut lang_items::c_int,
    );
}
extern "C" {
    /// Converts AVChromaLocation to swscale x/y chroma position.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut lang_items::c_int,
        ypos: *mut lang_items::c_int,
        pos: AVChromaLocation,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Converts swscale x/y chroma position to AVChromaLocation.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_chroma_pos_to_enum(
        xpos: lang_items::c_int,
        ypos: lang_items::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
    ///
    /// Some decoders may support multiple frames in a single AVPacket. Such
    /// decoders would then just decode the first frame and the return value would be
    /// less than the packet size. In this case, avcodec_decode_audio4 has to be
    /// called again with an AVPacket containing the remaining data in order to
    /// decode the second frame, etc...  Even if no frames are returned, the packet
    /// needs to be fed to the decoder with remaining data until it is completely
    /// consumed or an error occurs.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning samples. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    /// larger than the actual read bytes because some optimized bitstream
    /// readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param      avctx the codec context
    /// @param[out] frame The AVFrame in which to store decoded audio samples.
    /// The decoder will allocate a buffer for the decoded frame by
    /// calling the AVCodecContext.get_buffer2() callback.
    /// When AVCodecContext.refcounted_frames is set to 1, the frame is
    /// reference counted and the returned reference belongs to the
    /// caller. The caller must release the frame using av_frame_unref()
    /// when the frame is no longer needed. The caller may safely write
    /// to the frame if av_frame_is_writable() returns 1.
    /// When AVCodecContext.refcounted_frames is set to 0, the returned
    /// reference belongs to the decoder and is valid only until the
    /// next call to this function or until closing or flushing the
    /// decoder. The caller may not write to it.
    /// @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
    /// non-zero. Note that this field being set to zero
    /// does not mean that an error has occurred. For
    /// decoders with AV_CODEC_CAP_DELAY set, no given decode
    /// call is guaranteed to produce a frame.
    /// @param[in]  avpkt The input AVPacket containing the input buffer.
    /// At least avpkt->data and avpkt->size should be set. Some
    /// decoders might also require additional fields to be set.
    /// @return A negative error code is returned if an error occurred during
    /// decoding, otherwise the number of bytes consumed from the input
    /// AVPacket is returned.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_audio4(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
        got_frame_ptr: *mut lang_items::c_int,
        avpkt: *const AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Decode the video frame of size avpkt->size from avpkt->data into picture.
    /// Some decoders may support multiple frames in a single AVPacket, such
    /// decoders would then just decode the first frame.
    ///
    /// @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
    /// the actual read bytes because some optimized bitstream readers read 32 or 64
    /// bits at once and could read over the end.
    ///
    /// @warning The end of the input buffer buf should be set to 0 to ensure that
    /// no overreading happens for damaged MPEG streams.
    ///
    /// @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
    /// between input and output, these need to be fed with avpkt->data=NULL,
    /// avpkt->size=0 at the end to return the remaining frames.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] picture The AVFrame in which the decoded video frame will be stored.
    /// Use av_frame_alloc() to get an AVFrame. The codec will
    /// allocate memory for the actual bitmap by calling the
    /// AVCodecContext.get_buffer2() callback.
    /// When AVCodecContext.refcounted_frames is set to 1, the frame is
    /// reference counted and the returned reference belongs to the
    /// caller. The caller must release the frame using av_frame_unref()
    /// when the frame is no longer needed. The caller may safely write
    /// to the frame if av_frame_is_writable() returns 1.
    /// When AVCodecContext.refcounted_frames is set to 0, the returned
    /// reference belongs to the decoder and is valid only until the
    /// next call to this function or until closing or flushing the
    /// decoder. The caller may not write to it.
    ///
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    /// You can create such packet with av_init_packet() and by then setting
    /// data and size, some decoders might in addition need other fields like
    /// flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
    /// fields possible.
    /// @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
    /// @return On error a negative value is returned, otherwise the number of bytes
    /// used or zero if no frame could be decompressed.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_video2(
        avctx: *mut AVCodecContext,
        picture: *mut AVFrame,
        got_picture_ptr: *mut lang_items::c_int,
        avpkt: *const AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Decode a subtitle message.
    /// Return a negative value on error, otherwise return the number of bytes used.
    /// If no subtitle could be decompressed, got_sub_ptr is zero.
    /// Otherwise, the subtitle is stored in *sub.
    /// Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
    /// simplicity, because the performance difference is expect to be negligible
    /// and reusing a get_buffer written for video codecs would probably perform badly
    /// due to a potentially very different allocation pattern.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning subtitles. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
    /// must be freed with avsubtitle_free if *got_sub_ptr is set.
    /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut lang_items::c_int,
        avpkt: *mut AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Supply raw packet data as input to a decoder.
    ///
    /// Internally, this call will copy relevant AVCodecContext fields, which can
    /// influence decoding per-packet, and apply them when the packet is actually
    /// decoded. (For example AVCodecContext.skip_frame, which might direct the
    /// decoder to drop the frame contained by the packet sent with this function.)
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    /// larger than the actual read bytes because some optimized bitstream
    /// readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
    /// on the same AVCodecContext. It will return unexpected results now
    /// or in future libavcodec versions.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx codec context
    /// @param[in] avpkt The input AVPacket. Usually, this will be a single video
    /// frame, or several complete audio frames.
    /// Ownership of the packet remains with the caller, and the
    /// decoder will not write to the packet. The decoder may create
    /// a reference to the packet data (or copy it if the packet is
    /// not reference-counted).
    /// Unlike with older APIs, the packet is always fully consumed,
    /// and if it contains multiple frames (e.g. some audio codecs),
    /// will require you to call avcodec_receive_frame() multiple
    /// times afterwards before you can send a new packet.
    /// It can be NULL (or an AVPacket with data set to NULL and
    /// size set to 0); in this case, it is considered a flush
    /// packet, which signals the end of the stream. Sending the
    /// first flush packet will return success. Subsequent ones are
    /// unnecessary and will return AVERROR_EOF. If the decoder
    /// still has frames buffered, it will return them after sending
    /// a flush packet.
    ///
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   input is not accepted in the current state - user
    /// must read output with avcodec_receive_frame() (once
    /// all output is read, the packet should be resent, and
    /// the call will not fail with EAGAIN).
    /// AVERROR_EOF:       the decoder has been flushed, and no new packets can
    /// be sent to it (also returned if more than 1 flush
    /// packet is sent)
    /// AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
    /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    /// other errors: legitimate decoding errors
    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return decoded output data from a decoder.
    ///
    /// @param avctx codec context
    /// @param frame This will be set to a reference-counted video or audio
    /// frame (depending on the decoder type) allocated by the
    /// decoder. Note that the function will always call
    /// av_frame_unref(frame) before doing anything else.
    ///
    /// @return
    /// 0:                 success, a frame was returned
    /// AVERROR(EAGAIN):   output is not available in this state - user must try
    /// to send new input
    /// AVERROR_EOF:       the decoder has been fully flushed, and there will be
    /// no more output frames
    /// AVERROR(EINVAL):   codec not opened, or it is an encoder
    /// other negative values: legitimate decoding errors
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
    /// to retrieve buffered output packets.
    ///
    /// @param avctx     codec context
    /// @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
    /// Ownership of the frame remains with the caller, and the
    /// encoder will not write to the frame. The encoder may create
    /// a reference to the frame data (or copy it if the frame is
    /// not reference-counted).
    /// It can be NULL, in which case it is considered a flush
    /// packet.  This signals the end of the stream. If the encoder
    /// still has packets buffered, it will return them after this
    /// call. Once flushing mode has been entered, additional flush
    /// packets are ignored, and sending frames will return
    /// AVERROR_EOF.
    ///
    /// For audio:
    /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    /// can have any number of samples.
    /// If it is not set, frame->nb_samples must be equal to
    /// avctx->frame_size for all frames except the last.
    /// The final frame may be smaller than avctx->frame_size.
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   input is not accepted in the current state - user
    /// must read output with avcodec_receive_packet() (once
    /// all output is read, the packet should be resent, and
    /// the call will not fail with EAGAIN).
    /// AVERROR_EOF:       the encoder has been flushed, and no new frames can
    /// be sent to it
    /// AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
    /// decoder, or requires flush
    /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    /// other errors: legitimate decoding errors
    pub fn avcodec_send_frame(
        avctx: *mut AVCodecContext,
        frame: *const AVFrame,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Read encoded data from the encoder.
    ///
    /// @param avctx codec context
    /// @param avpkt This will be set to a reference-counted packet allocated by the
    /// encoder. Note that the function will always call
    /// av_frame_unref(frame) before doing anything else.
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   output is not available in the current state - user
    /// must try to send input
    /// AVERROR_EOF:       the encoder has been fully flushed, and there will be
    /// no more output packets
    /// AVERROR(EINVAL):   codec not opened, or it is an encoder
    /// other errors: legitimate decoding errors
    pub fn avcodec_receive_packet(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Create and return a AVHWFramesContext with values adequate for hardware
    /// decoding. This is meant to get called from the get_format callback, and is
    /// a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
    /// This API is for decoding with certain hardware acceleration modes/APIs only.
    ///
    /// The returned AVHWFramesContext is not initialized. The caller must do this
    /// with av_hwframe_ctx_init().
    ///
    /// Calling this function is not a requirement, but makes it simpler to avoid
    /// codec or hardware API specific details when manually allocating frames.
    ///
    /// Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
    /// which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
    /// it unnecessary to call this function or having to care about
    /// AVHWFramesContext initialization at all.
    ///
    /// There are a number of requirements for calling this function:
    ///
    /// - It must be called from get_format with the same avctx parameter that was
    /// passed to get_format. Calling it outside of get_format is not allowed, and
    /// can trigger undefined behavior.
    /// - The function is not always supported (see description of return values).
    /// Even if this function returns successfully, hwaccel initialization could
    /// fail later. (The degree to which implementations check whether the stream
    /// is actually supported varies. Some do this check only after the user's
    /// get_format callback returns.)
    /// - The hw_pix_fmt must be one of the choices suggested by get_format. If the
    /// user decides to use a AVHWFramesContext prepared with this API function,
    /// the user must return the same hw_pix_fmt from get_format.
    /// - The device_ref passed to this function must support the given hw_pix_fmt.
    /// - After calling this API function, it is the user's responsibility to
    /// initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
    /// and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
    /// before returning from get_format (this is implied by the normal
    /// AVCodecContext.hw_frames_ctx API rules).
    /// - The AVHWFramesContext parameters may change every time time get_format is
    /// called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
    /// you are inherently required to go through this process again on every
    /// get_format call.
    /// - It is perfectly possible to call this function without actually using
    /// the resulting AVHWFramesContext. One use-case might be trying to reuse a
    /// previously initialized AVHWFramesContext, and calling this API function
    /// only to test whether the required frame parameters have changed.
    /// - Fields that use dynamically allocated values of any kind must not be set
    /// by the user unless setting them is explicitly allowed by the documentation.
    /// If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
    /// the new free callback must call the potentially set previous free callback.
    /// This API call may set any dynamically allocated fields, including the free
    /// callback.
    ///
    /// The function will set at least the following fields on AVHWFramesContext
    /// (potentially more, depending on hwaccel API):
    ///
    /// - All fields set by av_hwframe_ctx_alloc().
    /// - Set the format field to hw_pix_fmt.
    /// - Set the sw_format field to the most suited and most versatile format. (An
    /// implication is that this will prefer generic formats over opaque formats
    /// with arbitrary restrictions, if possible.)
    /// - Set the width/height fields to the coded frame size, rounded up to the
    /// API-specific minimum alignment.
    /// - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
    /// field to the number of maximum reference surfaces possible with the codec,
    /// plus 1 surface for the user to work (meaning the user can safely reference
    /// at most 1 decoded surface at a time), plus additional buffering introduced
    /// by frame threading. If the hwaccel does not require pre-allocation, the
    /// field is left to 0, and the decoder will allocate new surfaces on demand
    /// during decoding.
    /// - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
    /// hardware API.
    ///
    /// Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
    /// with basic frame parameters set.
    ///
    /// The function is stateless, and does not change the AVCodecContext or the
    /// device_ref AVHWDeviceContext.
    ///
    /// @param avctx The context which is currently calling get_format, and which
    /// implicitly contains all state needed for filling the returned
    /// AVHWFramesContext properly.
    /// @param device_ref A reference to the AVHWDeviceContext describing the device
    /// which will be used by the hardware decoder.
    /// @param hw_pix_fmt The hwaccel format you are going to return from get_format.
    /// @param out_frames_ref On success, set to a reference to an _uninitialized_
    /// AVHWFramesContext, created from the given device_ref.
    /// Fields will be set to values required for decoding.
    /// Not changed if an error is returned.
    /// @return zero on success, a negative value on error. The following error codes
    /// have special semantics:
    /// AVERROR(ENOENT): the decoder does not support this functionality. Setup
    /// is always manual, or it is a decoder which does not
    /// support setting AVCodecContext.hw_frames_ctx at all,
    /// or it is a software format.
    /// AVERROR(EINVAL): it is known that hardware decoding is not supported for
    /// this configuration, or the device_ref is not supported
    /// for the hwaccel referenced by hw_pix_fmt.
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> lang_items::c_int;
}
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_UNKNOWN: AVPictureStructure = 0;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_TOP_FIELD: AVPictureStructure = 1;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_BOTTOM_FIELD: AVPictureStructure = 2;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_FRAME: AVPictureStructure = 3;
/// @defgroup lavc_parsing Frame parsing
/// @{
pub type AVPictureStructure = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParserContext {
    pub priv_data: *mut lang_items::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: lang_items::c_int,
    /// This field is used for proper frame duration computation in lavf.
    /// It signals, how much longer the frame duration of the current frame
    /// is compared to normal frame duration.
    ///
    /// frame_duration = (1 + repeat_pict) * time_base
    ///
    /// It is used by codecs like H.264 to display telecined material.
    pub repeat_pict: lang_items::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: lang_items::c_int,
    pub cur_frame_start_index: lang_items::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: lang_items::c_int,
    /// < byte offset from starting packet start
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    /// Set by parser to 1 for key frames and 0 for non-key frames.
    /// It is initialized to -1, so if the parser doesn't set this flag,
    /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
    /// will be used.
    pub key_frame: lang_items::c_int,
    /// @deprecated unused
    pub convergence_duration: i64,
    /// Synchronization point for start of timestamp generation.
    ///
    /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
    /// (default).
    ///
    /// For example, this corresponds to presence of H.264 buffering period
    /// SEI message.
    pub dts_sync_point: lang_items::c_int,
    /// Offset of the current timestamp against last timestamp sync point in
    /// units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain a valid timestamp offset.
    ///
    /// Note that the timestamp of sync point has usually a nonzero
    /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
    /// the next frame after timestamp sync point will be usually 1.
    ///
    /// For example, this corresponds to H.264 cpb_removal_delay.
    pub dts_ref_dts_delta: lang_items::c_int,
    /// Presentation delay of current frame in units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain valid non-negative timestamp delta (presentation time of a frame
    /// must not lie in the past).
    ///
    /// This delay represents the difference between decoding and presentation
    /// time of the frame.
    ///
    /// For example, this corresponds to H.264 dpb_output_delay.
    pub pts_dts_delta: lang_items::c_int,
    /// Position of the packet in file.
    ///
    /// Analogous to cur_frame_pts/dts
    pub cur_frame_pos: [i64; 4usize],
    /// Byte position of currently parsed frame in stream.
    pub pos: i64,
    /// Previous frame byte position.
    pub last_pos: i64,
    /// Duration of the current frame.
    /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
    /// For all other types, this is in units of AVCodecContext.time_base.
    pub duration: lang_items::c_int,
    pub field_order: AVFieldOrder,
    /// Indicate whether a picture is coded as a frame, top field or bottom field.
    ///
    /// For example, H.264 field_pic_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
    /// equal to 1 and bottom_field_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_TOP_FIELD.
    pub picture_structure: AVPictureStructure,
    /// Picture number incremented in presentation or output order.
    /// This field may be reinitialized at the first picture of a new sequence.
    ///
    /// For example, this corresponds to H.264 PicOrderCnt.
    pub output_picture_number: lang_items::c_int,
    /// Dimensions of the decoded video intended for presentation.
    pub width: lang_items::c_int,
    pub height: lang_items::c_int,
    /// Dimensions of the coded video.
    pub coded_width: lang_items::c_int,
    pub coded_height: lang_items::c_int,
    /// The format of the coded data, corresponds to enum AVPixelFormat for video
    /// and for enum AVSampleFormat for audio.
    ///
    /// Note that a decoder can have considerable freedom in how exactly it
    /// decodes the data, so the format reported here might be different from the
    /// one returned by a decoder.
    pub format: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    assert_eq!(
        std::mem::size_of::<AVCodecParserContext>(),
        352usize,
        concat!("Size of: ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).priv_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).parser as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).frame_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_offset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).next_frame_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(next_frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).pict_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).repeat_pict as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).pts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).dts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).last_pts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).last_dts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).fetch_timestamp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(fetch_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_start_index as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_offset as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_pts as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_dts as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).flags as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).offset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_end as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_end)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).key_frame as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).convergence_duration as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(convergence_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).dts_sync_point as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_sync_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).dts_ref_dts_delta as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_ref_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).pts_dts_delta as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).cur_frame_pos as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).pos as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).last_pos as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).duration as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).field_order as *const _ as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).picture_structure as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).output_picture_number as *const _
                as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(output_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).width as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).height as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).coded_width as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVCodecParserContext>())).coded_height as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParserContext>())).format as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParser {
    pub codec_ids: [lang_items::c_int; 5usize],
    pub priv_data_size: lang_items::c_int,
    pub parser_init: std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecParserContext) -> lang_items::c_int,
    >,
    pub parser_parse: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut lang_items::c_int,
            buf: *const u8,
            buf_size: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub parser_close: std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub next: *mut AVCodecParser,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    assert_eq!(
        std::mem::size_of::<AVCodecParser>(),
        64usize,
        concat!("Size of: ", stringify!(AVCodecParser))
    );
    assert_eq!(
        std::mem::align_of::<AVCodecParser>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParser))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).codec_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).priv_data_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).parser_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_init)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).parser_parse as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).parser_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_close)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).split as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVCodecParser>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    /// Iterate over all registered codec parsers.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered codec parser or NULL when the iteration is
    /// finished
    pub fn av_parser_iterate(opaque: *mut *mut lang_items::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: lang_items::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    /// Parse a packet.
    ///
    /// @param s             parser context.
    /// @param avctx         codec context.
    /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
    /// @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
    /// @param buf           input buffer.
    /// @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
    /// size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
    /// To signal EOF, this should be 0 (so that the last frame
    /// can be output).
    /// @param pts           input presentation timestamp.
    /// @param dts           input decoding timestamp.
    /// @param pos           input byte position in stream.
    /// @return the number of bytes of the input bitstream used.
    ///
    /// Example:
    /// @code
    /// while(in_len){
    /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
    /// in_data, in_len,
    /// pts, dts, pos);
    /// in_data += len;
    /// in_len  -= len;
    ///
    /// if(size)
    /// decode_frame(data, size);
    /// }
    /// @endcode
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut lang_items::c_int,
        buf: *const u8,
        buf_size: lang_items::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
    /// @deprecated use AVBitStreamFilter
    pub fn av_parser_change(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut lang_items::c_int,
        buf: *const u8,
        buf_size: lang_items::c_int,
        keyframe: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    /// Find a registered encoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered encoder with the specified name.
    ///
    /// @param name name of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder_by_name(name: *const lang_items::c_char) -> *mut AVCodec;
}
extern "C" {
    /// Encode a frame of audio.
    ///
    /// Takes input samples from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay, split, and combine input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    /// The user can supply an output buffer by setting
    /// avpkt->data and avpkt->size prior to calling the
    /// function, but if the size of the user-provided data is not
    /// large enough, encoding will fail. If avpkt->data and
    /// avpkt->size are set, avpkt->destruct must also be set. All
    /// other AVPacket fields will be reset by the encoder using
    /// av_init_packet(). If avpkt->data is NULL, the encoder will
    /// allocate it. The encoder will set avpkt->size to the size
    /// of the output packet.
    ///
    /// If this function fails or produces no output, avpkt will be
    /// freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw audio data to be encoded.
    /// May be NULL when flushing an encoder that has the
    /// AV_CODEC_CAP_DELAY capability set.
    /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    /// can have any number of samples.
    /// If it is not set, frame->nb_samples must be equal to
    /// avctx->frame_size for all frames except the last.
    /// The final frame may be smaller than avctx->frame_size.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    /// output packet is non-empty, and to 0 if it is
    /// empty. If the function returns an error, the
    /// packet can be assumed to be invalid, and the
    /// value of got_packet_ptr is undefined and should
    /// not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_audio2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Encode a frame of video.
    ///
    /// Takes input raw video data from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay and reorder input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    /// The user can supply an output buffer by setting
    /// avpkt->data and avpkt->size prior to calling the
    /// function, but if the size of the user-provided data is not
    /// large enough, encoding will fail. All other AVPacket fields
    /// will be reset by the encoder using av_init_packet(). If
    /// avpkt->data is NULL, the encoder will allocate it.
    /// The encoder will set avpkt->size to the size of the
    /// output packet. The returned data (if any) belongs to the
    /// caller, he is responsible for freeing it.
    ///
    /// If this function fails or produces no output, avpkt will be
    /// freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw video data to be encoded.
    /// May be NULL when flushing an encoder that has the
    /// AV_CODEC_CAP_DELAY capability set.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    /// output packet is non-empty, and to 0 if it is
    /// empty. If the function returns an error, the
    /// packet can be assumed to be invalid, and the
    /// value of got_packet_ptr is undefined and should
    /// not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_video2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: lang_items::c_int,
        sub: *const AVSubtitle,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_alloc(
        picture: *mut AVPicture,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    /// @deprecated use av_image_fill_arrays() instead.
    pub fn avpicture_fill(
        picture: *mut AVPicture,
        ptr: *const u8,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated use av_image_copy_to_buffer() instead.
    pub fn avpicture_layout(
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
        dest: *mut lang_items::c_uchar,
        dest_size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated use av_image_get_buffer_size() instead.
    pub fn avpicture_get_size(
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated av_image_copy() instead.
    pub fn av_picture_copy(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: lang_items::c_int,
        height: lang_items::c_int,
    );
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_crop(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        top_band: lang_items::c_int,
        left_band: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_pad(
        dst: *mut AVPicture,
        src: *const AVPicture,
        height: lang_items::c_int,
        width: lang_items::c_int,
        pix_fmt: AVPixelFormat,
        padtop: lang_items::c_int,
        padbottom: lang_items::c_int,
        padleft: lang_items::c_int,
        padright: lang_items::c_int,
        color: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated Use av_pix_fmt_get_chroma_sub_sample
    pub fn avcodec_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut lang_items::c_int,
        v_shift: *mut lang_items::c_int,
    );
}
extern "C" {
    /// Return a value representing the fourCC code associated to the
    /// pixel format pix_fmt, or 0 if no associated fourCC code can be
    /// found.
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> lang_items::c_uint;
}
extern "C" {
    /// @deprecated see av_get_pix_fmt_loss()
    pub fn avcodec_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Find the best pixel format to convert to given a certain source pixel
    /// format.  When converting from one pixel format to another, information loss
    /// may occur.  For example, when converting from RGB24 to GRAY, the color
    /// information will be lost. Similarly, other losses occur when converting from
    /// some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
    /// the given pixel formats should be used to suffer the least amount of loss.
    /// The pixel formats from which it chooses one, are determined by the
    /// pix_fmt_list parameter.
    ///
    ///
    /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
    /// @return The best pixel format to convert to or -1 if none was found.
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
        loss_ptr: *mut lang_items::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    /// @deprecated see av_find_best_pix_fmt_of_2()
    pub fn avcodec_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
        loss_ptr: *mut lang_items::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: lang_items::c_int,
        loss_ptr: *mut lang_items::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    /// Put a string representing the codec tag codec_tag in buf.
    ///
    /// @param buf       buffer to place codec tag in
    /// @param buf_size size in bytes of buf
    /// @param codec_tag codec tag to assign
    /// @return the length of the string that would have been generated if
    /// enough space had been available, excluding the trailing null
    ///
    /// @deprecated see av_fourcc_make_string() and av_fourcc2str().
    pub fn av_get_codec_tag_string(
        buf: *mut lang_items::c_char,
        buf_size: usize,
        codec_tag: lang_items::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn avcodec_string(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        enc: *mut AVCodecContext,
        encode: lang_items::c_int,
    );
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec the codec that is searched for the given profile
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    pub fn av_get_profile_name(
        codec: *const AVCodec,
        profile: lang_items::c_int,
    ) -> *const lang_items::c_char;
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec_id the ID of the codec to which the requested profile belongs
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    ///
    /// @note unlike av_get_profile_name(), which searches a list of profiles
    /// supported by a specific decoder or encoder implementation, this
    /// function searches the list of profiles from the AVCodecDescriptor
    pub fn avcodec_profile_name(
        codec_id: AVCodecID,
        profile: lang_items::c_int,
    ) -> *const lang_items::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: std::option::Option<
            unsafe extern "C" fn(c2: *mut AVCodecContext, arg2: *mut lang_items::c_void)
                -> lang_items::c_int,
        >,
        arg: *mut lang_items::c_void,
        ret: *mut lang_items::c_int,
        count: lang_items::c_int,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut lang_items::c_void,
                arg1: lang_items::c_int,
                arg2: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        arg: *mut lang_items::c_void,
        ret: *mut lang_items::c_int,
        count: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Fill AVFrame audio data and linesize pointers.
    ///
    /// The buffer buf must be a preallocated buffer with a size big enough
    /// to contain the specified samples amount. The filled AVFrame data
    /// pointers will point to this buffer.
    ///
    /// AVFrame extended_data channel pointers are allocated if necessary for
    /// planar audio.
    ///
    /// @param frame       the AVFrame
    /// frame->nb_samples must be set prior to calling the
    /// function. This function fills in frame->data,
    /// frame->extended_data, frame->linesize[0].
    /// @param nb_channels channel count
    /// @param sample_fmt  sample format
    /// @param buf         buffer to use for frame data
    /// @param buf_size    size of buffer
    /// @param align       plane size sample alignment (0 = default)
    /// @return            >=0 on success, negative error code on failure
    /// @todo return the size in bytes required to store the samples in
    /// case of success, at the next libavutil bump
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: lang_items::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: lang_items::c_int,
        align: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Reset the internal decoder state / flush internal buffers. Should be called
    /// e.g. when seeking or when switching to a different stream.
    ///
    /// @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),
    /// this invalidates the frames previously returned from the decoder. When
    /// refcounted frames are used, the decoder just releases any references it might
    /// keep internally, but the caller's reference remains valid.
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    /// Return codec bits per sample.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> lang_items::c_int;
}
extern "C" {
    /// Return the PCM codec associated with a sample format.
    /// @param be  endianness, 0 for little, 1 for big,
    /// -1 (or anything else) for native
    /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: lang_items::c_int) -> AVCodecID;
}
extern "C" {
    /// Return codec bits per sample.
    /// Only return non-zero if the bits per sample is exactly correct, not an
    /// approximation.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> lang_items::c_int;
}
extern "C" {
    /// Return audio frame duration.
    ///
    /// @param avctx        codec context
    /// @param frame_bytes  size of the frame, or 0 if unknown
    /// @return             frame duration, in samples, if known. 0 if not able to
    /// determine.
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// This function is the same as av_get_audio_frame_duration(), except it works
    /// with AVCodecParameters instead of an AVCodecContext.
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: lang_items::c_int,
    ) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut lang_items::c_void,
    pub filter: *const AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    /// Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
    /// Not for access by library users.
    pub args: *mut lang_items::c_char,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilterContext() {
    assert_eq!(
        std::mem::size_of::<AVBitStreamFilterContext>(),
        40usize,
        concat!("Size of: ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        std::mem::align_of::<AVBitStreamFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVBitStreamFilterContext>())).priv_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVBitStreamFilterContext>())).filter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVBitStreamFilterContext>())).parser as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilterContext>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilterContext>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
/// The bitstream filter state.
///
/// This struct must be allocated with av_bsf_alloc() and freed with
/// av_bsf_free().
///
/// The fields in the struct will only be changed (by the caller or by the
/// filter) as described in their documentation, and are to be considered
/// immutable otherwise.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFContext {
    /// A class for logging and AVOptions
    pub av_class: *const AVClass,
    /// The bitstream filter this context is an instance of.
    pub filter: *const AVBitStreamFilter,
    /// Opaque libavcodec internal data. Must not be touched by the caller in any
    /// way.
    pub internal: *mut AVBSFInternal,
    /// Opaque filter-specific private data. If filter->priv_class is non-NULL,
    /// this is an AVOptions-enabled struct.
    pub priv_data: *mut lang_items::c_void,
    /// Parameters of the input stream. This field is allocated in
    /// av_bsf_alloc(), it needs to be filled by the caller before
    /// av_bsf_init().
    pub par_in: *mut AVCodecParameters,
    /// Parameters of the output stream. This field is allocated in
    /// av_bsf_alloc(), it is set by the filter in av_bsf_init().
    pub par_out: *mut AVCodecParameters,
    /// The timebase used for the timestamps of the input packets. Set by the
    /// caller before av_bsf_init().
    pub time_base_in: AVRational,
    /// The timebase used for the timestamps of the output packets. Set by the
    /// filter in av_bsf_init().
    pub time_base_out: AVRational,
}
#[test]
fn bindgen_test_layout_AVBSFContext() {
    assert_eq!(
        std::mem::size_of::<AVBSFContext>(),
        64usize,
        concat!("Size of: ", stringify!(AVBSFContext))
    );
    assert_eq!(
        std::mem::align_of::<AVBSFContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBSFContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).internal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).par_in as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_in)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).par_out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_out)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).time_base_in as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_in)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBSFContext>())).time_base_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_out)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilter {
    pub name: *const lang_items::c_char,
    /// A list of codec ids supported by the filter, terminated by
    /// AV_CODEC_ID_NONE.
    /// May be NULL, in that case the bitstream filter works with any codec id.
    pub codec_ids: *const AVCodecID,
    /// A class for the private data, used to declare bitstream filter private
    /// AVOptions. This field is NULL for bitstream filters that do not declare
    /// any options.
    ///
    /// If this field is non-NULL, the first member of the filter private data
    /// must be a pointer to AVClass, which will be set by libavcodec generic
    /// code to this class.
    pub priv_class: *const AVClass,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: lang_items::c_int,
    pub init:
        std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext) -> lang_items::c_int>,
    pub filter: std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> lang_items::c_int,
    >,
    pub close: std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilter() {
    assert_eq!(
        std::mem::size_of::<AVBitStreamFilter>(),
        56usize,
        concat!("Size of: ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        std::mem::align_of::<AVBitStreamFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).codec_ids as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).priv_class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVBitStreamFilter>())).priv_data_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).filter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVBitStreamFilter>())).close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use the new bitstream filtering API (using AVBSFContext).
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()
    /// from the new bitstream filtering API (using AVBSFContext).
    pub fn av_bitstream_filter_init(
        name: *const lang_items::c_char,
    ) -> *mut AVBitStreamFilterContext;
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the
    /// new bitstream filtering API (using AVBSFContext).
    pub fn av_bitstream_filter_filter(
        bsfc: *mut AVBitStreamFilterContext,
        avctx: *mut AVCodecContext,
        args: *const lang_items::c_char,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut lang_items::c_int,
        buf: *const u8,
        buf_size: lang_items::c_int,
        keyframe: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_free() from the new bitstream filtering API (using
    /// AVBSFContext).
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
    /// is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using
    /// AVBSFContext).
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter) -> *const AVBitStreamFilter;
}
extern "C" {
    /// @return a bitstream filter with the specified name or NULL if no such
    /// bitstream filter exists.
    pub fn av_bsf_get_by_name(name: *const lang_items::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Iterate over all registered bitstream filters.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered bitstream filter or NULL when the iteration is
    /// finished
    pub fn av_bsf_iterate(opaque: *mut *mut lang_items::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_next(opaque: *mut *mut lang_items::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Allocate a context for a given bitstream filter. The caller must fill in the
    /// context parameters as described in the documentation and then call
    /// av_bsf_init() before sending any data to the filter.
    ///
    /// @param filter the filter for which to allocate an instance.
    /// @param ctx a pointer into which the pointer to the newly-allocated context
    /// will be written. It must be freed with av_bsf_free() after the
    /// filtering is done.
    ///
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Prepare the filter for use, after all the parameters and options have been
    /// set.
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> lang_items::c_int;
}
extern "C" {
    /// Submit a packet for filtering.
    ///
    /// After sending each packet, the filter must be completely drained by calling
    /// av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
    /// AVERROR_EOF.
    ///
    /// @param pkt the packet to filter. The bitstream filter will take ownership of
    /// the packet and reset the contents of pkt. pkt is not touched if an error occurs.
    /// This parameter may be NULL, which signals the end of the stream (i.e. no more
    /// packets will be sent). That will cause the filter to output any packets it
    /// may have buffered internally.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Retrieve a filtered packet.
    ///
    /// @param[out] pkt this struct will be filled with the contents of the filtered
    /// packet. It is owned by the caller and must be freed using
    /// av_packet_unref() when it is no longer needed.
    /// This parameter should be "clean" (i.e. freshly allocated
    /// with av_packet_alloc() or unreffed with av_packet_unref())
    /// when this function is called. If this function returns
    /// successfully, the contents of pkt will be completely
    /// overwritten by the returned data. On failure, pkt is not
    /// touched.
    ///
    /// @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
    /// filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
    /// will be no further output from the filter. Another negative AVERROR value if
    /// an error occurs.
    ///
    /// @note one input packet may result in several output packets, so after sending
    /// a packet with av_bsf_send_packet(), this function needs to be called
    /// repeatedly until it stops returning 0. It is also possible for a filter to
    /// output fewer packets than were sent to it, so this function may return
    /// AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
    pub fn av_bsf_receive_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Free a bitstream filter context and everything associated with it; write NULL
    /// into the supplied pointer.
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    /// Get the AVClass for AVBSFContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate empty list of bitstream filters.
    /// The list must be later freed by av_bsf_list_free()
    /// or finalized by av_bsf_list_finalize().
    ///
    /// @return Pointer to @ref AVBSFList on success, NULL in case of failure
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    /// Free list of bitstream filters.
    ///
    /// @param lst Pointer to pointer returned by av_bsf_list_alloc()
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    /// Append bitstream filter to the list of bitstream filters.
    ///
    /// @param lst List to append to
    /// @param bsf Filter context to be appended
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext) -> lang_items::c_int;
}
extern "C" {
    /// Construct new bitstream filter context given it's name and options
    /// and append it to the list of bitstream filters.
    ///
    /// @param lst      List to append to
    /// @param bsf_name Name of the bitstream filter
    /// @param options  Options for the bitstream filter, can be set to NULL
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const lang_items::c_char,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Finalize list of bitstream filters.
    ///
    /// This function will transform @ref AVBSFList to single @ref AVBSFContext,
    /// so the whole chain of bitstream filters can be treated as single filter
    /// freshly allocated by av_bsf_alloc().
    /// If the call is successful, @ref AVBSFList structure is freed and lst
    /// will be set to NULL. In case of failure, caller is responsible for
    /// freeing the structure by av_bsf_list_free()
    ///
    /// @param      lst Filter list structure to be transformed
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    /// representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Parse string describing list of bitstream filters and create single
    /// @ref AVBSFContext describing the whole chain of bitstream filters.
    /// Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
    /// allocated by av_bsf_alloc().
    ///
    /// @param      str String describing chain of bitstream filters in format
    /// `bsf1[=opt1=val1:opt2=val2][,bsf2]`
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    /// representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_parse_str(
        str: *const lang_items::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get null/pass-through bitstream filter.
    ///
    /// @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
    ///
    /// @return
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> lang_items::c_int;
}
extern "C" {
    /// Same behaviour av_fast_malloc but the buffer has additional
    /// AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
    ///
    /// In addition the whole buffer will initially and after resizes
    /// be 0-initialized so that no uninitialized data will ever appear.
    pub fn av_fast_padded_malloc(
        ptr: *mut lang_items::c_void,
        size: *mut lang_items::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Same behaviour av_fast_padded_malloc except that buffer will always
    /// be 0-initialized after call.
    pub fn av_fast_padded_mallocz(
        ptr: *mut lang_items::c_void,
        size: *mut lang_items::c_uint,
        min_size: usize,
    );
}
extern "C" {
    /// Encode extradata length to a buffer. Used by xiph codecs.
    ///
    /// @param s buffer to write to; must be at least (v/255+1) bytes long
    /// @param v size of extradata in bytes
    /// @return number of bytes written to the buffer.
    pub fn av_xiphlacing(s: *mut lang_items::c_uchar, v: lang_items::c_uint) -> lang_items::c_uint;
}
extern "C" {
    /// Register the hardware accelerator hwaccel.
    ///
    /// @deprecated  This function doesn't do anything.
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    /// If hwaccel is NULL, returns the first registered hardware accelerator,
    /// if hwaccel is non-NULL, returns the next registered hardware accelerator
    /// after hwaccel, or NULL if hwaccel is the last one.
    ///
    /// @deprecated  AVHWaccel structures contain no user-serviceable parts, so
    /// this function should not be used.
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
/// < Create a mutex
pub const AVLockOp_AV_LOCK_CREATE: AVLockOp = 0;
/// < Lock the mutex
pub const AVLockOp_AV_LOCK_OBTAIN: AVLockOp = 1;
/// < Unlock the mutex
pub const AVLockOp_AV_LOCK_RELEASE: AVLockOp = 2;
/// < Free mutex resources
pub const AVLockOp_AV_LOCK_DESTROY: AVLockOp = 3;
/// Lock operation used by lockmgr
///
/// @deprecated Deprecated together with av_lockmgr_register().
pub type AVLockOp = u32;
extern "C" {
    /// Register a user provided lock manager supporting the operations
    /// specified by AVLockOp. The "mutex" argument to the function points
    /// to a (void *) where the lockmgr should store/get a pointer to a user
    /// allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
    /// value left by the last call for all other ops. If the lock manager is
    /// unable to perform the op then it should leave the mutex in the same
    /// state as when it was called and return a non-zero value. However,
    /// when called with AV_LOCK_DESTROY the mutex will always be assumed to
    /// have been successfully destroyed. If av_lockmgr_register succeeds
    /// it will return a non-negative value, if it fails it will return a
    /// negative value and destroy all mutex and unregister all callbacks.
    /// av_lockmgr_register is not thread-safe, it must be called from a
    /// single thread before any calls which make use of locking are used.
    ///
    /// @param cb User defined callback. av_lockmgr_register invokes calls
    /// to this callback and the previously registered callback.
    /// The callback will be used to create more than one mutex
    /// each of which must be backed by its own underlying locking
    /// mechanism (i.e. do not use a single static object to
    /// implement your lock manager). If cb is set to NULL the
    /// lockmgr will be unregistered.
    ///
    /// @deprecated This function does nothing, and always returns 0. Be sure to
    /// build with thread support to get basic thread safety.
    pub fn av_lockmgr_register(
        cb: std::option::Option<
            unsafe extern "C" fn(mutex: *mut *mut lang_items::c_void, op: AVLockOp)
                -> lang_items::c_int,
        >,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get the type of the given codec.
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    /// Get the name of a codec.
    /// @return  a static string identifying the codec; never NULL
    pub fn avcodec_get_name(id: AVCodecID) -> *const lang_items::c_char;
}
extern "C" {
    /// @return a positive value if s is open (i.e. avcodec_open2() was called on it
    /// with no corresponding avcodec_close()), 0 otherwise.
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> lang_items::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is an encoder, zero otherwise
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> lang_items::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is a decoder, zero otherwise
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> lang_items::c_int;
}
extern "C" {
    /// @return descriptor for given codec ID or NULL if no descriptor exists.
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Iterate over all codec descriptors known to libavcodec.
    ///
    /// @param prev previous descriptor. NULL to get the first descriptor.
    ///
    /// @return next descriptor or NULL after the last descriptor
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    /// @return codec descriptor with the given name or NULL if no such descriptor
    /// exists.
    pub fn avcodec_descriptor_get_by_name(
        name: *const lang_items::c_char,
    ) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Allocate a CPB properties structure and initialize its fields to default
    /// values.
    ///
    /// @param size if non-NULL, the size of the allocated struct will be written
    /// here. This is useful for embedding it in side data.
    ///
    /// @return the newly allocated struct or NULL on failure
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
/// Callback for checking whether to abort blocking functions.
/// AVERROR_EXIT is returned in this case by the interrupted
/// function. During blocking operations, callback is called with
/// opaque as parameter. If the callback returns 1, the
/// blocking operation will be aborted.
///
/// No members can be added to this struct without a major bump, if
/// new elements have been added after this struct in AVFormatContext
/// or AVIOContext.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOInterruptCB {
    pub callback: std::option::Option<
        unsafe extern "C" fn(arg1: *mut lang_items::c_void) -> lang_items::c_int,
    >,
    pub opaque: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_AVIOInterruptCB() {
    assert_eq!(
        std::mem::size_of::<AVIOInterruptCB>(),
        16usize,
        concat!("Size of: ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        std::mem::align_of::<AVIOInterruptCB>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOInterruptCB>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOInterruptCB>())).opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(opaque)
        )
    );
}
pub const AVIODirEntryType_AVIO_ENTRY_UNKNOWN: AVIODirEntryType = 0;
pub const AVIODirEntryType_AVIO_ENTRY_BLOCK_DEVICE: AVIODirEntryType = 1;
pub const AVIODirEntryType_AVIO_ENTRY_CHARACTER_DEVICE: AVIODirEntryType = 2;
pub const AVIODirEntryType_AVIO_ENTRY_DIRECTORY: AVIODirEntryType = 3;
pub const AVIODirEntryType_AVIO_ENTRY_NAMED_PIPE: AVIODirEntryType = 4;
pub const AVIODirEntryType_AVIO_ENTRY_SYMBOLIC_LINK: AVIODirEntryType = 5;
pub const AVIODirEntryType_AVIO_ENTRY_SOCKET: AVIODirEntryType = 6;
pub const AVIODirEntryType_AVIO_ENTRY_FILE: AVIODirEntryType = 7;
pub const AVIODirEntryType_AVIO_ENTRY_SERVER: AVIODirEntryType = 8;
pub const AVIODirEntryType_AVIO_ENTRY_SHARE: AVIODirEntryType = 9;
pub const AVIODirEntryType_AVIO_ENTRY_WORKGROUP: AVIODirEntryType = 10;
/// Directory entry types.
pub type AVIODirEntryType = u32;
/// Describes single entry of the directory.
///
/// Only name and type fields are guaranteed be set.
/// Rest of fields are protocol or/and platform dependent and might be unknown.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirEntry {
    /// < Filename
    pub name: *mut lang_items::c_char,
    /// < Type of the entry
    pub type_: lang_items::c_int,
    /// < Set to 1 when name is encoded with UTF-8, 0 otherwise.
    /// Name can be encoded with UTF-8 even though 0 is set.
    pub utf8: lang_items::c_int,
    /// < File size in bytes, -1 if unknown.
    pub size: i64,
    /// < Time of last modification in microseconds since unix
    /// epoch, -1 if unknown.
    pub modification_timestamp: i64,
    /// < Time of last access in microseconds since unix epoch,
    /// -1 if unknown.
    pub access_timestamp: i64,
    /// < Time of last status change in microseconds since unix
    /// epoch, -1 if unknown.
    pub status_change_timestamp: i64,
    /// < User ID of owner, -1 if unknown.
    pub user_id: i64,
    /// < Group ID of owner, -1 if unknown.
    pub group_id: i64,
    /// < Unix file mode, -1 if unknown.
    pub filemode: i64,
}
#[test]
fn bindgen_test_layout_AVIODirEntry() {
    assert_eq!(
        std::mem::size_of::<AVIODirEntry>(),
        72usize,
        concat!("Size of: ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        std::mem::align_of::<AVIODirEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).utf8 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVIODirEntry>())).modification_timestamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(modification_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).access_timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(access_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVIODirEntry>())).status_change_timestamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(status_change_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).user_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(user_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).group_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirEntry>())).filemode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(filemode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[test]
fn bindgen_test_layout_AVIODirContext() {
    assert_eq!(
        std::mem::size_of::<AVIODirContext>(),
        8usize,
        concat!("Size of: ", stringify!(AVIODirContext))
    );
    assert_eq!(
        std::mem::align_of::<AVIODirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIODirContext>())).url_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirContext),
            "::",
            stringify!(url_context)
        )
    );
}
/// Header data; this needs to be present for the stream to be decodeable.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_HEADER: AVIODataMarkerType = 0;
/// A point in the output bytestream where a decoder can start decoding
/// (i.e. a keyframe). A demuxer/decoder given the data flagged with
/// AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,
/// should give decodeable results.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_SYNC_POINT: AVIODataMarkerType = 1;
/// A point in the output bytestream where a demuxer can start parsing
/// (for non self synchronizing bytestream formats). That is, any
/// non-keyframe packet start point.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_BOUNDARY_POINT: AVIODataMarkerType = 2;
/// This is any, unlabelled data. It can either be a muxer not marking
/// any positions at all, it can be an actual boundary/sync point
/// that the muxer chooses not to mark, or a later part of a packet/fragment
/// that is cut into multiple write callbacks due to limited IO buffer size.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_UNKNOWN: AVIODataMarkerType = 3;
/// Trailer data, which doesn't contain actual content, but only for
/// finalizing the output file.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_TRAILER: AVIODataMarkerType = 4;
/// A point in the output bytestream where the underlying AVIOContext might
/// flush the buffer depending on latency or buffering requirements. Typically
/// means the end of a packet.
pub const AVIODataMarkerType_AVIO_DATA_MARKER_FLUSH_POINT: AVIODataMarkerType = 5;
/// Different data types that can be returned via the AVIO
/// write_data_type callback.
pub type AVIODataMarkerType = u32;
/// Bytestream IO Context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVIOContext) must not be used outside libav*.
///
/// @note None of the function pointers in AVIOContext should be called
/// directly, they should only be set by the client application
/// when implementing custom I/O. Normally these are set to the
/// function pointers specified in avio_alloc_context()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOContext {
    /// A class for private options.
    ///
    /// If this AVIOContext is created by avio_open2(), av_class is set and
    /// passes the options down to protocols.
    ///
    /// If this AVIOContext is manually allocated, then av_class may be set by
    /// the caller.
    ///
    /// warning -- this field can be NULL, be sure to not pass this AVIOContext
    /// to any av_opt_* functions in that case.
    pub av_class: *const AVClass,
    /// < Start of the buffer.
    pub buffer: *mut lang_items::c_uchar,
    /// < Maximum buffer size
    pub buffer_size: lang_items::c_int,
    /// < Current position in the buffer
    pub buf_ptr: *mut lang_items::c_uchar,
    /// < End of the data, may be less than
    /// buffer+buffer_size if the read function returned
    /// less data than requested, e.g. for streams where
    /// no more data has been received yet.
    pub buf_end: *mut lang_items::c_uchar,
    /// < A private pointer, passed to the read/write/seek/...
    /// functions.
    pub opaque: *mut lang_items::c_void,
    pub read_packet: std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut lang_items::c_void,
            buf: *mut u8,
            buf_size: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub write_packet: std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut lang_items::c_void,
            buf: *mut u8,
            buf_size: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    pub seek: std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut lang_items::c_void,
            offset: i64,
            whence: lang_items::c_int,
        ) -> i64,
    >,
    /// < position in the file of the current buffer
    pub pos: i64,
    /// < true if eof reached
    pub eof_reached: lang_items::c_int,
    /// < true if open for writing
    pub write_flag: lang_items::c_int,
    pub max_packet_size: lang_items::c_int,
    pub checksum: lang_items::c_ulong,
    pub checksum_ptr: *mut lang_items::c_uchar,
    pub update_checksum: std::option::Option<
        unsafe extern "C" fn(
            checksum: lang_items::c_ulong,
            buf: *const u8,
            size: lang_items::c_uint,
        ) -> lang_items::c_ulong,
    >,
    /// < contains the error code or 0 if no error happened
    pub error: lang_items::c_int,
    /// Pause or resume playback for network streaming protocols - e.g. MMS.
    pub read_pause: std::option::Option<
        unsafe extern "C" fn(opaque: *mut lang_items::c_void, pause: lang_items::c_int)
            -> lang_items::c_int,
    >,
    /// Seek to a given timestamp in stream with the specified stream_index.
    /// Needed for some network streaming protocols which don't support seeking
    /// to byte position.
    pub read_seek: std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut lang_items::c_void,
            stream_index: lang_items::c_int,
            timestamp: i64,
            flags: lang_items::c_int,
        ) -> i64,
    >,
    /// A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
    pub seekable: lang_items::c_int,
    /// max filesize, used to limit allocations
    /// This field is internal to libavformat and access from outside is not allowed.
    pub maxsize: i64,
    /// avio_read and avio_write should if possible be satisfied directly
    /// instead of going through a buffer, and avio_seek will always
    /// call the underlying seek function directly.
    pub direct: lang_items::c_int,
    /// Bytes read statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub bytes_read: i64,
    /// seek statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub seek_count: lang_items::c_int,
    /// writeout statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub writeout_count: lang_items::c_int,
    /// Original buffer size
    /// used internally after probing and ensure seekback to reset the buffer size
    /// This field is internal to libavformat and access from outside is not allowed.
    pub orig_buffer_size: lang_items::c_int,
    /// Threshold to favor readahead over seek.
    /// This is current internal only, do not use from outside.
    pub short_seek_threshold: lang_items::c_int,
    /// ',' separated list of allowed protocols.
    pub protocol_whitelist: *const lang_items::c_char,
    /// ',' separated list of disallowed protocols.
    pub protocol_blacklist: *const lang_items::c_char,
    /// A callback that is used instead of write_packet.
    pub write_data_type: std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut lang_items::c_void,
            buf: *mut u8,
            buf_size: lang_items::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> lang_items::c_int,
    >,
    /// If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
    /// but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
    /// small chunks of data returned from the callback).
    pub ignore_boundary_point: lang_items::c_int,
    /// Internal, not meant to be used from outside of AVIOContext.
    pub current_type: AVIODataMarkerType,
    pub last_time: i64,
    /// A callback that is used instead of short_seek_threshold.
    /// This is current internal only, do not use from outside.
    pub short_seek_get: std::option::Option<
        unsafe extern "C" fn(opaque: *mut lang_items::c_void) -> lang_items::c_int,
    >,
    pub written: i64,
    /// Maximum reached position before a backward seek in the write buffer,
    /// used keeping track of already written data for a later flush.
    pub buf_ptr_max: *mut lang_items::c_uchar,
    /// Try to buffer at least this amount of data before flushing it
    pub min_packet_size: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVIOContext() {
    assert_eq!(
        std::mem::size_of::<AVIOContext>(),
        264usize,
        concat!("Size of: ", stringify!(AVIOContext))
    );
    assert_eq!(
        std::mem::align_of::<AVIOContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).buf_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).buf_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).read_packet as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).write_packet as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).seek as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).eof_reached as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(eof_reached)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).write_flag as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).max_packet_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(max_packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).checksum as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).checksum_ptr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).update_checksum as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).error as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).read_seek as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).seekable as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).maxsize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).direct as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(direct)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).bytes_read as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).seek_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).writeout_count as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(writeout_count)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).orig_buffer_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(orig_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVIOContext>())).short_seek_threshold as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(short_seek_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).protocol_whitelist as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).protocol_blacklist as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).write_data_type as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_data_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVIOContext>())).ignore_boundary_point as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(ignore_boundary_point)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).current_type as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(current_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).last_time as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(last_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).short_seek_get as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(short_seek_get)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).written as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).buf_ptr_max as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIOContext>())).min_packet_size as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(min_packet_size)
        )
    );
}
extern "C" {
    /// Return the name of the protocol that will handle the passed URL.
    ///
    /// NULL is returned if no protocol could be found for the given URL.
    ///
    /// @return Name of the protocol or NULL.
    pub fn avio_find_protocol_name(url: *const lang_items::c_char) -> *const lang_items::c_char;
}
extern "C" {
    /// Return AVIO_FLAG_* access flags corresponding to the access permissions
    /// of the resource in url, or a negative value corresponding to an
    /// AVERROR code in case of failure. The returned access flags are
    /// masked by the value in flags.
    ///
    /// @note This function is intrinsically unsafe, in the sense that the
    /// checked resource may change its existence or permission status from
    /// one call to another. Thus you should not trust the returned value,
    /// unless you are sure that no other processes are accessing the
    /// checked resource.
    pub fn avio_check(
        url: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Move or rename a resource.
    ///
    /// @note url_src and url_dst should share the same protocol and authority.
    ///
    /// @param url_src url to resource to be moved
    /// @param url_dst new url to resource if the operation succeeded
    /// @return >=0 on success or negative on error.
    pub fn avpriv_io_move(
        url_src: *const lang_items::c_char,
        url_dst: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Delete a resource.
    ///
    /// @param url resource to be deleted.
    /// @return >=0 on success or negative on error.
    pub fn avpriv_io_delete(url: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Open directory for reading.
    ///
    /// @param s       directory read context. Pointer to a NULL pointer must be passed.
    /// @param url     directory to be listed.
    /// @param options A dictionary filled with protocol-private options. On return
    /// this parameter will be destroyed and replaced with a dictionary
    /// containing options that were not found. May be NULL.
    /// @return >=0 on success or negative on error.
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const lang_items::c_char,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get next directory entry.
    ///
    /// Returned entry must be freed with avio_free_directory_entry(). In particular
    /// it may outlive AVIODirContext.
    ///
    /// @param s         directory read context.
    /// @param[out] next next entry or NULL when no more entries.
    /// @return >=0 on success or negative on error. End of list is not considered an
    /// error.
    pub fn avio_read_dir(s: *mut AVIODirContext, next: *mut *mut AVIODirEntry)
        -> lang_items::c_int;
}
extern "C" {
    /// Close directory.
    ///
    /// @note Entries created using avio_read_dir() are not deleted and must be
    /// freeded with avio_free_directory_entry().
    ///
    /// @param s         directory read context.
    /// @return >=0 on success or negative on error.
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> lang_items::c_int;
}
extern "C" {
    /// Free entry allocated by avio_read_dir().
    ///
    /// @param entry entry to be freed.
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    /// Allocate and initialize an AVIOContext for buffered I/O. It must be later
    /// freed with avio_context_free().
    ///
    /// @param buffer Memory block for input/output operations via AVIOContext.
    /// The buffer must be allocated with av_malloc() and friends.
    /// It may be freed and replaced with a new buffer by libavformat.
    /// AVIOContext.buffer holds the buffer currently in use,
    /// which must be later freed with av_free().
    /// @param buffer_size The buffer size is very important for performance.
    /// For protocols with fixed blocksize it should be set to this blocksize.
    /// For others a typical size is a cache page, e.g. 4kb.
    /// @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
    /// @param opaque An opaque pointer to user-specific data.
    /// @param read_packet  A function for refilling the buffer, may be NULL.
    /// For stream protocols, must never return 0 but rather
    /// a proper AVERROR code.
    /// @param write_packet A function for writing the buffer contents, may be NULL.
    /// The function may not change the input buffers content.
    /// @param seek A function for seeking to specified byte position, may be NULL.
    ///
    /// @return Allocated AVIOContext or NULL on failure.
    pub fn avio_alloc_context(
        buffer: *mut lang_items::c_uchar,
        buffer_size: lang_items::c_int,
        write_flag: lang_items::c_int,
        opaque: *mut lang_items::c_void,
        read_packet: std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut lang_items::c_void,
                buf: *mut u8,
                buf_size: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        write_packet: std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut lang_items::c_void,
                buf: *mut u8,
                buf_size: lang_items::c_int,
            ) -> lang_items::c_int,
        >,
        seek: std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut lang_items::c_void,
                offset: i64,
                whence: lang_items::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    /// Free the supplied IO context and everything associated with it.
    ///
    /// @param s Double pointer to the IO context. This function will write NULL
    /// into s.
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: lang_items::c_int);
}
extern "C" {
    pub fn avio_write(
        s: *mut AVIOContext,
        buf: *const lang_items::c_uchar,
        size: lang_items::c_int,
    );
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: lang_items::c_uint);
}
extern "C" {
    /// Write a NULL-terminated string.
    /// @return number of bytes written.
    pub fn avio_put_str(s: *mut AVIOContext, str: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Convert an UTF-8 string to UTF-16LE and write it.
    /// @param s the AVIOContext
    /// @param str NULL-terminated UTF-8 string
    ///
    /// @return number of bytes written.
    pub fn avio_put_str16le(
        s: *mut AVIOContext,
        str: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Convert an UTF-8 string to UTF-16BE and write it.
    /// @param s the AVIOContext
    /// @param str NULL-terminated UTF-8 string
    ///
    /// @return number of bytes written.
    pub fn avio_put_str16be(
        s: *mut AVIOContext,
        str: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Mark the written bytestream as a specific type.
    ///
    /// Zero-length ranges are omitted from the output.
    ///
    /// @param time the stream time the current bytestream pos corresponds to
    /// (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
    /// applicable
    /// @param type the kind of data written starting at the current pos
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    /// fseek() equivalent for AVIOContext.
    /// @return new position or AVERROR.
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: lang_items::c_int) -> i64;
}
extern "C" {
    /// Skip given number of bytes forward
    /// @return new position or AVERROR.
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    /// Get the filesize.
    /// @return filesize or AVERROR
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    /// feof() equivalent for AVIOContext.
    /// @return non zero if and only if end of file
    pub fn avio_feof(s: *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    /// @warning Writes up to 4 KiB per call
    pub fn avio_printf(
        s: *mut AVIOContext,
        fmt: *const lang_items::c_char,
        ...
    ) -> lang_items::c_int;
}
extern "C" {
    /// Force flushing of buffered data.
    ///
    /// For write streams, force the buffered data to be immediately written to the output,
    /// without to wait to fill the internal buffer.
    ///
    /// For read streams, discard all currently buffered data, and advance the
    /// reported file position to that of the underlying stream. This does not
    /// read new data, and does not perform any seeks.
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    /// Read size bytes from AVIOContext into buf.
    /// @return number of bytes read or AVERROR
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut lang_items::c_uchar,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed
    /// to read fewer bytes than requested. The missing bytes can be read in the next
    /// call. This always tries to read at least 1 byte.
    /// Useful to reduce latency in certain cases.
    /// @return number of bytes read or AVERROR
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut lang_items::c_uchar,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @name Functions for reading from AVIOContext
    /// @{
    ///
    /// @note return 0 if EOF, so you cannot use it if EOF handling is
    /// necessary
    pub fn avio_r8(s: *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> lang_items::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    /// Read a string from pb into buf. The reading will terminate when either
    /// a NULL character was encountered, maxlen bytes have been read, or nothing
    /// more can be read from pb. The result is guaranteed to be NULL-terminated, it
    /// will be truncated if buf is too small.
    /// Note that the string is not interpreted or validated in any way, it
    /// might get truncated in the middle of a sequence for multi-byte encodings.
    ///
    /// @return number of bytes read (is always <= maxlen).
    /// If reading ends on EOF or error, the return value will be one more than
    /// bytes actually read.
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: lang_items::c_int,
        buf: *mut lang_items::c_char,
        buflen: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Read a UTF-16 string from pb and convert it to UTF-8.
    /// The reading will terminate when either a null or invalid character was
    /// encountered or maxlen bytes have been read.
    /// @return number of bytes read (is always <= maxlen)
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: lang_items::c_int,
        buf: *mut lang_items::c_char,
        buflen: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: lang_items::c_int,
        buf: *mut lang_items::c_char,
        buflen: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Create and initialize a AVIOContext for accessing the
    /// resource indicated by url.
    /// @note When the resource indicated by url has been opened in
    /// read+write mode, the AVIOContext can be used only for writing.
    ///
    /// @param s Used to return the pointer to the created AVIOContext.
    /// In case of failure the pointed to value is set to NULL.
    /// @param url resource to access
    /// @param flags flags which control how the resource indicated by url
    /// is to be opened
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code in case of failure
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const lang_items::c_char,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Create and initialize a AVIOContext for accessing the
    /// resource indicated by url.
    /// @note When the resource indicated by url has been opened in
    /// read+write mode, the AVIOContext can be used only for writing.
    ///
    /// @param s Used to return the pointer to the created AVIOContext.
    /// In case of failure the pointed to value is set to NULL.
    /// @param url resource to access
    /// @param flags flags which control how the resource indicated by url
    /// is to be opened
    /// @param int_cb an interrupt callback to be used at the protocols level
    /// @param options  A dictionary filled with protocol-private options. On return
    /// this parameter will be destroyed and replaced with a dict containing options
    /// that were not found. May be NULL.
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code in case of failure
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const lang_items::c_char,
        flags: lang_items::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Close the resource accessed by the AVIOContext s and free it.
    /// This function can only be used if s was opened by avio_open().
    ///
    /// The internal buffer is automatically flushed before closing the
    /// resource.
    ///
    /// @return 0 on success, an AVERROR < 0 on error.
    /// @see avio_closep
    pub fn avio_close(s: *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    /// Close the resource accessed by the AVIOContext *s, free it
    /// and set the pointer pointing to it to NULL.
    /// This function can only be used if s was opened by avio_open().
    ///
    /// The internal buffer is automatically flushed before closing the
    /// resource.
    ///
    /// @return 0 on success, an AVERROR < 0 on error.
    /// @see avio_close
    pub fn avio_closep(s: *mut *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    /// Open a write only memory stream.
    ///
    /// @param s new IO context
    /// @return zero if no error.
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    /// Return the written size and a pointer to the buffer.
    /// The AVIOContext stream is left intact.
    /// The buffer must NOT be freed.
    /// No padding is added to the buffer.
    ///
    /// @param s IO context
    /// @param pbuffer pointer to a byte buffer
    /// @return the length of the byte buffer
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> lang_items::c_int;
}
extern "C" {
    /// Return the written size and a pointer to the buffer. The buffer
    /// must be freed with av_free().
    /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
    ///
    /// @param s IO context
    /// @param pbuffer pointer to a byte buffer
    /// @return the length of the byte buffer
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> lang_items::c_int;
}
extern "C" {
    /// Iterate through names of available protocols.
    ///
    /// @param opaque A private pointer representing current protocol.
    /// It must be a pointer to NULL on first iteration and will
    /// be updated by successive calls to avio_enum_protocols.
    /// @param output If set to 1, iterate over output protocols,
    /// otherwise over input protocols.
    ///
    /// @return A static string containing the name of current protocol or NULL
    pub fn avio_enum_protocols(
        opaque: *mut *mut lang_items::c_void,
        output: lang_items::c_int,
    ) -> *const lang_items::c_char;
}
extern "C" {
    /// Pause and resume playing - only meaningful if using a network streaming
    /// protocol (e.g. MMS).
    ///
    /// @param h     IO context from which to call the read_pause function pointer
    /// @param pause 1 for pause, 0 for resume
    pub fn avio_pause(h: *mut AVIOContext, pause: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Seek to a given timestamp relative to some component stream.
    /// Only meaningful if using a network streaming protocol (e.g. MMS.).
    ///
    /// @param h IO context from which to call the seek function pointers
    /// @param stream_index The stream index that the timestamp is relative to.
    /// If stream_index is (-1) the timestamp should be in AV_TIME_BASE
    /// units from the beginning of the presentation.
    /// If a stream_index >= 0 is used and the protocol does not support
    /// seeking based on component streams, the call will fail.
    /// @param timestamp timestamp in AVStream.time_base units
    /// or if there is no stream specified then in AV_TIME_BASE units.
    /// @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
    /// and AVSEEK_FLAG_ANY. The protocol may silently ignore
    /// AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
    /// fail if used and not supported.
    /// @return >= 0 on success
    /// @see AVInputFormat::read_seek
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: lang_items::c_int,
        timestamp: i64,
        flags: lang_items::c_int,
    ) -> i64;
}
extern "C" {
    /// Read contents of h into print buffer, up to max_size bytes, or up to EOF.
    ///
    /// @return 0 for success (max_size bytes read or EOF reached), negative error
    /// code otherwise
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Accept and allocate a client context on a server context.
    /// @param  s the server context
    /// @param  c the client context, must be unallocated
    /// @return   >= 0 on success or a negative value corresponding
    /// to an AVERROR on failure
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> lang_items::c_int;
}
extern "C" {
    /// Perform one step of the protocol handshake to accept a new client.
    /// This function must be called on a client returned by avio_accept() before
    /// using it as a read/write context.
    /// It is separate from avio_accept() because it may block.
    /// A step of the handshake is defined by places where the application may
    /// decide to change the proceedings.
    /// For example, on a protocol with a request header and a reply header, each
    /// one can constitute a step because the application may use the parameters
    /// from the request to change parameters in the reply; or each individual
    /// chunk of the request can constitute a step.
    /// If the handshake is already finished, avio_handshake() does nothing and
    /// returns 0 immediately.
    ///
    /// @param  c the client context to perform the handshake on
    /// @return   0   on a complete and successful handshake
    /// > 0 if the handshake progressed, but is not complete
    /// < 0 for an AVERROR code
    pub fn avio_handshake(c: *mut AVIOContext) -> lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfoList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceCapabilitiesQuery {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate and read the payload of a packet and initialize its
    /// fields with default values.
    ///
    /// @param s    associated IO context
    /// @param pkt packet
    /// @param size desired payload size
    /// @return >0 (read size) if OK, AVERROR_xxx otherwise
    pub fn av_get_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Read data and append it to the current content of the AVPacket.
    /// If pkt->size is 0 this is identical to av_get_packet.
    /// Note that this uses av_grow_packet and thus involves a realloc
    /// which is inefficient. Thus this function should only be used
    /// when there is no reasonable way to know (an upper bound of)
    /// the final size.
    ///
    /// @param s    associated IO context
    /// @param pkt packet
    /// @param size amount of data to read
    /// @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
    /// will not be lost even if an error occurs.
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
/// This structure contains the data a format has to probe a file.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProbeData {
    pub filename: *const lang_items::c_char,
    /// < Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero.
    pub buf: *mut lang_items::c_uchar,
    /// < Size of buf except extra allocated bytes
    pub buf_size: lang_items::c_int,
    /// < mime_type, when known.
    pub mime_type: *const lang_items::c_char,
}
#[test]
fn bindgen_test_layout_AVProbeData() {
    assert_eq!(
        std::mem::size_of::<AVProbeData>(),
        32usize,
        concat!("Size of: ", stringify!(AVProbeData))
    );
    assert_eq!(
        std::mem::align_of::<AVProbeData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProbeData))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProbeData>())).filename as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProbeData>())).buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProbeData>())).buf_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProbeData>())).mime_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(mime_type)
        )
    );
}
/// @addtogroup lavf_encoding
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOutputFormat {
    pub name: *const lang_items::c_char,
    /// Descriptive name for the format, meant to be more human-readable
    /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
    /// to define it.
    pub long_name: *const lang_items::c_char,
    pub mime_type: *const lang_items::c_char,
    /// < comma-separated filename extensions
    pub extensions: *const lang_items::c_char,
    /// < default audio codec
    pub audio_codec: AVCodecID,
    /// < default video codec
    pub video_codec: AVCodecID,
    /// < default subtitle codec
    pub subtitle_codec: AVCodecID,
    /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
    /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
    /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
    /// AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
    pub flags: lang_items::c_int,
    /// List of supported codec_id-codec_tag pairs, ordered by "better
    /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
    pub codec_tag: *const *const AVCodecTag,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub next: *mut AVOutputFormat,
    /// size of private data so that it can be allocated in the wrapper
    pub priv_data_size: lang_items::c_int,
    pub write_header: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
    /// pkt can be NULL in order to flush data buffered in the muxer.
    /// When flushing, return 0 if there still is more data to flush,
    /// or 1 if everything was flushed and there is no more buffered
    /// data.
    pub write_packet: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> lang_items::c_int,
    >,
    pub write_trailer: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Currently only used to set pixel format if not YUV420P.
    pub interleave_packet: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            out: *mut AVPacket,
            in_: *mut AVPacket,
            flush: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    /// Test if the given codec can be stored in this container.
    ///
    /// @return 1 if the codec is supported, 0 if it is not.
    /// A negative number if unknown.
    /// MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
    pub query_codec: std::option::Option<
        unsafe extern "C" fn(id: AVCodecID, std_compliance: lang_items::c_int) -> lang_items::c_int,
    >,
    pub get_output_timestamp: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: lang_items::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    /// Allows sending messages from application to device.
    pub control_message: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: lang_items::c_int,
            data: *mut lang_items::c_void,
            data_size: usize,
        ) -> lang_items::c_int,
    >,
    /// Write an uncoded AVFrame.
    ///
    /// See av_write_uncoded_frame() for details.
    ///
    /// The library will free *frame afterwards, but the muxer can prevent it
    /// by setting the pointer to NULL.
    pub write_uncoded_frame: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: lang_items::c_int,
            frame: *mut *mut AVFrame,
            flags: lang_items::c_uint,
        ) -> lang_items::c_int,
    >,
    /// Returns device list with it properties.
    /// @see avdevice_list_devices() for more details.
    pub get_device_list: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, device_list: *mut AVDeviceInfoList)
            -> lang_items::c_int,
    >,
    /// Initialize device capabilities submodule.
    /// @see avdevice_capabilities_create() for more details.
    pub create_device_capabilities: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> lang_items::c_int,
    >,
    /// Free device capabilities submodule.
    /// @see avdevice_capabilities_free() for more details.
    pub free_device_capabilities: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> lang_items::c_int,
    >,
    /// < default data codec
    pub data_codec: AVCodecID,
    /// Initialize format. May allocate data here, and set any AVFormatContext or
    /// AVStream parameters that need to be set before packets are sent.
    /// This method must not write output.
    ///
    /// Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure
    ///
    /// Any allocations made here must be freed in deinit().
    pub init: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Deinitialize format. If present, this is called whenever the muxer is being
    /// destroyed, regardless of whether or not the header has been written.
    ///
    /// If a trailer is being written, this is called after write_trailer().
    ///
    /// This is called if init() fails as well.
    pub deinit: std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    /// Set up any necessary bitstream filtering and extract any extra data needed
    /// for the global header.
    /// Return 0 if more packets from this stream must be checked; 1 if not.
    pub check_bitstream: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *const AVPacket) -> lang_items::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVOutputFormat() {
    assert_eq!(
        std::mem::size_of::<AVOutputFormat>(),
        200usize,
        concat!("Size of: ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        std::mem::align_of::<AVOutputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).mime_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).audio_codec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).video_codec as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).subtitle_codec as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).codec_tag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).priv_class as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).priv_data_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).write_header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_header)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).write_packet as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).write_trailer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_trailer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVOutputFormat>())).interleave_packet as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(interleave_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).query_codec as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(query_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVOutputFormat>())).get_output_timestamp as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_output_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).control_message as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(control_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVOutputFormat>())).write_uncoded_frame as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_uncoded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).get_device_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVOutputFormat>())).create_device_capabilities as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(create_device_capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVOutputFormat>())).free_device_capabilities as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(free_device_capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).data_codec as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).init as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).deinit as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVOutputFormat>())).check_bitstream as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(check_bitstream)
        )
    );
}
/// @addtogroup lavf_decoding
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVInputFormat {
    /// A comma separated list of short names for the format. New names
    /// may be appended with a minor bump.
    pub name: *const lang_items::c_char,
    /// Descriptive name for the format, meant to be more human-readable
    /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
    /// to define it.
    pub long_name: *const lang_items::c_char,
    /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
    /// AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
    /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
    pub flags: lang_items::c_int,
    /// If extensions are defined, then no probe is done. You should
    /// usually not use extension format guessing because it is not
    /// reliable enough
    pub extensions: *const lang_items::c_char,
    pub codec_tag: *const *const AVCodecTag,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// Comma-separated list of mime types.
    /// It is used check for matching mime types while probing.
    /// @see av_probe_input_format2
    pub mime_type: *const lang_items::c_char,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub next: *mut AVInputFormat,
    /// Raw demuxers store their codec ID here.
    pub raw_codec_id: lang_items::c_int,
    /// Size of private data so that it can be allocated in the wrapper.
    pub priv_data_size: lang_items::c_int,
    /// Tell if a given file has a chance of being parsed as this format.
    /// The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
    /// big so you do not have to check for that unless you need more.
    pub read_probe:
        std::option::Option<unsafe extern "C" fn(arg1: *mut AVProbeData) -> lang_items::c_int>,
    /// Read the format header and initialize the AVFormatContext
    /// structure. Return 0 if OK. 'avformat_new_stream' should be
    /// called to create new streams.
    pub read_header: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Read one packet and put it in 'pkt'. pts and flags are also
    /// set. 'avformat_new_stream' can be called only if the flag
    /// AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
    /// background thread).
    /// @return 0 on success, < 0 on error.
    /// When returning an error, pkt must not have been allocated
    /// or must be freed before returning
    pub read_packet: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> lang_items::c_int,
    >,
    /// Close the stream. The AVFormatContext and AVStreams are not
    /// freed by this function
    pub read_close: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Seek to a given timestamp relative to the frames in
    /// stream component stream_index.
    /// @param stream_index Must not be -1.
    /// @param flags Selects which direction should be preferred if no exact
    /// match is available.
    /// @return >= 0 on success (but not necessarily the new offset)
    pub read_seek: std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: lang_items::c_int,
            timestamp: i64,
            flags: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    /// Get the next timestamp in stream[stream_index].time_base units.
    /// @return the timestamp or AV_NOPTS_VALUE if an error occurred
    pub read_timestamp: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: lang_items::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    /// Start/resume playing - only meaningful if using a network-based format
    /// (RTSP).
    pub read_play: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Pause playing - only meaningful if using a network-based format
    /// (RTSP).
    pub read_pause: std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> lang_items::c_int,
    >,
    /// Seek to timestamp ts.
    /// Seeking will be done so that the point from which all active streams
    /// can be presented successfully will be closest to ts and within min/max_ts.
    /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
    pub read_seek2: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: lang_items::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: lang_items::c_int,
        ) -> lang_items::c_int,
    >,
    /// Returns device list with it properties.
    /// @see avdevice_list_devices() for more details.
    pub get_device_list: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, device_list: *mut AVDeviceInfoList)
            -> lang_items::c_int,
    >,
    /// Initialize device capabilities submodule.
    /// @see avdevice_capabilities_create() for more details.
    pub create_device_capabilities: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> lang_items::c_int,
    >,
    /// Free device capabilities submodule.
    /// @see avdevice_capabilities_free() for more details.
    pub free_device_capabilities: std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> lang_items::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVInputFormat() {
    assert_eq!(
        std::mem::size_of::<AVInputFormat>(),
        168usize,
        concat!("Size of: ", stringify!(AVInputFormat))
    );
    assert_eq!(
        std::mem::align_of::<AVInputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVInputFormat))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).codec_tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).priv_class as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).mime_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).raw_codec_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(raw_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).priv_data_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_probe as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_header)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_packet as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_close as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_close)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_seek as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_timestamp as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_play as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_play)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).read_seek2 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek2)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVInputFormat>())).get_device_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVInputFormat>())).create_device_capabilities as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(create_device_capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVInputFormat>())).free_device_capabilities as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(free_device_capabilities)
        )
    );
}
pub const AVStreamParseType_AVSTREAM_PARSE_NONE: AVStreamParseType = 0;
/// < full parsing and repack
pub const AVStreamParseType_AVSTREAM_PARSE_FULL: AVStreamParseType = 1;
/// < Only parse headers, do not repack.
pub const AVStreamParseType_AVSTREAM_PARSE_HEADERS: AVStreamParseType = 2;
/// < full parsing and interpolation of timestamps for frames not starting on a packet boundary
pub const AVStreamParseType_AVSTREAM_PARSE_TIMESTAMPS: AVStreamParseType = 3;
/// < full parsing and repack of the first frame only, only implemented for H.264 currently
pub const AVStreamParseType_AVSTREAM_PARSE_FULL_ONCE: AVStreamParseType = 4;
/// < full parsing and repack with timestamp and position generation by parser for raw
/// this assumes that each packet in the file contains no demuxer level headers and
/// just codec level data, otherwise position generation would fail
pub const AVStreamParseType_AVSTREAM_PARSE_FULL_RAW: AVStreamParseType = 5;
/// @}
pub type AVStreamParseType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIndexEntry {
    pub pos: i64,
    /// <
    /// Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
    /// when seeking to this entry. That means preferable PTS on keyframe based formats.
    /// But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
    /// is known
    pub timestamp: i64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    /// < Minimum distance between this and the previous keyframe, used to avoid unneeded searching.
    pub min_distance: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVIndexEntry() {
    assert_eq!(
        std::mem::size_of::<AVIndexEntry>(),
        24usize,
        concat!("Size of: ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        std::mem::align_of::<AVIndexEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIndexEntry>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIndexEntry>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVIndexEntry>())).min_distance as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(min_distance)
        )
    );
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> lang_items::c_int {
        unsafe { std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: lang_items::c_int) {
        unsafe {
            let val: u32 = std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> lang_items::c_int {
        unsafe { std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: lang_items::c_int) {
        unsafe {
            let val: u32 = std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: lang_items::c_int,
        size: lang_items::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStreamInternal {
    _unused: [u8; 0],
}
/// Stream structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVStream) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream {
    /// < stream index in AVFormatContext
    pub index: lang_items::c_int,
    /// Format-specific stream ID.
    /// decoding: set by libavformat
    /// encoding: set by the user, replaced by libavformat if left unset
    pub id: lang_items::c_int,
    /// @deprecated use the codecpar struct instead
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut lang_items::c_void,
    /// This is the fundamental unit of time (in seconds) in terms
    /// of which frame timestamps are represented.
    ///
    /// decoding: set by libavformat
    /// encoding: May be set by the caller before avformat_write_header() to
    /// provide a hint to the muxer about the desired timebase. In
    /// avformat_write_header(), the muxer will overwrite this field
    /// with the timebase that will actually be used for the timestamps
    /// written into the file (which may or may not be related to the
    /// user-provided one, depending on the format).
    pub time_base: AVRational,
    /// Decoding: pts of the first frame of the stream in presentation order, in stream time base.
    /// Only set this if you are absolutely 100% sure that the value you set
    /// it to really is the pts of the first frame.
    /// This may be undefined (AV_NOPTS_VALUE).
    /// @note The ASF header does NOT contain a correct start_time the ASF
    /// demuxer must NOT set this.
    pub start_time: i64,
    /// Decoding: duration of the stream, in stream time base.
    /// If a source file does not specify a duration, but does specify
    /// a bitrate, this value will be estimated from bitrate and file size.
    ///
    /// Encoding: May be set by the caller before avformat_write_header() to
    /// provide a hint to the muxer about the estimated duration.
    pub duration: i64,
    /// < number of frames in this stream if known or 0
    pub nb_frames: i64,
    /// < AV_DISPOSITION_* bit field
    pub disposition: lang_items::c_int,
    /// < Selects which packets can be discarded at will and do not need to be demuxed.
    pub discard: AVDiscard,
    /// sample aspect ratio (0 if unknown)
    /// - encoding: Set by user.
    /// - decoding: Set by libavformat.
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    /// Average framerate
    ///
    /// - demuxing: May be set by libavformat when creating the stream or in
    /// avformat_find_stream_info().
    /// - muxing: May be set by the caller before avformat_write_header().
    pub avg_frame_rate: AVRational,
    /// For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
    /// will contain the attached picture.
    ///
    /// decoding: set by libavformat, must not be modified by the caller.
    /// encoding: unused
    pub attached_pic: AVPacket,
    /// An array of side data that applies to the whole stream (i.e. the
    /// container does not allow it to change between packets).
    ///
    /// There may be no overlap between the side data in this array and side data
    /// in the packets. I.e. a given side data is either exported by the muxer
    /// (demuxing) / set by the caller (muxing) in this array, then it never
    /// appears in the packets, or the side data is exported / sent through
    /// the packets (always in the first packet where the value becomes known or
    /// changes), then it does not appear in this array.
    ///
    /// - demuxing: Set by libavformat when the stream is created.
    /// - muxing: May be set by the caller before avformat_write_header().
    ///
    /// Freed by libavformat in avformat_free_context().
    ///
    /// @see av_format_inject_global_side_data()
    pub side_data: *mut AVPacketSideData,
    /// The number of elements in the AVStream.side_data array.
    pub nb_side_data: lang_items::c_int,
    /// Flags for the user to detect events happening on the stream. Flags must
    /// be cleared by the user once the event has been handled.
    /// A combination of AVSTREAM_EVENT_FLAG_*.
    pub event_flags: lang_items::c_int,
    /// Real base framerate of the stream.
    /// This is the lowest framerate with which all timestamps can be
    /// represented accurately (it is the least common multiple of all
    /// framerates in the stream). Note, this value is just a guess!
    /// For example, if the time base is 1/90000 and all frames have either
    /// approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
    pub r_frame_rate: AVRational,
    /// String containing pairs of key and values describing recommended encoder configuration.
    /// Pairs are separated by ','.
    /// Keys are separated from values by '='.
    ///
    /// @deprecated unused
    pub recommended_encoder_configuration: *mut lang_items::c_char,
    /// Codec parameters associated with this stream. Allocated and freed by
    /// libavformat in avformat_new_stream() and avformat_free_context()
    /// respectively.
    ///
    /// - demuxing: filled by libavformat on stream creation or in
    /// avformat_find_stream_info()
    /// - muxing: filled by the caller before avformat_write_header()
    pub codecpar: *mut AVCodecParameters,
    pub info: *mut AVStream__bindgen_ty_1,
    /// < number of bits in pts (used for wrapping control)
    pub pts_wrap_bits: lang_items::c_int,
    /// Timestamp corresponding to the last dts sync point.
    ///
    /// Initialized when AVCodecParserContext.dts_sync_point >= 0 and
    /// a DTS is received from the underlying container. Otherwise set to
    /// AV_NOPTS_VALUE by default.
    pub first_dts: i64,
    pub cur_dts: i64,
    pub last_IP_pts: i64,
    pub last_IP_duration: lang_items::c_int,
    /// Number of packets to buffer for codec probing
    pub probe_packets: lang_items::c_int,
    /// Number of frames that have been demuxed during avformat_find_stream_info()
    pub codec_info_nb_frames: lang_items::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    /// last packet in packet_buffer for this stream when muxing.
    pub last_in_packet_buffer: *mut AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [i64; 17usize],
    /// < Only used if the format does not
    /// support seeking natively.
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: lang_items::c_int,
    pub index_entries_allocated_size: lang_items::c_uint,
    /// Stream Identifier
    /// This is the MPEG-TS stream identifier +1
    /// 0 means unknown
    pub stream_identifier: lang_items::c_int,
    pub interleaver_chunk_size: i64,
    pub interleaver_chunk_duration: i64,
    /// stream probing state
    /// -1   -> probing finished
    /// 0   -> no probing requested
    /// rest -> perform probing with request_probe being the minimum score to accept.
    /// NOT PART OF PUBLIC API
    pub request_probe: lang_items::c_int,
    /// Indicates that everything up to the next keyframe
    /// should be discarded.
    pub skip_to_keyframe: lang_items::c_int,
    /// Number of samples to skip at the start of the frame decoded from the next packet.
    pub skip_samples: lang_items::c_int,
    /// If not 0, the number of samples that should be skipped from the start of
    /// the stream (the samples are removed from packets with pts==0, which also
    /// assumes negative timestamps do not happen).
    /// Intended for use with formats such as mp3 with ad-hoc gapless audio
    /// support.
    pub start_skip_samples: i64,
    /// If not 0, the first audio sample that should be discarded from the stream.
    /// This is broken by design (needs global sample count), but can't be
    /// avoided for broken by design formats such as mp3 with ad-hoc gapless
    /// audio support.
    pub first_discard_sample: i64,
    /// The sample after last sample that is intended to be discarded after
    /// first_discard_sample. Works on frame boundaries only. Used to prevent
    /// early EOF if the gapless info is broken (considered concatenated mp3s).
    pub last_discard_sample: i64,
    /// Number of internally decoded frames, used internally in libavformat, do not access
    /// its lifetime differs from info which is why it is not in that structure.
    pub nb_decoded_frames: lang_items::c_int,
    /// Timestamp offset added to timestamps before muxing
    /// NOT PART OF PUBLIC API
    pub mux_ts_offset: i64,
    /// Internal data to check for wrapping of the time stamp
    pub pts_wrap_reference: i64,
    /// Options for behavior, when a wrap is detected.
    ///
    /// Defined by AV_PTS_WRAP_ values.
    ///
    /// If correction is enabled, there are two possibilities:
    /// If the first time stamp is near the wrap point, the wrap offset
    /// will be subtracted, which will create negative time stamps.
    /// Otherwise the offset will be added.
    pub pts_wrap_behavior: lang_items::c_int,
    /// Internal data to prevent doing update_initial_durations() twice
    pub update_initial_durations_done: lang_items::c_int,
    /// Internal data to generate dts from pts
    pub pts_reorder_error: [i64; 17usize],
    pub pts_reorder_error_count: [u8; 17usize],
    /// Internal data to analyze DTS and detect faulty mpeg streams
    pub last_dts_for_order_check: i64,
    pub dts_ordered: u8,
    pub dts_misordered: u8,
    /// Internal data to inject global side data
    pub inject_global_side_data: lang_items::c_int,
    /// display aspect ratio (0 if unknown)
    /// - encoding: unused
    /// - decoding: Set by libavformat to calculate sample_aspect_ratio internally
    pub display_aspect_ratio: AVRational,
    /// An opaque field for libavformat internal usage.
    /// Must not be accessed in any way by callers.
    pub internal: *mut AVStreamInternal,
}
/// Stream information used internally by avformat_find_stream_info()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream__bindgen_ty_1 {
    pub last_dts: i64,
    pub duration_gcd: i64,
    pub duration_count: lang_items::c_int,
    pub rfps_duration_sum: i64,
    pub duration_error: *mut [[f64; 399usize]; 2usize],
    pub codec_info_duration: i64,
    pub codec_info_duration_fields: i64,
    pub frame_delay_evidence: lang_items::c_int,
    /// 0  -> decoder has not been searched for yet.
    /// >0 -> decoder found
    /// <0 -> decoder with codec_id == -found_decoder has not been found
    pub found_decoder: lang_items::c_int,
    pub last_duration: i64,
    /// Those are used for average framerate estimation.
    pub fps_first_dts: i64,
    pub fps_first_dts_idx: lang_items::c_int,
    pub fps_last_dts: i64,
    pub fps_last_dts_idx: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVStream__bindgen_ty_1() {
    assert_eq!(
        std::mem::size_of::<AVStream__bindgen_ty_1>(),
        104usize,
        concat!("Size of: ", stringify!(AVStream__bindgen_ty_1))
    );
    assert_eq!(
        std::mem::align_of::<AVStream__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).last_dts as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).duration_gcd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_gcd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).duration_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).rfps_duration_sum as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(rfps_duration_sum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).duration_error as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).codec_info_duration as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(codec_info_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).codec_info_duration_fields
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(codec_info_duration_fields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).frame_delay_evidence as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(frame_delay_evidence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).found_decoder as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(found_decoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).last_duration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(last_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).fps_first_dts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_first_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).fps_first_dts_idx as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_first_dts_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).fps_last_dts as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream__bindgen_ty_1>())).fps_last_dts_idx as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_last_dts_idx)
        )
    );
}
#[test]
fn bindgen_test_layout_AVStream() {
    assert_eq!(
        std::mem::size_of::<AVStream>(),
        760usize,
        concat!("Size of: ", stringify!(AVStream))
    );
    assert_eq!(
        std::mem::align_of::<AVStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).codec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).priv_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).time_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).start_time as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).duration as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).nb_frames as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).disposition as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(disposition)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).discard as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).sample_aspect_ratio as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).metadata as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).avg_frame_rate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(avg_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).attached_pic as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(attached_pic)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).side_data as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).nb_side_data as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).event_flags as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).r_frame_rate as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(r_frame_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).recommended_encoder_configuration as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(recommended_encoder_configuration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).codecpar as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codecpar)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).info as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).pts_wrap_bits as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).first_dts as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(first_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).cur_dts as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(cur_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).last_IP_pts as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_IP_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).last_IP_duration as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_IP_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).probe_packets as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(probe_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).codec_info_nb_frames as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codec_info_nb_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).need_parsing as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(need_parsing)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).parser as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).last_in_packet_buffer as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_in_packet_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).probe_data as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(probe_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).pts_buffer as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).index_entries as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).nb_index_entries as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_index_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).index_entries_allocated_size as *const _ as usize
        },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index_entries_allocated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).stream_identifier as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(stream_identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).interleaver_chunk_size as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(interleaver_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).interleaver_chunk_duration as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(interleaver_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).request_probe as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(request_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).skip_to_keyframe as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(skip_to_keyframe)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).skip_samples as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(skip_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).start_skip_samples as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_skip_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).first_discard_sample as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(first_discard_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).last_discard_sample as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_discard_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).nb_decoded_frames as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_decoded_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).mux_ts_offset as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(mux_ts_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).pts_wrap_reference as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).pts_wrap_behavior as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).update_initial_durations_done as *const _ as usize
        },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(update_initial_durations_done)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).pts_reorder_error as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_reorder_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).pts_reorder_error_count as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_reorder_error_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).last_dts_for_order_check as *const _ as usize
        },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_dts_for_order_check)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).dts_ordered as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(dts_ordered)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).dts_misordered as *const _ as usize },
        737usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(dts_misordered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVStream>())).inject_global_side_data as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(inject_global_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).display_aspect_ratio as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(display_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVStream>())).internal as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(internal)
        )
    );
}
extern "C" {
    /// Accessors for some AVStream fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_stream_get_r_frame_rate(s: *const AVStream) -> AVRational;
}
extern "C" {
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
}
extern "C" {
    pub fn av_stream_get_recommended_encoder_configuration(
        s: *const AVStream,
    ) -> *mut lang_items::c_char;
}
extern "C" {
    pub fn av_stream_set_recommended_encoder_configuration(
        s: *mut AVStream,
        configuration: *mut lang_items::c_char,
    );
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    /// Returns the pts of the last muxed packet + its duration
    ///
    /// the retuned value is undefined when used with a demuxer.
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVProgram) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProgram {
    pub id: lang_items::c_int,
    pub flags: lang_items::c_int,
    /// < selects which program to discard and which to feed to the caller
    pub discard: AVDiscard,
    pub stream_index: *mut lang_items::c_uint,
    pub nb_stream_indexes: lang_items::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: lang_items::c_int,
    pub pmt_pid: lang_items::c_int,
    pub pcr_pid: lang_items::c_int,
    /// All fields below this line are not part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub start_time: i64,
    pub end_time: i64,
    /// < reference dts for wrap detection
    pub pts_wrap_reference: i64,
    /// < behavior on wrap detection
    pub pts_wrap_behavior: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVProgram() {
    assert_eq!(
        std::mem::size_of::<AVProgram>(),
        88usize,
        concat!("Size of: ", stringify!(AVProgram))
    );
    assert_eq!(
        std::mem::align_of::<AVProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProgram))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).discard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).stream_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).nb_stream_indexes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(nb_stream_indexes)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).program_num as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(program_num)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).pmt_pid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).pcr_pid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pcr_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).start_time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).end_time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).pts_wrap_reference as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVProgram>())).pts_wrap_behavior as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChapter {
    /// < unique ID to identify the chapter
    pub id: lang_items::c_int,
    /// < time base in which the start/end timestamps are specified
    pub time_base: AVRational,
    /// < chapter start/end time in time_base units
    pub start: i64,
    /// < chapter start/end time in time_base units
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[test]
fn bindgen_test_layout_AVChapter() {
    assert_eq!(
        std::mem::size_of::<AVChapter>(),
        40usize,
        concat!("Size of: ", stringify!(AVChapter))
    );
    assert_eq!(
        std::mem::align_of::<AVChapter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChapter))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVChapter>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVChapter>())).time_base as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVChapter>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVChapter>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVChapter>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(metadata)
        )
    );
}
/// Callback used by devices to communicate with application.
pub type av_format_control_message = std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: lang_items::c_int,
        data: *mut lang_items::c_void,
        data_size: usize,
    ) -> lang_items::c_int,
>;
pub type AVOpenCallback = std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const lang_items::c_char,
        flags: lang_items::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int,
>;
/// < Duration accurately estimated from PTSes
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_PTS: AVDurationEstimationMethod = 0;
/// < Duration estimated from a stream with a known duration
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_STREAM: AVDurationEstimationMethod = 1;
/// < Duration estimated from bitrate (less accurate)
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_BITRATE: AVDurationEstimationMethod = 2;
/// The duration of a video can be estimated through various ways, and this enum can be used
/// to know how the duration was estimated.
pub type AVDurationEstimationMethod = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatInternal {
    _unused: [u8; 0],
}
/// Format I/O context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVFormatContext) must not be used outside libav*, use
/// avformat_alloc_context() to create an AVFormatContext.
///
/// Fields can be accessed through AVOptions (av_opt*),
/// the name string used matches the associated command line parameter name and
/// can be found in libavformat/options_table.h.
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFormatContext {
    /// A class for logging and @ref avoptions. Set by avformat_alloc_context().
    /// Exports (de)muxer private options if they exist.
    pub av_class: *const AVClass,
    /// The input container format.
    ///
    /// Demuxing only, set by avformat_open_input().
    pub iformat: *mut AVInputFormat,
    /// The output container format.
    ///
    /// Muxing only, must be set by the caller before avformat_write_header().
    pub oformat: *mut AVOutputFormat,
    /// Format private data. This is an AVOptions-enabled struct
    /// if and only if iformat/oformat.priv_class is not NULL.
    ///
    /// - muxing: set by avformat_write_header()
    /// - demuxing: set by avformat_open_input()
    pub priv_data: *mut lang_items::c_void,
    /// I/O context.
    ///
    /// - demuxing: either set by the user before avformat_open_input() (then
    /// the user must close it manually) or set by avformat_open_input().
    /// - muxing: set by the user before avformat_write_header(). The caller must
    /// take care of closing / freeing the IO context.
    ///
    /// Do NOT set this field if AVFMT_NOFILE flag is set in
    /// iformat/oformat.flags. In such a case, the (de)muxer will handle
    /// I/O in some other way and this field will be NULL.
    pub pb: *mut AVIOContext,
    /// Flags signalling stream properties. A combination of AVFMTCTX_*.
    /// Set by libavformat.
    pub ctx_flags: lang_items::c_int,
    /// Number of elements in AVFormatContext.streams.
    ///
    /// Set by avformat_new_stream(), must not be modified by any other code.
    pub nb_streams: lang_items::c_uint,
    /// A list of all streams in the file. New streams are created with
    /// avformat_new_stream().
    ///
    /// - demuxing: streams are created by libavformat in avformat_open_input().
    /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
    /// appear in av_read_frame().
    /// - muxing: streams are created by the user before avformat_write_header().
    ///
    /// Freed by libavformat in avformat_free_context().
    pub streams: *mut *mut AVStream,
    /// input or output filename
    ///
    /// - demuxing: set by avformat_open_input()
    /// - muxing: may be set by the caller before avformat_write_header()
    ///
    /// @deprecated Use url instead.
    pub filename: [lang_items::c_char; 1024usize],
    /// input or output URL. Unlike the old filename field, this field has no
    /// length restriction.
    ///
    /// - demuxing: set by avformat_open_input(), initialized to an empty
    /// string if url parameter was NULL in avformat_open_input().
    /// - muxing: may be set by the caller before calling avformat_write_header()
    /// (or avformat_init_output() if that is called first) to a string
    /// which is freeable by av_free(). Set to an empty string if it
    /// was NULL in avformat_init_output().
    ///
    /// Freed by libavformat in avformat_free_context().
    pub url: *mut lang_items::c_char,
    /// Position of the first frame of the component, in
    /// AV_TIME_BASE fractional seconds. NEVER set this value directly:
    /// It is deduced from the AVStream values.
    ///
    /// Demuxing only, set by libavformat.
    pub start_time: i64,
    /// Duration of the stream, in AV_TIME_BASE fractional
    /// seconds. Only set this value if you know none of the individual stream
    /// durations and also do not set any of them. This is deduced from the
    /// AVStream values if not set.
    ///
    /// Demuxing only, set by libavformat.
    pub duration: i64,
    /// Total stream bitrate in bit/s, 0 if not
    /// available. Never set it directly if the file_size and the
    /// duration are known as FFmpeg can compute it automatically.
    pub bit_rate: i64,
    pub packet_size: lang_items::c_uint,
    pub max_delay: lang_items::c_int,
    /// Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
    /// Set by the user before avformat_open_input() / avformat_write_header().
    pub flags: lang_items::c_int,
    /// Maximum size of the data read from input for determining
    /// the input container format.
    /// Demuxing only, set by the caller before avformat_open_input().
    pub probesize: i64,
    /// Maximum duration (in AV_TIME_BASE units) of the data read
    /// from input in avformat_find_stream_info().
    /// Demuxing only, set by the caller before avformat_find_stream_info().
    /// Can be set to 0 to let avformat choose using a heuristic.
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: lang_items::c_int,
    pub nb_programs: lang_items::c_uint,
    pub programs: *mut *mut AVProgram,
    /// Forced video codec_id.
    /// Demuxing: Set by user.
    pub video_codec_id: AVCodecID,
    /// Forced audio codec_id.
    /// Demuxing: Set by user.
    pub audio_codec_id: AVCodecID,
    /// Forced subtitle codec_id.
    /// Demuxing: Set by user.
    pub subtitle_codec_id: AVCodecID,
    /// Maximum amount of memory in bytes to use for the index of each stream.
    /// If the index exceeds this size, entries will be discarded as
    /// needed to maintain a smaller size. This can lead to slower or less
    /// accurate seeking (depends on demuxer).
    /// Demuxers for which a full in-memory index is mandatory will ignore
    /// this.
    /// - muxing: unused
    /// - demuxing: set by user
    pub max_index_size: lang_items::c_uint,
    /// Maximum amount of memory in bytes to use for buffering frames
    /// obtained from realtime capture devices.
    pub max_picture_buffer: lang_items::c_uint,
    /// Number of chapters in AVChapter array.
    /// When muxing, chapters are normally written in the file header,
    /// so nb_chapters should normally be initialized before write_header
    /// is called. Some muxers (e.g. mov and mkv) can also write chapters
    /// in the trailer.  To write chapters in the trailer, nb_chapters
    /// must be zero when write_header is called and non-zero when
    /// write_trailer is called.
    /// - muxing: set by user
    /// - demuxing: set by libavformat
    pub nb_chapters: lang_items::c_uint,
    pub chapters: *mut *mut AVChapter,
    /// Metadata that applies to the whole file.
    ///
    /// - demuxing: set by libavformat in avformat_open_input()
    /// - muxing: may be set by the caller before avformat_write_header()
    ///
    /// Freed by libavformat in avformat_free_context().
    pub metadata: *mut AVDictionary,
    /// Start time of the stream in real world time, in microseconds
    /// since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
    /// stream was captured at this real world time.
    /// - muxing: Set by the caller before avformat_write_header(). If set to
    /// either 0 or AV_NOPTS_VALUE, then the current wall-time will
    /// be used.
    /// - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
    /// the value may become known after some number of frames
    /// have been received.
    pub start_time_realtime: i64,
    /// The number of frames used for determining the framerate in
    /// avformat_find_stream_info().
    /// Demuxing only, set by the caller before avformat_find_stream_info().
    pub fps_probe_size: lang_items::c_int,
    /// Error recognition; higher values will detect more errors but may
    /// misdetect some more or less valid parts as errors.
    /// Demuxing only, set by the caller before avformat_open_input().
    pub error_recognition: lang_items::c_int,
    /// Custom interrupt callbacks for the I/O layer.
    ///
    /// demuxing: set by the user before avformat_open_input().
    /// muxing: set by the user before avformat_write_header()
    /// (mainly useful for AVFMT_NOFILE formats). The callback
    /// should also be passed to avio_open2() if it's used to
    /// open the file.
    pub interrupt_callback: AVIOInterruptCB,
    /// Flags to enable debugging.
    pub debug: lang_items::c_int,
    /// Maximum buffering duration for interleaving.
    ///
    /// To ensure all the streams are interleaved correctly,
    /// av_interleaved_write_frame() will wait until it has at least one packet
    /// for each stream before actually writing any packets to the output file.
    /// When some streams are "sparse" (i.e. there are large gaps between
    /// successive packets), this can result in excessive buffering.
    ///
    /// This field specifies the maximum difference between the timestamps of the
    /// first and the last packet in the muxing queue, above which libavformat
    /// will output a packet regardless of whether it has queued a packet for all
    /// the streams.
    ///
    /// Muxing only, set by the caller before avformat_write_header().
    pub max_interleave_delta: i64,
    /// Allow non-standard and experimental extension
    /// @see AVCodecContext.strict_std_compliance
    pub strict_std_compliance: lang_items::c_int,
    /// Flags for the user to detect events happening on the file. Flags must
    /// be cleared by the user once the event has been handled.
    /// A combination of AVFMT_EVENT_FLAG_*.
    pub event_flags: lang_items::c_int,
    /// Maximum number of packets to read while waiting for the first timestamp.
    /// Decoding only.
    pub max_ts_probe: lang_items::c_int,
    /// Avoid negative timestamps during muxing.
    /// Any value of the AVFMT_AVOID_NEG_TS_* constants.
    /// Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)
    /// - muxing: Set by user
    /// - demuxing: unused
    pub avoid_negative_ts: lang_items::c_int,
    /// Transport stream id.
    /// This will be moved into demuxer private options. Thus no API/ABI compatibility
    pub ts_id: lang_items::c_int,
    /// Audio preload in microseconds.
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub audio_preload: lang_items::c_int,
    /// Max chunk time in microseconds.
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub max_chunk_duration: lang_items::c_int,
    /// Max chunk size in bytes
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub max_chunk_size: lang_items::c_int,
    /// forces the use of wallclock timestamps as pts/dts of packets
    /// This has undefined results in the presence of B frames.
    /// - encoding: unused
    /// - decoding: Set by user
    pub use_wallclock_as_timestamps: lang_items::c_int,
    /// avio flags, used to force AVIO_FLAG_DIRECT.
    /// - encoding: unused
    /// - decoding: Set by user
    pub avio_flags: lang_items::c_int,
    /// The duration field can be estimated through various ways, and this field can be used
    /// to know how the duration was estimated.
    /// - encoding: unused
    /// - decoding: Read by user
    pub duration_estimation_method: AVDurationEstimationMethod,
    /// Skip initial bytes when opening stream
    /// - encoding: unused
    /// - decoding: Set by user
    pub skip_initial_bytes: i64,
    /// Correct single timestamp overflows
    /// - encoding: unused
    /// - decoding: Set by user
    pub correct_ts_overflow: lang_items::c_uint,
    /// Force seeking to any (also non key) frames.
    /// - encoding: unused
    /// - decoding: Set by user
    pub seek2any: lang_items::c_int,
    /// Flush the I/O context after each packet.
    /// - encoding: Set by user
    /// - decoding: unused
    pub flush_packets: lang_items::c_int,
    /// format probing score.
    /// The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
    /// the format.
    /// - encoding: unused
    /// - decoding: set by avformat, read by user
    pub probe_score: lang_items::c_int,
    /// number of bytes to read maximally to identify format.
    /// - encoding: unused
    /// - decoding: set by user
    pub format_probesize: lang_items::c_int,
    /// ',' separated list of allowed decoders.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub codec_whitelist: *mut lang_items::c_char,
    /// ',' separated list of allowed demuxers.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub format_whitelist: *mut lang_items::c_char,
    /// An opaque field for libavformat internal usage.
    /// Must not be accessed in any way by callers.
    pub internal: *mut AVFormatInternal,
    /// IO repositioned flag.
    /// This is set by avformat when the underlaying IO context read pointer
    /// is repositioned, for example when doing byte based seeking.
    /// Demuxers can use the flag to detect such changes.
    pub io_repositioned: lang_items::c_int,
    /// Forced video codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub video_codec: *mut AVCodec,
    /// Forced audio codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub audio_codec: *mut AVCodec,
    /// Forced subtitle codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub subtitle_codec: *mut AVCodec,
    /// Forced data codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub data_codec: *mut AVCodec,
    /// Number of bytes to be written as padding in a metadata header.
    /// Demuxing: Unused.
    /// Muxing: Set by user via av_format_set_metadata_header_padding.
    pub metadata_header_padding: lang_items::c_int,
    /// User data.
    /// This is a place for some private data of the user.
    pub opaque: *mut lang_items::c_void,
    /// Callback used by devices to communicate with application.
    pub control_message_cb: av_format_control_message,
    /// Output timestamp offset, in microseconds.
    /// Muxing: set by user
    pub output_ts_offset: i64,
    /// dump format separator.
    /// can be ", " or "\n      " or anything else
    /// - muxing: Set by user.
    /// - demuxing: Set by user.
    pub dump_separator: *mut u8,
    /// Forced Data codec_id.
    /// Demuxing: Set by user.
    pub data_codec_id: AVCodecID,
    /// Called to open further IO contexts when needed for demuxing.
    ///
    /// This can be set by the user application to perform security checks on
    /// the URLs before opening them.
    /// The function should behave like avio_open2(), AVFormatContext is provided
    /// as contextual information and to reach AVFormatContext.opaque.
    ///
    /// If NULL then some simple checks are used together with avio_open2().
    ///
    /// Must not be accessed directly from outside avformat.
    /// @See av_format_set_open_cb()
    ///
    /// Demuxing: Set by user.
    ///
    /// @deprecated Use io_open and io_close.
    pub open_cb: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            p: *mut *mut AVIOContext,
            url: *const lang_items::c_char,
            flags: lang_items::c_int,
            int_cb: *const AVIOInterruptCB,
            options: *mut *mut AVDictionary,
        ) -> lang_items::c_int,
    >,
    /// ',' separated list of allowed protocols.
    /// - encoding: unused
    /// - decoding: set by user
    pub protocol_whitelist: *mut lang_items::c_char,
    /// A callback for opening new IO streams.
    ///
    /// Whenever a muxer or a demuxer needs to open an IO stream (typically from
    /// avformat_open_input() for demuxers, but for certain formats can happen at
    /// other times as well), it will call this callback to obtain an IO context.
    ///
    /// @param s the format context
    /// @param pb on success, the newly opened IO context should be returned here
    /// @param url the url to open
    /// @param flags a combination of AVIO_FLAG_*
    /// @param options a dictionary of additional options, with the same
    /// semantics as in avio_open2()
    /// @return 0 on success, a negative AVERROR code on failure
    ///
    /// @note Certain muxers and demuxers do nesting, i.e. they open one or more
    /// additional internal format contexts. Thus the AVFormatContext pointer
    /// passed to this callback may be different from the one facing the caller.
    /// It will, however, have the same 'opaque' field.
    pub io_open: std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const lang_items::c_char,
            flags: lang_items::c_int,
            options: *mut *mut AVDictionary,
        ) -> lang_items::c_int,
    >,
    /// A callback for closing the streams opened with AVFormatContext.io_open().
    pub io_close:
        std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    /// ',' separated list of disallowed protocols.
    /// - encoding: unused
    /// - decoding: set by user
    pub protocol_blacklist: *mut lang_items::c_char,
    /// The maximum number of streams.
    /// - encoding: unused
    /// - decoding: set by user
    pub max_streams: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AVFormatContext() {
    assert_eq!(
        std::mem::size_of::<AVFormatContext>(),
        1496usize,
        concat!("Size of: ", stringify!(AVFormatContext))
    );
    assert_eq!(
        std::mem::align_of::<AVFormatContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFormatContext))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).iformat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(iformat)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).oformat as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(oformat)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).pb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(pb)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).ctx_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ctx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).nb_streams as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_streams)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).streams as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(streams)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).filename as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).url as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).start_time as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).duration as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).bit_rate as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).packet_size as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).max_delay as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).flags as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).probesize as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).max_analyze_duration as *const _ as usize
        },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_analyze_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).key as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).keylen as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).nb_programs as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_programs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).programs as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(programs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).video_codec_id as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).audio_codec_id as *const _ as usize },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).subtitle_codec_id as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).max_index_size as *const _ as usize },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_index_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).max_picture_buffer as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_picture_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).nb_chapters as *const _ as usize },
        1188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).chapters as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).metadata as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).start_time_realtime as *const _ as usize
        },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time_realtime)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).fps_probe_size as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(fps_probe_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).error_recognition as *const _ as usize
        },
        1220usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(error_recognition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).interrupt_callback as *const _ as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(interrupt_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).debug as *const _ as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).max_interleave_delta as *const _ as usize
        },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_interleave_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).strict_std_compliance as *const _ as usize
        },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).event_flags as *const _ as usize },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).max_ts_probe as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_ts_probe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).avoid_negative_ts as *const _ as usize
        },
        1268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avoid_negative_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).ts_id as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ts_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).audio_preload as *const _ as usize },
        1276usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_preload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).max_chunk_duration as *const _ as usize
        },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).max_chunk_size as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).use_wallclock_as_timestamps as *const _
                as usize
        },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(use_wallclock_as_timestamps)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).avio_flags as *const _ as usize },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avio_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).duration_estimation_method as *const _
                as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration_estimation_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).skip_initial_bytes as *const _ as usize
        },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_initial_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).correct_ts_overflow as *const _ as usize
        },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(correct_ts_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).seek2any as *const _ as usize },
        1316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(seek2any)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).flush_packets as *const _ as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flush_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).probe_score as *const _ as usize },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probe_score)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).format_probesize as *const _ as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_probesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).codec_whitelist as *const _ as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).format_whitelist as *const _ as usize
        },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).internal as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).io_repositioned as *const _ as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_repositioned)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).video_codec as *const _ as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).audio_codec as *const _ as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).subtitle_codec as *const _ as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).data_codec as *const _ as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).metadata_header_padding as *const _
                as usize
        },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata_header_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).opaque as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).control_message_cb as *const _ as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(control_message_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).output_ts_offset as *const _ as usize
        },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(output_ts_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).dump_separator as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).data_codec_id as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).open_cb as *const _ as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(open_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).protocol_whitelist as *const _ as usize
        },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).io_open as *const _ as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_open)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).io_close as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(std::ptr::null::<AVFormatContext>())).protocol_blacklist as *const _ as usize
        },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVFormatContext>())).max_streams as *const _ as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_streams)
        )
    );
}
extern "C" {
    /// Accessors for some AVFormatContext fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_format_get_probe_score(s: *const AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    pub fn av_format_get_video_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_video_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_audio_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_subtitle_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_data_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_data_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_metadata_header_padding(s: *const AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext, c: lang_items::c_int);
}
extern "C" {
    pub fn av_format_get_opaque(s: *const AVFormatContext) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn av_format_set_opaque(s: *mut AVFormatContext, opaque: *mut lang_items::c_void);
}
extern "C" {
    pub fn av_format_get_control_message_cb(s: *const AVFormatContext)
        -> av_format_control_message;
}
extern "C" {
    pub fn av_format_set_control_message_cb(
        s: *mut AVFormatContext,
        callback: av_format_control_message,
    );
}
extern "C" {
    pub fn av_format_get_open_cb(s: *const AVFormatContext) -> AVOpenCallback;
}
extern "C" {
    pub fn av_format_set_open_cb(s: *mut AVFormatContext, callback: AVOpenCallback);
}
extern "C" {
    /// This function will cause global side data to be injected in the next packet
    /// of each stream as well as after any subsequent seek.
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    /// Returns the method used to set ctx->duration.
    ///
    /// @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[test]
fn bindgen_test_layout_AVPacketList() {
    assert_eq!(
        std::mem::size_of::<AVPacketList>(),
        96usize,
        concat!("Size of: ", stringify!(AVPacketList))
    );
    assert_eq!(
        std::mem::align_of::<AVPacketList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketList))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacketList>())).pkt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(pkt)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<AVPacketList>())).next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    /// Return the LIBAVFORMAT_VERSION_INT constant.
    pub fn avformat_version() -> lang_items::c_uint;
}
extern "C" {
    /// Return the libavformat build-time configuration.
    pub fn avformat_configuration() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the libavformat license.
    pub fn avformat_license() -> *const lang_items::c_char;
}
extern "C" {
    /// Initialize libavformat and register all the muxers, demuxers and
    /// protocols. If you do not call this function, then you can select
    /// exactly which formats you want to support.
    ///
    /// @see av_register_input_format()
    /// @see av_register_output_format()
    pub fn av_register_all();
}
extern "C" {
    pub fn av_register_input_format(format: *mut AVInputFormat);
}
extern "C" {
    pub fn av_register_output_format(format: *mut AVOutputFormat);
}
extern "C" {
    /// Do global initialization of network libraries. This is optional,
    /// and not recommended anymore.
    ///
    /// This functions only exists to work around thread-safety issues
    /// with older GnuTLS or OpenSSL libraries. If libavformat is linked
    /// to newer versions of those libraries, or if you do not use them,
    /// calling this function is unnecessary. Otherwise, you need to call
    /// this function before any other threads using them are started.
    ///
    /// This function will be deprecated once support for older GnuTLS and
    /// OpenSSL libraries is removed, and this function has no purpose
    /// anymore.
    pub fn avformat_network_init() -> lang_items::c_int;
}
extern "C" {
    /// Undo the initialization done by avformat_network_init. Call it only
    /// once for each time you called avformat_network_init.
    pub fn avformat_network_deinit() -> lang_items::c_int;
}
extern "C" {
    /// If f is NULL, returns the first registered input format,
    /// if f is non-NULL, returns the next registered input format after f
    /// or NULL if f is the last one.
    pub fn av_iformat_next(f: *const AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    /// If f is NULL, returns the first registered output format,
    /// if f is non-NULL, returns the next registered output format after f
    /// or NULL if f is the last one.
    pub fn av_oformat_next(f: *const AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    /// Iterate over all registered muxers.
    ///
    /// @param opaque a pointer where libavformat will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered muxer or NULL when the iteration is
    /// finished
    pub fn av_muxer_iterate(opaque: *mut *mut lang_items::c_void) -> *const AVOutputFormat;
}
extern "C" {
    /// Iterate over all registered demuxers.
    ///
    /// @param opaque a pointer where libavformat will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered demuxer or NULL when the iteration is
    /// finished
    pub fn av_demuxer_iterate(opaque: *mut *mut lang_items::c_void) -> *const AVInputFormat;
}
extern "C" {
    /// Allocate an AVFormatContext.
    /// avformat_free_context() can be used to free the context and everything
    /// allocated by the framework within it.
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    /// Free an AVFormatContext and all its streams.
    /// @param s context to free
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    /// Get the AVClass for AVFormatContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    /// Add a new stream to a media file.
    ///
    /// When demuxing, it is called by the demuxer in read_header(). If the
    /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
    /// be called in read_packet().
    ///
    /// When muxing, should be called by the user before avformat_write_header().
    ///
    /// User is required to call avcodec_close() and avformat_free_context() to
    /// clean up the allocation by avformat_new_stream().
    ///
    /// @param s media file handle
    /// @param c If non-NULL, the AVCodecContext corresponding to the new stream
    /// will be initialized to use this codec. This is needed for e.g. codec-specific
    /// defaults to be set, so codec should be provided if it is known.
    ///
    /// @return newly created stream or NULL on error.
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    /// Wrap an existing array as stream side data.
    ///
    /// @param st stream
    /// @param type side information type
    /// @param data the side data array. It must be allocated with the av_malloc()
    /// family of functions. The ownership of the data is transferred to
    /// st.
    /// @param size side information size
    /// @return zero on success, a negative AVERROR code on failure. On failure,
    /// the stream is unchanged and the data remains owned by the caller.
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate new information from stream.
    ///
    /// @param stream stream
    /// @param type desired side information type
    /// @param size side information size
    /// @return pointer to fresh allocated data or NULL otherwise
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: lang_items::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Get side information from stream.
    ///
    /// @param stream stream
    /// @param type desired side information type
    /// @param size pointer for side information size to store (optional)
    /// @return pointer to data if present or NULL otherwise
    pub fn av_stream_get_side_data(
        stream: *const AVStream,
        type_: AVPacketSideDataType,
        size: *mut lang_items::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: lang_items::c_int) -> *mut AVProgram;
}
extern "C" {
    /// Allocate an AVFormatContext for an output format.
    /// avformat_free_context() can be used to free the context and
    /// everything allocated by the framework within it.
    ///
    /// @param *ctx is set to the created format context, or to NULL in
    /// case of failure
    /// @param oformat format to use for allocating the context, if NULL
    /// format_name and filename are used instead
    /// @param format_name the name of output format to use for allocating the
    /// context, if NULL filename is used instead
    /// @param filename the name of the filename to use for allocating the
    /// context, may be NULL
    /// @return >= 0 in case of success, a negative AVERROR code in case of
    /// failure
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *mut AVOutputFormat,
        format_name: *const lang_items::c_char,
        filename: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Find AVInputFormat based on the short name of the input format.
    pub fn av_find_input_format(short_name: *const lang_items::c_char) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param pd        data to be probed
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    pub fn av_probe_input_format(
        pd: *mut AVProbeData,
        is_opened: lang_items::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param pd        data to be probed
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    /// @param score_max A probe score larger that this is required to accept a
    /// detection, the variable is set to the actual detection
    /// score afterwards.
    /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
    /// to retry with a larger probe buffer.
    pub fn av_probe_input_format2(
        pd: *mut AVProbeData,
        is_opened: lang_items::c_int,
        score_max: *mut lang_items::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    /// @param score_ret The score of the best detection.
    pub fn av_probe_input_format3(
        pd: *mut AVProbeData,
        is_opened: lang_items::c_int,
        score_ret: *mut lang_items::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Probe a bytestream to determine the input format. Each time a probe returns
    /// with a score that is too low, the probe buffer size is increased and another
    /// attempt is made. When the maximum probe size is reached, the input format
    /// with the highest score is returned.
    ///
    /// @param pb the bytestream to probe
    /// @param fmt the input format is put here
    /// @param url the url of the stream
    /// @param logctx the log context
    /// @param offset the offset within the bytestream to probe from
    /// @param max_probe_size the maximum probe buffer size (zero for default)
    /// @return the score in case of success, a negative value corresponding to an
    /// the maximal score is AVPROBE_SCORE_MAX
    /// AVERROR code otherwise
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const lang_items::c_char,
        logctx: *mut lang_items::c_void,
        offset: lang_items::c_uint,
        max_probe_size: lang_items::c_uint,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Like av_probe_input_buffer2() but returns 0 on success
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const lang_items::c_char,
        logctx: *mut lang_items::c_void,
        offset: lang_items::c_uint,
        max_probe_size: lang_items::c_uint,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Open an input stream and read the header. The codecs are not opened.
    /// The stream must be closed with avformat_close_input().
    ///
    /// @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
    /// May be a pointer to NULL, in which case an AVFormatContext is allocated by this
    /// function and written into ps.
    /// Note that a user-supplied AVFormatContext will be freed on failure.
    /// @param url URL of the stream to open.
    /// @param fmt If non-NULL, this parameter forces a specific input format.
    /// Otherwise the format is autodetected.
    /// @param options  A dictionary filled with AVFormatContext and demuxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return 0 on success, a negative AVERROR on failure.
    ///
    /// @note If you want to use custom IO, preallocate the format context and set its pb field.
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const lang_items::c_char,
        fmt: *mut AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Read packets of a media file to get stream information. This
    /// is useful for file formats with no headers such as MPEG. This
    /// function also computes the real framerate in case of MPEG-2 repeat
    /// frame mode.
    /// The logical file position is not changed by this function;
    /// examined packets may be buffered for later processing.
    ///
    /// @param ic media file handle
    /// @param options  If non-NULL, an ic.nb_streams long array of pointers to
    /// dictionaries, where i-th member contains options for
    /// codec corresponding to i-th stream.
    /// On return each dictionary will be filled with options that were not found.
    /// @return >=0 if OK, AVERROR_xxx on error
    ///
    /// @note this function isn't guaranteed to open all the codecs, so
    /// options being non-empty at return is a perfectly normal behavior.
    ///
    /// @todo Let the user decide somehow what information is needed so that
    /// we do not waste time getting stuff the user does not need.
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Find the programs which belong to a given stream.
    ///
    /// @param ic    media file handle
    /// @param last  the last found program, the search will start after this
    /// program, or from the beginning if it is NULL
    /// @param s     stream index
    /// @return the next program which belongs to s, NULL if no program is found or
    /// the last program is not among the programs of ic.
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: lang_items::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: lang_items::c_int,
        idx: lang_items::c_uint,
    );
}
extern "C" {
    /// Find the "best" stream in the file.
    /// The best stream is determined according to various heuristics as the most
    /// likely to be what the user expects.
    /// If the decoder parameter is non-NULL, av_find_best_stream will find the
    /// default decoder for the stream's codec; streams for which no decoder can
    /// be found are ignored.
    ///
    /// @param ic                media file handle
    /// @param type              stream type: video, audio, subtitles, etc.
    /// @param wanted_stream_nb  user-requested stream number,
    /// or -1 for automatic selection
    /// @param related_stream    try to find a stream related (eg. in the same
    /// program) to this one, or -1 if none
    /// @param decoder_ret       if non-NULL, returns the decoder for the
    /// selected stream
    /// @param flags             flags; none are currently defined
    /// @return  the non-negative stream number in case of success,
    /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
    /// could be found,
    /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
    /// @note  If av_find_best_stream returns successfully and decoder_ret is not
    /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: lang_items::c_int,
        related_stream: lang_items::c_int,
        decoder_ret: *mut *mut AVCodec,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return the next frame of a stream.
    /// This function returns what is stored in the file, and does not validate
    /// that what is there are valid frames for the decoder. It will split what is
    /// stored in the file into frames and return one for each call. It will not
    /// omit invalid data between valid frames so as to give the decoder the maximum
    /// information possible for decoding.
    ///
    /// If pkt->buf is NULL, then the packet is valid until the next
    /// av_read_frame() or until avformat_close_input(). Otherwise the packet
    /// is valid indefinitely. In both cases the packet must be freed with
    /// av_packet_unref when it is no longer needed. For video, the packet contains
    /// exactly one frame. For audio, it contains an integer number of frames if each
    /// frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames
    /// have a variable size (e.g. MPEG audio), then it contains one frame.
    ///
    /// pkt->pts, pkt->dts and pkt->duration are always set to correct
    /// values in AVStream.time_base units (and guessed if the format cannot
    /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
    /// has B-frames, so it is better to rely on pkt->dts if you do not
    /// decompress the payload.
    ///
    /// @return 0 if OK, < 0 on error or end of file
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Seek to the keyframe at timestamp.
    /// 'timestamp' in 'stream_index'.
    ///
    /// @param s media file handle
    /// @param stream_index If stream_index is (-1), a default
    /// stream is selected, and timestamp is automatically converted
    /// from AV_TIME_BASE units to the stream specific time_base.
    /// @param timestamp Timestamp in AVStream.time_base units
    /// or, if no stream is specified, in AV_TIME_BASE units.
    /// @param flags flags which select direction and seeking mode
    /// @return >= 0 on success
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: lang_items::c_int,
        timestamp: i64,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Seek to timestamp ts.
    /// Seeking will be done so that the point from which all active streams
    /// can be presented successfully will be closest to ts and within min/max_ts.
    /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
    ///
    /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
    /// are the file position (this may not be supported by all demuxers).
    /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
    /// in the stream with stream_index (this may not be supported by all demuxers).
    /// Otherwise all timestamps are in units of the stream selected by stream_index
    /// or if stream_index is -1, in AV_TIME_BASE units.
    /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
    /// keyframes (this may not be supported by all demuxers).
    /// If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
    ///
    /// @param s media file handle
    /// @param stream_index index of the stream which is used as time base reference
    /// @param min_ts smallest acceptable timestamp
    /// @param ts target timestamp
    /// @param max_ts largest acceptable timestamp
    /// @param flags flags
    /// @return >=0 on success, error code otherwise
    ///
    /// @note This is part of the new seek API which is still under construction.
    /// Thus do not use this yet. It may change at any time, do not expect
    /// ABI compatibility yet!
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: lang_items::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Discard all internally buffered data. This can be useful when dealing with
    /// discontinuities in the byte stream. Generally works only with formats that
    /// can resync. This includes headerless formats like MPEG-TS/TS but should also
    /// work with NUT, Ogg and in a limited way AVI for example.
    ///
    /// The set of streams, the detected duration, stream parameters and codecs do
    /// not change when calling this function. If you want a complete reset, it's
    /// better to open a new AVFormatContext.
    ///
    /// This does not flush the AVIOContext (s->pb). If necessary, call
    /// avio_flush(s->pb) before calling this function.
    ///
    /// @param s media file handle
    /// @return >=0 on success, error code otherwise
    pub fn avformat_flush(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Start playing a network-based stream (e.g. RTSP stream) at the
    /// current position.
    pub fn av_read_play(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Pause a network-based stream (e.g. RTSP stream).
    ///
    /// Use av_read_play() to resume it.
    pub fn av_read_pause(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Close an opened input AVFormatContext. Free it and all its contents
    /// and set *s to NULL.
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    /// Allocate the stream private data and write the stream header to
    /// an output media file.
    ///
    /// @param s Media file handle, must be allocated with avformat_alloc_context().
    /// Its oformat field must be set to the desired output format;
    /// Its pb field must be set to an already opened AVIOContext.
    /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
    /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
    /// negative AVERROR on failure.
    ///
    /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate the stream private data and initialize the codec, but do not write the header.
    /// May optionally be used before avformat_write_header to initialize stream parameters
    /// before actually writing the header.
    /// If using this function, do not pass the same options to avformat_write_header.
    ///
    /// @param s Media file handle, must be allocated with avformat_alloc_context().
    /// Its oformat field must be set to the desired output format;
    /// Its pb field must be set to an already opened AVIOContext.
    /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
    /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
    /// negative AVERROR on failure.
    ///
    /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Write a packet to an output media file.
    ///
    /// This function passes the packet directly to the muxer, without any buffering
    /// or reordering. The caller is responsible for correctly interleaving the
    /// packets if the format requires it. Callers that want libavformat to handle
    /// the interleaving should call av_interleaved_write_frame() instead of this
    /// function.
    ///
    /// @param s media file handle
    /// @param pkt The packet containing the data to be written. Note that unlike
    /// av_interleaved_write_frame(), this function does not take
    /// ownership of the packet passed to it (though some muxers may make
    /// an internal reference to the input packet).
    /// <br>
    /// This parameter can be NULL (at any time, not just at the end), in
    /// order to immediately flush data buffered within the muxer, for
    /// muxers that buffer up data internally before writing it to the
    /// output.
    /// <br>
    /// Packet's @ref AVPacket.stream_index "stream_index" field must be
    /// set to the index of the corresponding stream in @ref
    /// AVFormatContext.streams "s->streams".
    /// <br>
    /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
    /// must be set to correct values in the stream's timebase (unless the
    /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
    /// they can be set to AV_NOPTS_VALUE).
    /// The dts for subsequent packets passed to this function must be strictly
    /// increasing when compared in their respective timebases (unless the
    /// output format is flagged with the AVFMT_TS_NONSTRICT, then they
    /// merely have to be nondecreasing).  @ref AVPacket.duration
    /// "duration") should also be set if known.
    /// @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
    ///
    /// @see av_interleaved_write_frame()
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> lang_items::c_int;
}
extern "C" {
    /// Write a packet to an output media file ensuring correct interleaving.
    ///
    /// This function will buffer the packets internally as needed to make sure the
    /// packets in the output file are properly interleaved in the order of
    /// increasing dts. Callers doing their own interleaving should call
    /// av_write_frame() instead of this function.
    ///
    /// Using this function instead of av_write_frame() can give muxers advance
    /// knowledge of future packets, improving e.g. the behaviour of the mp4
    /// muxer for VFR content in fragmenting mode.
    ///
    /// @param s media file handle
    /// @param pkt The packet containing the data to be written.
    /// <br>
    /// If the packet is reference-counted, this function will take
    /// ownership of this reference and unreference it later when it sees
    /// fit.
    /// The caller must not access the data through this reference after
    /// this function returns. If the packet is not reference-counted,
    /// libavformat will make a copy.
    /// <br>
    /// This parameter can be NULL (at any time, not just at the end), to
    /// flush the interleaving queues.
    /// <br>
    /// Packet's @ref AVPacket.stream_index "stream_index" field must be
    /// set to the index of the corresponding stream in @ref
    /// AVFormatContext.streams "s->streams".
    /// <br>
    /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
    /// must be set to correct values in the stream's timebase (unless the
    /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
    /// they can be set to AV_NOPTS_VALUE).
    /// The dts for subsequent packets in one stream must be strictly
    /// increasing (unless the output format is flagged with the
    /// AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
    /// @ref AVPacket.duration "duration") should also be set if known.
    ///
    /// @return 0 on success, a negative AVERROR on error. Libavformat will always
    /// take care of freeing the packet, even if this function fails.
    ///
    /// @see av_write_frame(), AVFormatContext.max_interleave_delta
    pub fn av_interleaved_write_frame(
        s: *mut AVFormatContext,
        pkt: *mut AVPacket,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Write an uncoded frame to an output media file.
    ///
    /// The frame must be correctly interleaved according to the container
    /// specification; if not, then av_interleaved_write_frame() must be used.
    ///
    /// See av_interleaved_write_frame() for details.
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: lang_items::c_int,
        frame: *mut AVFrame,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Write an uncoded frame to an output media file.
    ///
    /// If the muxer supports it, this function makes it possible to write an AVFrame
    /// structure directly, without encoding it into a packet.
    /// It is mostly useful for devices and similar special muxers that use raw
    /// video or PCM data and will not serialize it into a byte stream.
    ///
    /// To test whether it is possible to use it with a given muxer and stream,
    /// use av_write_uncoded_frame_query().
    ///
    /// The caller gives up ownership of the frame and must not access it
    /// afterwards.
    ///
    /// @return  >=0 for success, a negative code on error
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: lang_items::c_int,
        frame: *mut AVFrame,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Test whether a muxer supports uncoded frame.
    ///
    /// @return  >=0 if an uncoded frame can be written to that muxer and stream,
    /// <0 if not
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Write the stream trailer to an output media file and free the
    /// file private data.
    ///
    /// May only be called after a successful call to avformat_write_header.
    ///
    /// @param s media file handle
    /// @return 0 if OK, AVERROR_xxx on error
    pub fn av_write_trailer(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Return the output format in the list of registered output formats
    /// which best matches the provided parameters, or return NULL if
    /// there is no match.
    ///
    /// @param short_name if non-NULL checks if short_name matches with the
    /// names of the registered formats
    /// @param filename if non-NULL checks if filename terminates with the
    /// extensions of the registered formats
    /// @param mime_type if non-NULL checks if mime_type matches with the
    /// MIME type of the registered formats
    pub fn av_guess_format(
        short_name: *const lang_items::c_char,
        filename: *const lang_items::c_char,
        mime_type: *const lang_items::c_char,
    ) -> *mut AVOutputFormat;
}
extern "C" {
    /// Guess the codec ID based upon muxer and filename.
    pub fn av_guess_codec(
        fmt: *mut AVOutputFormat,
        short_name: *const lang_items::c_char,
        filename: *const lang_items::c_char,
        mime_type: *const lang_items::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    /// Get timing information for the data currently output.
    /// The exact meaning of "currently output" depends on the format.
    /// It is mostly relevant for devices that have an internal buffer and/or
    /// work in real time.
    /// @param s          media file handle
    /// @param stream     stream in the media file
    /// @param[out] dts   DTS of the last packet output for the stream, in stream
    /// time_base units
    /// @param[out] wall  absolute time when that packet whas output,
    /// in microsecond
    /// @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
    /// Note: some formats or devices may not allow to measure dts and wall
    /// atomically.
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: lang_items::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Send a nice hexadecimal dump of a buffer to the specified file stream.
    ///
    /// @param f The file stream pointer where the dump should be sent to.
    /// @param buf buffer
    /// @param size buffer size
    ///
    /// @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: lang_items::c_int);
}
extern "C" {
    /// Send a nice hexadecimal dump of a buffer to the log.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message, lower values signifying
    /// higher importance.
    /// @param buf buffer
    /// @param size buffer size
    ///
    /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
    pub fn av_hex_dump_log(
        avcl: *mut lang_items::c_void,
        level: lang_items::c_int,
        buf: *const u8,
        size: lang_items::c_int,
    );
}
extern "C" {
    /// Send a nice dump of a packet to the specified file stream.
    ///
    /// @param f The file stream pointer where the dump should be sent to.
    /// @param pkt packet to dump
    /// @param dump_payload True if the payload must be displayed, too.
    /// @param st AVStream that the packet belongs to
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: lang_items::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    /// Send a nice dump of a packet to the log.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message, lower values signifying
    /// higher importance.
    /// @param pkt packet to dump
    /// @param dump_payload True if the payload must be displayed, too.
    /// @param st AVStream that the packet belongs to
    pub fn av_pkt_dump_log2(
        avcl: *mut lang_items::c_void,
        level: lang_items::c_int,
        pkt: *const AVPacket,
        dump_payload: lang_items::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    /// Get the AVCodecID for the given codec tag tag.
    /// If no codec id is found returns AV_CODEC_ID_NONE.
    ///
    /// @param tags list of supported codec_id-codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param tag  codec tag to match to a codec ID
    pub fn av_codec_get_id(tags: *const *const AVCodecTag, tag: lang_items::c_uint) -> AVCodecID;
}
extern "C" {
    /// Get the codec tag for the given codec id id.
    /// If no codec tag is found returns 0.
    ///
    /// @param tags list of supported codec_id-codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param id   codec ID to match to a codec tag
    pub fn av_codec_get_tag(tags: *const *const AVCodecTag, id: AVCodecID) -> lang_items::c_uint;
}
extern "C" {
    /// Get the codec tag for the given codec id.
    ///
    /// @param tags list of supported codec_id - codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param id codec id that should be searched for in the list
    /// @param tag A pointer to the found tag
    /// @return 0 if id was not found in tags, > 0 if it was found
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut lang_items::c_uint,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Get the index for a specific timestamp.
    ///
    /// @param st        stream that the timestamp belongs to
    /// @param timestamp timestamp to retrieve the index for
    /// @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
    /// to the timestamp which is <= the requested one, if backward
    /// is 0, then it will be >=
    /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
    /// @return < 0 if no such timestamp could be found
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Add an index entry into a sorted list. Update the entry if the list
    /// already contains it.
    ///
    /// @param timestamp timestamp in the time base of the given stream
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: lang_items::c_int,
        distance: lang_items::c_int,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Split a URL string into components.
    ///
    /// The pointers to buffers for storing individual components may be null,
    /// in order to ignore that component. Buffers for components not found are
    /// set to empty strings. If the port is not found, it is set to a negative
    /// value.
    ///
    /// @param proto the buffer for the protocol
    /// @param proto_size the size of the proto buffer
    /// @param authorization the buffer for the authorization
    /// @param authorization_size the size of the authorization buffer
    /// @param hostname the buffer for the host name
    /// @param hostname_size the size of the hostname buffer
    /// @param port_ptr a pointer to store the port number in
    /// @param path the buffer for the path
    /// @param path_size the size of the path buffer
    /// @param url the URL to split
    pub fn av_url_split(
        proto: *mut lang_items::c_char,
        proto_size: lang_items::c_int,
        authorization: *mut lang_items::c_char,
        authorization_size: lang_items::c_int,
        hostname: *mut lang_items::c_char,
        hostname_size: lang_items::c_int,
        port_ptr: *mut lang_items::c_int,
        path: *mut lang_items::c_char,
        path_size: lang_items::c_int,
        url: *const lang_items::c_char,
    );
}
extern "C" {
    /// Print detailed information about the input or output format, such as
    /// duration, bitrate, streams, container, programs, metadata, side data,
    /// codec and time base.
    ///
    /// @param ic        the context to analyze
    /// @param index     index of the stream to dump information about
    /// @param url       the URL to print, such as source or destination file
    /// @param is_output Select whether the specified context is an input(0) or output(1)
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: lang_items::c_int,
        url: *const lang_items::c_char,
        is_output: lang_items::c_int,
    );
}
extern "C" {
    /// Return in 'buf' the path with '%d' replaced by a number.
    ///
    /// Also handles the '%0nd' format where 'n' is the total number
    /// of digits and '%%'.
    ///
    /// @param buf destination buffer
    /// @param buf_size destination buffer size
    /// @param path numbered sequence string
    /// @param number frame number
    /// @param flags AV_FRAME_FILENAME_FLAGS_*
    /// @return 0 if OK, -1 on format error
    pub fn av_get_frame_filename2(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        path: *const lang_items::c_char,
        number: lang_items::c_int,
        flags: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut lang_items::c_char,
        buf_size: lang_items::c_int,
        path: *const lang_items::c_char,
        number: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Check whether filename actually is a numbered sequence generator.
    ///
    /// @param filename possible numbered sequence string
    /// @return 1 if a valid numbered sequence string, 0 otherwise
    pub fn av_filename_number_test(filename: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Generate an SDP for an RTP session.
    ///
    /// Note, this overwrites the id values of AVStreams in the muxer contexts
    /// for getting unique dynamic payload types.
    ///
    /// @param ac array of AVFormatContexts describing the RTP streams. If the
    /// array is composed by only one context, such context can contain
    /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
    /// all the contexts in the array (an AVCodecContext per RTP stream)
    /// must contain only one AVStream.
    /// @param n_files number of AVCodecContexts contained in ac
    /// @param buf buffer where the SDP will be stored (must be allocated by
    /// the caller)
    /// @param size the size of the buffer
    /// @return 0 if OK, AVERROR_xxx on error
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: lang_items::c_int,
        buf: *mut lang_items::c_char,
        size: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return a positive value if the given filename has one of the given
    /// extensions, 0 otherwise.
    ///
    /// @param filename   file name to check against the given extensions
    /// @param extensions a comma-separated list of filename extensions
    pub fn av_match_ext(
        filename: *const lang_items::c_char,
        extensions: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Test if the given container can store a codec.
    ///
    /// @param ofmt           container to check for compatibility
    /// @param codec_id       codec to potentially store in container
    /// @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
    ///
    /// @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
    /// A negative number if this information is not available.
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @defgroup riff_fourcc RIFF FourCCs
    /// @{
    /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
    /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
    /// following code:
    /// @code
    /// uint32_t tag = MKTAG('H', '2', '6', '4');
    /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
    /// enum AVCodecID id = av_codec_get_id(table, tag);
    /// @endcode
    /// /
    /// /**
    /// @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping RIFF FourCCs for audio to AVCodecID.
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping MOV FourCCs for audio to AVCodecID.
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /// Guess the sample aspect ratio of a frame, based on both the stream and the
    /// frame aspect ratio.
    ///
    /// Since the frame aspect ratio is set by the codec but the stream aspect ratio
    /// is set by the demuxer, these two may not be equal. This function tries to
    /// return the value that you should use if you would like to display the frame.
    ///
    /// Basic logic is to use the stream aspect ratio if it is set to something sane
    /// otherwise use the frame aspect ratio. This way a container setting, which is
    /// usually easy to modify can override the coded value in the frames.
    ///
    /// @param format the format context which the stream is part of
    /// @param stream the stream which the frame is part of
    /// @param frame the frame with the aspect ratio to be determined
    /// @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    /// Guess the frame rate, based on both the container and codec information.
    ///
    /// @param ctx the format context which the stream is part of
    /// @param stream the stream which the frame is part of
    /// @param frame the frame for which the frame rate should be determined, may be NULL
    /// @return the guessed (valid) frame rate, 0/1 if no idea
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    /// Check if the stream st contained in s is matched by the stream specifier
    /// spec.
    ///
    /// See the "stream specifiers" chapter in the documentation for the syntax
    /// of spec.
    ///
    /// @return  >0 if st is matched by spec;
    /// 0  if st is not matched by spec;
    /// AVERROR code if spec is invalid
    ///
    /// @note  A stream specifier can match several streams in the format.
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const lang_items::c_char,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> lang_items::c_int;
}
extern "C" {
    /// Apply a list of bitstream filters to a packet.
    ///
    /// @param codec AVCodecContext, usually from an AVStream
    /// @param pkt the packet to apply filters to. If, on success, the returned
    /// packet has size == 0 and side_data_elems == 0, it indicates that
    /// the packet should be dropped
    /// @param bsfc a NULL-terminated list of filters to apply
    /// @return  >=0 on success;
    /// AVERROR code on failure
    pub fn av_apply_bitstream_filters(
        codec: *mut AVCodecContext,
        pkt: *mut AVPacket,
        bsfc: *mut AVBitStreamFilterContext,
    ) -> lang_items::c_int;
}
pub const AVTimebaseSource_AVFMT_TBCF_AUTO: AVTimebaseSource = -1;
pub const AVTimebaseSource_AVFMT_TBCF_DECODER: AVTimebaseSource = 0;
pub const AVTimebaseSource_AVFMT_TBCF_DEMUXER: AVTimebaseSource = 1;
pub const AVTimebaseSource_AVFMT_TBCF_R_FRAMERATE: AVTimebaseSource = 2;
pub type AVTimebaseSource = i32;
extern "C" {
    /// Transfer internal timing information from one stream to another.
    ///
    /// This function is useful when doing stream copy.
    ///
    /// @param ofmt     target output format for ost
    /// @param ost      output stream which needs timings copy and adjustments
    /// @param ist      reference input stream to copy timings from
    /// @param copy_tb  define from where the stream codec timebase needs to be imported
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Get the internal codec timebase from a stream.
    ///
    /// @param st  input stream to extract the timebase from
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
extern "C" {
    /// @defgroup libsws libswscale
    /// Color conversion and scaling library.
    ///
    /// @{
    ///
    /// Return the LIBSWSCALE_VERSION_INT constant.
    pub fn swscale_version() -> lang_items::c_uint;
}
extern "C" {
    /// Return the libswscale build-time configuration.
    pub fn swscale_configuration() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the libswscale license.
    pub fn swscale_license() -> *const lang_items::c_char;
}
extern "C" {
    /// Return a pointer to yuv<->rgb coefficients for the given colorspace
    /// suitable for sws_setColorspaceDetails().
    ///
    /// @param colorspace One of the SWS_CS_* macros. If invalid,
    /// SWS_CS_DEFAULT is used.
    pub fn sws_getCoefficients(colorspace: lang_items::c_int) -> *const lang_items::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsVector {
    /// < pointer to the list of coefficients
    pub coeff: *mut f64,
    /// < number of coefficients in the vector
    pub length: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_SwsVector() {
    assert_eq!(
        std::mem::size_of::<SwsVector>(),
        16usize,
        concat!("Size of: ", stringify!(SwsVector))
    );
    assert_eq!(
        std::mem::align_of::<SwsVector>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsVector))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsVector>())).coeff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsVector>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[test]
fn bindgen_test_layout_SwsFilter() {
    assert_eq!(
        std::mem::size_of::<SwsFilter>(),
        32usize,
        concat!("Size of: ", stringify!(SwsFilter))
    );
    assert_eq!(
        std::mem::align_of::<SwsFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsFilter))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsFilter>())).lumH as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumH)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsFilter>())).lumV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumV)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsFilter>())).chrH as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrH)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<SwsFilter>())).chrV as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Return a positive value if pix_fmt is a supported input format, 0
    /// otherwise.
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> lang_items::c_int;
}
extern "C" {
    /// Return a positive value if pix_fmt is a supported output format, 0
    /// otherwise.
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> lang_items::c_int;
}
extern "C" {
    /// @param[in]  pix_fmt the pixel format
    /// @return a positive value if an endianness conversion for pix_fmt is
    /// supported, 0 otherwise.
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> lang_items::c_int;
}
extern "C" {
    /// Allocate an empty SwsContext. This must be filled and passed to
    /// sws_init_context(). For filling see AVOptions, options.c and
    /// sws_setColorspaceDetails().
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    /// Initialize the swscaler context sws_context.
    ///
    /// @return zero or positive value on success, a negative value on
    /// error
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Free the swscaler context swsContext.
    /// If swsContext is NULL, then does nothing.
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    /// Allocate and return an SwsContext. You need it to perform
    /// scaling/conversion operations using sws_scale().
    ///
    /// @param srcW the width of the source image
    /// @param srcH the height of the source image
    /// @param srcFormat the source image format
    /// @param dstW the width of the destination image
    /// @param dstH the height of the destination image
    /// @param dstFormat the destination image format
    /// @param flags specify which algorithm and options to use for rescaling
    /// @param param extra parameters to tune the used scaler
    /// For SWS_BICUBIC param[0] and [1] tune the shape of the basis
    /// function, param[0] tunes f(1) and param[1] f´(1)
    /// For SWS_GAUSS param[0] tunes the exponent and thus cutoff
    /// frequency
    /// For SWS_LANCZOS param[0] tunes the width of the window function
    /// @return a pointer to an allocated context, or NULL in case of error
    /// @note this function is to be removed after a saner alternative is
    /// written
    pub fn sws_getContext(
        srcW: lang_items::c_int,
        srcH: lang_items::c_int,
        srcFormat: AVPixelFormat,
        dstW: lang_items::c_int,
        dstH: lang_items::c_int,
        dstFormat: AVPixelFormat,
        flags: lang_items::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    /// Scale the image slice in srcSlice and put the resulting scaled
    /// slice in the image in dst. A slice is a sequence of consecutive
    /// rows in an image.
    ///
    /// Slices have to be provided in sequential order, either in
    /// top-bottom or bottom-top order. If slices are provided in
    /// non-sequential order the behavior of the function is undefined.
    ///
    /// @param c         the scaling context previously created with
    /// sws_getContext()
    /// @param srcSlice  the array containing the pointers to the planes of
    /// the source slice
    /// @param srcStride the array containing the strides for each plane of
    /// the source image
    /// @param srcSliceY the position in the source image of the slice to
    /// process, that is the number (counted starting from
    /// zero) in the image of the first row of the slice
    /// @param srcSliceH the height of the source slice, that is the number
    /// of rows in the slice
    /// @param dst       the array containing the pointers to the planes of
    /// the destination image
    /// @param dstStride the array containing the strides for each plane of
    /// the destination image
    /// @return          the height of the output slice
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const lang_items::c_int,
        srcSliceY: lang_items::c_int,
        srcSliceH: lang_items::c_int,
        dst: *const *mut u8,
        dstStride: *const lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
    /// @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
    /// @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
    /// @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
    /// @param brightness 16.16 fixed point brightness correction
    /// @param contrast 16.16 fixed point contrast correction
    /// @param saturation 16.16 fixed point saturation correction
    /// @return -1 if not supported
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const lang_items::c_int,
        srcRange: lang_items::c_int,
        table: *const lang_items::c_int,
        dstRange: lang_items::c_int,
        brightness: lang_items::c_int,
        contrast: lang_items::c_int,
        saturation: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// @return -1 if not supported
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut lang_items::c_int,
        srcRange: *mut lang_items::c_int,
        table: *mut *mut lang_items::c_int,
        dstRange: *mut lang_items::c_int,
        brightness: *mut lang_items::c_int,
        contrast: *mut lang_items::c_int,
        saturation: *mut lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Allocate and return an uninitialized vector with length coefficients.
    pub fn sws_allocVec(length: lang_items::c_int) -> *mut SwsVector;
}
extern "C" {
    /// Return a normalized Gaussian curve used to filter stuff
    /// quality = 3 is high quality, lower is lower quality.
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    /// Scale all the coefficients of a by the scalar value.
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    /// Scale all the coefficients of a so that their sum equals height.
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_getConstVec(c: f64, length: lang_items::c_int) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_getIdentityVec() -> *mut SwsVector;
}
extern "C" {
    pub fn sws_convVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_addVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_subVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_shiftVec(a: *mut SwsVector, shift: lang_items::c_int);
}
extern "C" {
    pub fn sws_cloneVec(a: *mut SwsVector) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_printVec2(a: *mut SwsVector, log_ctx: *mut AVClass, log_level: lang_items::c_int);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: lang_items::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    /// Check if context can be reused, otherwise reallocate a new one.
    ///
    /// If context is NULL, just calls sws_getContext() to get a new
    /// context. Otherwise, checks if the parameters are the ones already
    /// saved in context. If that is the case, returns the current
    /// context. Otherwise, frees context and gets a new context with
    /// the new parameters.
    ///
    /// Be warned that srcFilter and dstFilter are not checked, they
    /// are assumed to remain the same.
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: lang_items::c_int,
        srcH: lang_items::c_int,
        srcFormat: AVPixelFormat,
        dstW: lang_items::c_int,
        dstH: lang_items::c_int,
        dstFormat: AVPixelFormat,
        flags: lang_items::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    /// Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
    ///
    /// The output frame will have the same packed format as the palette.
    ///
    /// @param src        source frame buffer
    /// @param dst        destination frame buffer
    /// @param num_pixels number of pixels to convert
    /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: lang_items::c_int,
        palette: *const u8,
    );
}
extern "C" {
    /// Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
    ///
    /// With the palette format "ABCD", the destination frame ends up with the format "ABC".
    ///
    /// @param src        source frame buffer
    /// @param dst        destination frame buffer
    /// @param num_pixels number of pixels to convert
    /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: lang_items::c_int,
        palette: *const u8,
    );
}
extern "C" {
    /// Get the AVClass for swsContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn sws_get_class() -> *const AVClass;
}
pub const SwrDitherType_SWR_DITHER_NONE: SwrDitherType = 0;
pub const SwrDitherType_SWR_DITHER_RECTANGULAR: SwrDitherType = 1;
pub const SwrDitherType_SWR_DITHER_TRIANGULAR: SwrDitherType = 2;
pub const SwrDitherType_SWR_DITHER_TRIANGULAR_HIGHPASS: SwrDitherType = 3;
/// < not part of API/ABI
pub const SwrDitherType_SWR_DITHER_NS: SwrDitherType = 64;
pub const SwrDitherType_SWR_DITHER_NS_LIPSHITZ: SwrDitherType = 65;
pub const SwrDitherType_SWR_DITHER_NS_F_WEIGHTED: SwrDitherType = 66;
pub const SwrDitherType_SWR_DITHER_NS_MODIFIED_E_WEIGHTED: SwrDitherType = 67;
pub const SwrDitherType_SWR_DITHER_NS_IMPROVED_E_WEIGHTED: SwrDitherType = 68;
pub const SwrDitherType_SWR_DITHER_NS_SHIBATA: SwrDitherType = 69;
pub const SwrDitherType_SWR_DITHER_NS_LOW_SHIBATA: SwrDitherType = 70;
pub const SwrDitherType_SWR_DITHER_NS_HIGH_SHIBATA: SwrDitherType = 71;
/// < not part of API/ABI
pub const SwrDitherType_SWR_DITHER_NB: SwrDitherType = 72;
/// Dithering algorithms
pub type SwrDitherType = u32;
/// < SW Resampler
pub const SwrEngine_SWR_ENGINE_SWR: SwrEngine = 0;
/// < SoX Resampler
pub const SwrEngine_SWR_ENGINE_SOXR: SwrEngine = 1;
/// < not part of API/ABI
pub const SwrEngine_SWR_ENGINE_NB: SwrEngine = 2;
/// Resampling Engines
pub type SwrEngine = u32;
/// < Cubic
pub const SwrFilterType_SWR_FILTER_TYPE_CUBIC: SwrFilterType = 0;
/// < Blackman Nuttall windowed sinc
pub const SwrFilterType_SWR_FILTER_TYPE_BLACKMAN_NUTTALL: SwrFilterType = 1;
/// < Kaiser windowed sinc
pub const SwrFilterType_SWR_FILTER_TYPE_KAISER: SwrFilterType = 2;
/// Resampling Filter Types
pub type SwrFilterType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Get the AVClass for SwrContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    /// @return the AVClass of SwrContext
    pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
    /// Allocate SwrContext.
    ///
    /// If you use this function you will need to set the parameters (manually or
    /// with swr_alloc_set_opts()) before calling swr_init().
    ///
    /// @see swr_alloc_set_opts(), swr_init(), swr_free()
    /// @return NULL on error, allocated context otherwise
    pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
    /// Initialize context after user parameters have been set.
    /// @note The context must be configured using the AVOption API.
    ///
    /// @see av_opt_set_int()
    /// @see av_opt_set_dict()
    ///
    /// @param[in,out]   s Swr context to initialize
    /// @return AVERROR error code in case of failure.
    pub fn swr_init(s: *mut SwrContext) -> lang_items::c_int;
}
extern "C" {
    /// Check whether an swr context has been initialized or not.
    ///
    /// @param[in]       s Swr context to check
    /// @see swr_init()
    /// @return positive if it has been initialized, 0 if not initialized
    pub fn swr_is_initialized(s: *mut SwrContext) -> lang_items::c_int;
}
extern "C" {
    /// Allocate SwrContext if needed and set/reset common parameters.
    ///
    /// This function does not require s to be allocated with swr_alloc(). On the
    /// other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters
    /// on the allocated context.
    ///
    /// @param s               existing Swr context if available, or NULL if not
    /// @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)
    /// @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).
    /// @param out_sample_rate output sample rate (frequency in Hz)
    /// @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)
    /// @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).
    /// @param in_sample_rate  input sample rate (frequency in Hz)
    /// @param log_offset      logging level offset
    /// @param log_ctx         parent logging context, can be NULL
    ///
    /// @see swr_init(), swr_free()
    /// @return NULL on error, allocated context otherwise
    pub fn swr_alloc_set_opts(
        s: *mut SwrContext,
        out_ch_layout: i64,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: lang_items::c_int,
        in_ch_layout: i64,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: lang_items::c_int,
        log_offset: lang_items::c_int,
        log_ctx: *mut lang_items::c_void,
    ) -> *mut SwrContext;
}
extern "C" {
    /// Free the given SwrContext and set the pointer to NULL.
    ///
    /// @param[in] s a pointer to a pointer to Swr context
    pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
    /// Closes the context so that swr_is_initialized() returns 0.
    ///
    /// The context can be brought back to life by running swr_init(),
    /// swr_init() can also be used without swr_close().
    /// This function is mainly provided for simplifying the usecase
    /// where one tries to support libavresample and libswresample.
    ///
    /// @param[in,out] s Swr context to be closed
    pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
    /// Convert audio.
    ///
    /// in and in_count can be set to 0 to flush the last few samples out at the
    /// end.
    ///
    /// If more input is provided than output space, then the input will be buffered.
    /// You can avoid this buffering by using swr_get_out_samples() to retrieve an
    /// upper bound on the required number of output samples for the given number of
    /// input samples. Conversion will run directly without copying whenever possible.
    ///
    /// @param s         allocated Swr context, with parameters set
    /// @param out       output buffers, only the first one need be set in case of packed audio
    /// @param out_count amount of space available for output in samples per channel
    /// @param in        input buffers, only the first one need to be set in case of packed audio
    /// @param in_count  number of input samples available in one channel
    ///
    /// @return number of samples output per channel, negative value on error
    pub fn swr_convert(
        s: *mut SwrContext,
        out: *mut *mut u8,
        out_count: lang_items::c_int,
        in_: *mut *const u8,
        in_count: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Convert the next timestamp from input to output
    /// timestamps are in 1/(in_sample_rate * out_sample_rate) units.
    ///
    /// @note There are 2 slightly differently behaving modes.
    /// @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
    /// in this case timestamps will be passed through with delays compensated
    /// @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)
    /// in this case the output timestamps will match output sample numbers.
    /// See ffmpeg-resampler(1) for the two modes of compensation.
    ///
    /// @param s[in]     initialized Swr context
    /// @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown
    /// @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
    /// function used internally for timestamp compensation.
    /// @return the output timestamp for the next output sample
    pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
    /// Activate resampling compensation ("soft" compensation). This function is
    /// internally called when needed in swr_next_pts().
    ///
    /// @param[in,out] s             allocated Swr context. If it is not initialized,
    /// or SWR_FLAG_RESAMPLE is not set, swr_init() is
    /// called with the flag set.
    /// @param[in]     sample_delta  delta in PTS per sample
    /// @param[in]     compensation_distance number of samples to compensate for
    /// @return    >= 0 on success, AVERROR error codes if:
    /// @li @c s is NULL,
    /// @li @c compensation_distance is less than 0,
    /// @li @c compensation_distance is 0 but sample_delta is not,
    /// @li compensation unsupported by resampler, or
    /// @li swr_init() fails when called.
    pub fn swr_set_compensation(
        s: *mut SwrContext,
        sample_delta: lang_items::c_int,
        compensation_distance: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Set a customized input channel mapping.
    ///
    /// @param[in,out] s           allocated Swr context, not yet initialized
    /// @param[in]     channel_map customized input channel mapping (array of channel
    /// indexes, -1 for a muted channel)
    /// @return >= 0 on success, or AVERROR error code in case of failure.
    pub fn swr_set_channel_mapping(
        s: *mut SwrContext,
        channel_map: *const lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Generate a channel mixing matrix.
    ///
    /// This function is the one used internally by libswresample for building the
    /// default mixing matrix. It is made public just as a utility function for
    /// building custom matrices.
    ///
    /// @param in_layout           input channel layout
    /// @param out_layout          output channel layout
    /// @param center_mix_level    mix level for the center channel
    /// @param surround_mix_level  mix level for the surround channel(s)
    /// @param lfe_mix_level       mix level for the low-frequency effects channel
    /// @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent
    /// overflow. if INT_MAX, coefficients will not be
    /// normalized.
    /// @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
    /// the weight of input channel i in output channel o.
    /// @param stride              distance between adjacent input channels in the
    /// matrix array
    /// @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
    /// @param log_ctx             parent logging context, can be NULL
    /// @return                    0 on success, negative AVERROR code on failure
    pub fn swr_build_matrix(
        in_layout: u64,
        out_layout: u64,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        rematrix_maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: lang_items::c_int,
        matrix_encoding: AVMatrixEncoding,
        log_ctx: *mut lang_items::c_void,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Set a customized remix matrix.
    ///
    /// @param s       allocated Swr context, not yet initialized
    /// @param matrix  remix coefficients; matrix[i + stride * o] is
    /// the weight of input channel i in output channel o
    /// @param stride  offset between lines of the matrix
    /// @return  >= 0 on success, or AVERROR error code in case of failure.
    pub fn swr_set_matrix(
        s: *mut SwrContext,
        matrix: *const f64,
        stride: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Drops the specified number of output samples.
    ///
    /// This function, along with swr_inject_silence(), is called by swr_next_pts()
    /// if needed for "hard" compensation.
    ///
    /// @param s     allocated Swr context
    /// @param count number of samples to be dropped
    ///
    /// @return >= 0 on success, or a negative AVERROR code on failure
    pub fn swr_drop_output(s: *mut SwrContext, count: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Injects the specified number of silence samples.
    ///
    /// This function, along with swr_drop_output(), is called by swr_next_pts()
    /// if needed for "hard" compensation.
    ///
    /// @param s     allocated Swr context
    /// @param count number of samples to be dropped
    ///
    /// @return >= 0 on success, or a negative AVERROR code on failure
    pub fn swr_inject_silence(s: *mut SwrContext, count: lang_items::c_int) -> lang_items::c_int;
}
extern "C" {
    /// Gets the delay the next input sample will experience relative to the next output sample.
    ///
    /// Swresample can buffer data if more input has been provided than available
    /// output space, also converting between sample rates needs a delay.
    /// This function returns the sum of all such delays.
    /// The exact delay is not necessarily an integer value in either input or
    /// output sample rate. Especially when downsampling by a large value, the
    /// output sample rate may be a poor choice to represent the delay, similarly
    /// for upsampling and the input sample rate.
    ///
    /// @param s     swr context
    /// @param base  timebase in which the returned delay will be:
    /// @li if it's set to 1 the returned delay is in seconds
    /// @li if it's set to 1000 the returned delay is in milliseconds
    /// @li if it's set to the input sample rate then the returned
    /// delay is in input samples
    /// @li if it's set to the output sample rate then the returned
    /// delay is in output samples
    /// @li if it's the least common multiple of in_sample_rate and
    /// out_sample_rate then an exact rounding-free delay will be
    /// returned
    /// @returns     the delay in 1 / @c base units.
    pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
    /// Find an upper bound on the number of samples that the next swr_convert
    /// call will output, if called with in_samples of input samples. This
    /// depends on the internal state, and anything changing the internal state
    /// (like further swr_convert() calls) will may change the number of samples
    /// swr_get_out_samples() returns for the same number of input samples.
    ///
    /// @param in_samples    number of input samples.
    /// @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()
    /// or swr_set_compensation() invalidates this limit
    /// @note it is recommended to pass the correct available buffer size
    /// to all functions like swr_convert() even if swr_get_out_samples()
    /// indicates that less would be used.
    /// @returns an upper bound on the number of samples that the next swr_convert
    /// will output or a negative value to indicate an error
    pub fn swr_get_out_samples(
        s: *mut SwrContext,
        in_samples: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
    ///
    /// This is useful to check if the build-time libswresample has the same version
    /// as the run-time one.
    ///
    /// @returns     the unsigned int-typed version
    pub fn swresample_version() -> lang_items::c_uint;
}
extern "C" {
    /// Return the swr build-time configuration.
    ///
    /// @returns     the build-time @c ./configure flags
    pub fn swresample_configuration() -> *const lang_items::c_char;
}
extern "C" {
    /// Return the swr license.
    ///
    /// @returns     the license of libswresample, determined at build-time
    pub fn swresample_license() -> *const lang_items::c_char;
}
extern "C" {
    /// Convert the samples in the input AVFrame and write them to the output AVFrame.
    ///
    /// Input and output AVFrames must have channel_layout, sample_rate and format set.
    ///
    /// If the output AVFrame does not have the data pointers allocated the nb_samples
    /// field will be set using av_frame_get_buffer()
    /// is called to allocate the frame.
    ///
    /// The output AVFrame can be NULL or have fewer allocated samples than required.
    /// In this case, any remaining samples not written to the output will be added
    /// to an internal FIFO buffer, to be returned at the next call to this function
    /// or to swr_convert().
    ///
    /// If converting sample rate, there may be data remaining in the internal
    /// resampling delay buffer. swr_get_delay() tells the number of
    /// remaining samples. To get this data as output, call this function or
    /// swr_convert() with NULL input.
    ///
    /// If the SwrContext configuration does not match the output and
    /// input AVFrame settings the conversion does not take place and depending on
    /// which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED
    /// or the result of a bitwise-OR of them is returned.
    ///
    /// @see swr_delay()
    /// @see swr_convert()
    /// @see swr_get_delay()
    ///
    /// @param swr             audio resample context
    /// @param output          output AVFrame
    /// @param input           input AVFrame
    /// @return                0 on success, AVERROR on failure or nonmatching
    /// configuration.
    pub fn swr_convert_frame(
        swr: *mut SwrContext,
        output: *mut AVFrame,
        input: *const AVFrame,
    ) -> lang_items::c_int;
}
extern "C" {
    /// Configure or reconfigure the SwrContext using the information
    /// provided by the AVFrames.
    ///
    /// The original resampling context is reset even on failure.
    /// The function calls swr_close() internally if the context is open.
    ///
    /// @see swr_close();
    ///
    /// @param swr             audio resample context
    /// @param output          output AVFrame
    /// @param input           input AVFrame
    /// @return                0 on success, AVERROR on failure.
    pub fn swr_config_frame(
        swr: *mut SwrContext,
        out: *const AVFrame,
        in_: *const AVFrame,
    ) -> lang_items::c_int;
}
pub type __builtin_va_list = __va_list;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list {
    pub __stack: *mut lang_items::c_void,
    pub __gr_top: *mut lang_items::c_void,
    pub __vr_top: *mut lang_items::c_void,
    pub __gr_offs: lang_items::c_int,
    pub __vr_offs: lang_items::c_int,
}
#[test]
fn bindgen_test_layout___va_list() {
    assert_eq!(
        std::mem::size_of::<__va_list>(),
        32usize,
        concat!("Size of: ", stringify!(__va_list))
    );
    assert_eq!(
        std::mem::align_of::<__va_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list))
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__va_list>())).__stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__stack)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__va_list>())).__gr_top as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__gr_top)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__va_list>())).__vr_top as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__vr_top)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__va_list>())).__gr_offs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__gr_offs)
        )
    );
    assert_eq!(
        unsafe { &(*(std::ptr::null::<__va_list>())).__vr_offs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__vr_offs)
        )
    );
}
/// Array of pointers to hardware configurations supported by the codec,
/// or NULL if no hardware supported.  The array is terminated by a NULL
/// pointer.
///
/// The user can only access this field via avcodec_get_hw_config().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfigInternal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct URLContext {
    pub _address: u8,
}
